# 计算机科学导论



## 第一章

什么是计算机？

图灵模型（数学和哲学意义上的定义）

现代计算机参考模型——冯诺伊曼模型



### 图灵模型

图灵机模型：一个通用计算机设备（它能处理多种不同类型的数据）——图灵机，图灵模型是一个适用于通用计算机的模型。图灵通过对人类进行计算的过程进行抽象，然后建立该模型。



数据处理器模型：计算机可以被看作是一个接受输入数据，处理数据并产生输出数据的黑盒。特点是：这种定义太宽泛，这个模型没有说明他能处理的数据的类型，能完成的操作和数量，是专用还是通用的机器。这个模型不属于图灵模型的范畴。

![image-20230104131448366](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230104131448366.png)



可编程数据处理器模型（图灵模型）：

![image-20230104131500898](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230104131500898.png)

**程序是用来告诉计算机对数据进行处理的一系列指令的集合。**完成某一任务的程序是通过操作一系列的开关或者改变其配线来实现对数据的处理。



输出依赖于输入的数据和程序。

![image-20230111214540101](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230111214540101.png)



### 冯诺伊曼模型

图灵模型中的计算机在存储器中只存储数据。冯诺伊曼模型则指出，数据和程序（都是以二进制序列的形式存储）在逻辑上是相同的，所以程序也可以存储在存储器中。

冯诺伊曼模型计算机有4个子系统：

1. 存储器
2. 算数逻辑运算单元
3. 控制单元
4. 输入/输出单元

![image-20230111214847996](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230111214847996.png)

存储器：存储数据和程序。数据和程序具有相同的格式，都是以二进制格式（位模式）存储在存储器中的。

算数逻辑运算单元：对数据进行算数和逻辑运算。

控制单元：对其他子系统进行操作控制。

输入单元：从计算机外部接受输入的数据和程序。

输出单元：将计算机处理的结果输出到计算机外部。有些设备既可以是输入设备，也可以是输出设备。



冯诺伊曼模型中的一个程序是由一组数量有限的指令组成的一个集合。在这个模型中，控制单元从内存中取出一条指令，解释指令，将解析的结果自行处理或者将给算数逻辑单元处理，然后将数据回写到内存中或者寄存器中。一条指令可以操作一个或者多个数据。

指令是一条接着一条顺序执行的，当然，一些指令可能会让控制解析为跳转到其他指令所在位置（前面或者后面），然后执行该位置上的指令，但也还是遵循顺序执行的原则的。



### 计算机的组成

计算的组成部分：

1. 计算机硬件
2. 数据
3. 计算机软件



现代计算机的硬件是基于冯诺伊曼模型划分。



存储数据：电子计算存储数据的方式就是通过电信号有无或者高低来存储数据。有无和高低只能覆盖两种状态。日常生活中的很多数据的状态远远多于两种，所以无法将这类数据原样存储到存储器中，必须将这些数据（十进制数字，图片，文字，音视频等）转为另一种只使用两种状态（0和1）的表示的数据才能存储到计算机中。

组织数据：数据被组织成许多小单元，再由这些小单元组成一个更大的单元（类似于各种数据的编码和解码方式）



软件：

早期计算机并没有将程序存储在计算机的存储器中，但是程序仍旧是存在的。编程在计算机早期体现为系列开关的打开和闭合以及配线的改变。

在冯诺依曼模型中，程序和数据都存放在计算机的存储器中。且程序必须是有序的指令集，每一条指令可以操作一个或者多个数据项。



编程语言：计算机早期只有一种编程语言——机器语言，机器语言组成指令，指令组成最后的程序。  后面计算机科学家发明了利用符号来代表指令，这就产生了高级编程语言。

软件工程：结构化程序的设计和编写，现在不仅用来描述完成某一任务的应用程序，还包括程序设计中所需要严格遵循的原理和规则。

操作系统：有一系列的指令对于所有的应用程序来说都是公用的，比如数据加载指令，写入指令。这些指令只需要编写一个就可以用于所有程序，基于这个需求就产生的操作系统。计算机操作系统最初是为了程序访问计算机的硬件提供方便的一种管理程序。



### 计算机科学的划分

- 系统领域：涵盖那些与硬件和软件直接相关的领域，如：计算机体系结构，计算机网络，网络安全，操作系统，算法，程序设计语言等。
- 应用领域：应用软件，数据库，人工指令等。







## 数字系统（进制系统）

不同的数字系统定义了一套各自的不同的符号集合来表示一个数值。在不同的进制系统中，同一个数值有不同的表示方法。例如16进制中的2A和8进制中的52在十进制中都代表42。



### 位置化数字系统

在该系统中，数字中符号所占据的位置决定了其表示的值，该系统中，数字如下表示：

![image-20230111230711592](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230111230711592.png)

它对应的值：

![image-20230111230746206](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230111230746206.png)

S：一套符号集

b：底（基数），b就等于S符号集中的符号的总数

b的负数次幂表示该数字的小数部分，非负数次幂表示整数部分。



#### 十进制

S：{0，1，2，3，4，5，6，7，8，9}

b：10

![image-20230112201646521](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112201646521.png)



![image-20230112201736951](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112201736951.png)

计算机中存储十进制数的正负有不同的方式。





#### 二进制

S：{0，1}

b：2

数据和程序在计算机内部都是以二进制模式存储，这是因为计算机由电子开关（晶体管）制成，他们仅有两种状态——开和关。

![image-20230112202555396](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112202555396.png)





#### 十六进制

S：{0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F}

b：16

![image-20230112210935145](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112210935145.png)

含有小数部分的数值很少用十六进制来表示。



#### 八进制

S：{0，1，2，3，4，5，6，7，8}

b：8

![image-20230112211055976](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112211055976.png)

含有小数部分的数值很少用八进制来表示。



![image-20230112211141044](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112211141044.png)





### 进制转换

其他进制转为十进制：

![image-20230112211357931](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112211357931.png)

十进制转为其他进制：

- **整数部分转换**：可以使用连除。

![image-20230112211748565](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112211748565.png)

上图中说的插入目标数的左边是说基于前一次计算得出的数，下一次计算得到的余数插入前面得到的数的左边。

源：十进制的整数部分。

目标：转换为对应进制数的整数部分

```js
function decTobini(value) {
  let bini = '';
  let remainder;
  do {
    remainder = value % 2;
    value = parseInt(value / 2);
    bini = remainder + bini;
  } while (value !== 0);

  return bini;
}
```



![image-20230112212154841](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112212154841.png)



例子：

十进制的35转为2进制（35 = 100011）

![image-20230112212517840](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112212517840.png)



十进制的126转为8进制（126 = 176）

![image-20230112212709871](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112212709871.png)

十进制的126转为16进制（126 = 7E）

![image-20230112212754237](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112212754237.png)



- 小数部分转换：使用连乘法。

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112215007271.png" alt="image-20230112215007271" style="zoom: 200%;" />



<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112215158531.png" alt="image-20230112215158531" style="zoom: 200%;" />

```js
function decTobini(value) {
  let bini = '';
  let integer;
  do {
    integer = parseInt(value * 2);
    value = integer === 1?value * 2 - 1: value * 2;
    bini += integer;
  } while (value !== 0);
  return bini;
}

console.log(decTobini(0.00005));
```



例子：

十进制小数0.625转为2进制（0.625 = 0.101）

![image-20230112215431865](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112215431865.png)



十进制小数0.634转为8进制，精确到4位小数（0.634 = 0.5044）

![image-20230112215548405](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112215548405.png)





十进制178.6转为16进制并精确到1位小数（B2.9）

![image-20230112220353395](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112220353395.png)



**二进制与16进制相互转换**

二进制和16进制之间有一个固定的对应关系：二进制中的4位恰好是16进制中的一位。

![image-20230112221003795](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112221003795.png)

例子：

将二进制：10011100010转为16进制

先将二进制数排为4个一组100 1110 0010，其中最左边的一组可能位数不到4位。



**二进制和八进制的转换**

3位二进制数能代表一位八进制数。

![image-20230112221603992](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112221603992.png)



**八进制和十六进制进制转换**

可以根据上面的规律，将二进制作为中介来实现转换。

![image-20230112221750946](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230112221750946.png)





## 数据存储

计算是一种机器，它用来处理数据，具体通过加载不同的程序实现对不同数据的处理。

处理数据之前，需要先理解什么是数据，数据的特征以及不同的数据类型如何存储到计算机中。

### 数据类型

**数据的类型：文字，数字，音视频，图片等。**

不同的程序能处理不同类型的数据。

### 位

位是计算机中的最小存储单位（由一位二级制0或者1表示）。



### 位模式

所有不同类型的数据都是以二进制的表达形式存入计算机的。——这种格式被称为 **位模式**

位模式是一个规定了固定位数的二进制序列，比如8位二进制构成的位模式（一字节），16位二进制数构成的位模式。

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115214035580.png" alt="image-20230115214035580" style="zoom:50%;" />

不同数据类型的数据可以相同的位模式存储在内存中。



### 存储数字

数字在存入计算机之前被转为二进制来表示。但是有两点需要注意：

1. **存储数字的正负问题**
2. **如何表示小数问题**

在计算机中处理数字的符号的方法较多。对于小数，计算机使用两种不同的表示方法，定点和浮点。

**定点**：用于把数字看作整数存储，没有小数部分。

**浮点**：用于把数字看作实数存储，带有小数部分。

为了有效的利用电脑的内存空间来表示尽可能多的数字，计算机中针对无符号，有符号整数的存储为二进制之前的转换方式是不同。



#### 存储整数

正整数和负整数。整数可以被看作小数点位置固定的数，小数点固定在最右边。在这种表示法中，小数点是假定的，并不存储到计算机中。

![image-20230115181808283](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115181808283.png)



##### 无符号整数

0和正整数。计算机不可能表示出所有的正整数，所以，计算机都定义了一个常量，称为最大无符号整数，一般为（2^n-1）。

采用指定的位模式来存储一个无符号整数的步骤：

1. 将整数转为二进制形式
2. 如果转换后的二进制数不足位模式的指定位数，则左侧补0，使得位数满足，
3. 如果转换后的二进制数超过位模式的指定位数，则超出部分**溢出**，导致看上去同一个二进制数能表示两个不同的数值的错觉



##### 溢出

因为计算机底层硬件上存储单元数量的限制，可以表达的数字范围是有限的。

存储数字到由4个二进制组成的一个位模式中的益处情况：

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115183029709.png" alt="image-20230115183029709" style="zoom:33%;" />

十进制11的二进制形式是1011，再加上9，导致超出4位二机制能表示的最大数字——15（2^4-1）。所以溢出，十进制的20用二机制表示是10100，左边的高位溢出舍弃，留下0100。



无符号整数存储方式的应用：

1. 计数使用
2. 寻址，内存地址都是从0开始的非负整数
3. 计算机中的文本，图片，视频都是以位模式存储，可以被解码为无符号整数



##### 有符号整数

符号加绝对值表示法，在无符号整数表示法中，可以表示2^n-1个正整数的范围被平均分为两半，前一半用来表示正整数，后一半表示负整数。

以4位二进制数组成位模式为例：

![image-20230115190030502](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115190030502.png)

其中0有两个表示方式0000和1000。

**该种表示法中，最高位用于表示正负（0表示正，1表示负）。**



##### 溢出

分为正负两种溢出。以4位二进制数位模式为例子：

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115190850620.png" alt="image-20230115190850620" style="zoom:50%;" />

这种表示方法通常用于采样模拟信号，如音频。





##### 补码表示法

最常用的有符号整数的表示方法。这种表示方法中2^n-1被平均分为两个相等的范围，第一个范围用来表示非负数整数，另一个范围用来表示负数整数。以4位二进制数为例：

![image-20230115191526484](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115191526484.png)



反码：将一个数的二进制形式上的每一位有由1变为0或者由0变为1

补码：先将一个数的二进制形式从低位（右侧）开始复制，知道遇到第一个1被复制之后，该1复制位左侧的位上的数字依次取反得到。例子：

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115203353794.png" alt="image-20230115203353794" style="zoom:50%;" />

另一种计算补码的方式：先对原来数字的二进制数字进行一次取反操作，然后在取反的结果上再加1。

计算机采用二进制补码存储数字的步骤：

1. 将整数转为二进制数
2. 如果整数是正数或者0，原样保存到计算机中，如果是负数，则取正整数对应补码存储



将以补码方式保存在计算机中的二进制数转为10进制数步骤：

1. 如果二进制数最左边是1，则取该二进制数的补码；如果最左边是0，不做操作
2. 将上一步得到的二进制数转为10进制



<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115220558397.png" alt="image-20230115220558397" style="zoom:50%;" />









##### 溢出

![image-20230115204834545](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115204834545.png)



#### 实数

既有整数部分也有小数部分的数字。

表示实数的方法——定点表示法，但是这种方式的能表示的数字的范围会大大折扣。所以带有很大的整数和很小的小数部分的实数不应该用定点表示法表示，精度也有损失。



##### 浮点表示法

既能保证正确度，又能保证精确度。

该表示法允许小数点的位置不固定（浮动），可以在小数点的左右两侧有不同数量的数码。这极大的增加了可存储的实数的范围。

在浮点表示法中，一个数字由三部分组成：

![image-20230115210040003](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115210040003.png)

符号(s)：可正可负。

位移量(e)：表示小数点应该左右移动**构成实际数字**的位移量（十进制形式的需要转为二进制后存入内存中）。

定点数(f)：小数点位置固定的定点表示法。

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115210508441.png" alt="image-20230115210508441" style="zoom:50%;" />

上图中符号为+，位移量为21，定点数部分为7.425。

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115210948559.png" alt="image-20230115210948559" style="zoom:50%;" />





科学计数法用于二进制数：

![image-20230307202059558](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20230307202059558.png)



![image-20230307202046881](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20230307202046881.png)



根据浮点数表示得出，如果存储一个实数，现在只需要存储一个数的3部分信息就可以：符号，指数和尾数。

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230115212020977.png" alt="image-20230115212020977" style="zoom:50%;" />

符号：用一位二进制数表示。

指数：定义为小数点移动的位数（可正可负），用**余码表示法**转换十进制的指数为二进制之后存储在内存中。

尾数：小数点右边的二进制数字，它定义了数字精度，尾数是用无符号整数存储的。



##### 规范化

科学计数法是用于十进制的，而浮点数表示法是用于二进制的。为了使表示法的固定部分统一，**它们都在小数点左边使用了唯一的非零数码，这称为规范化**。

![image-20230130130308814](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130130308814.png)

内存中只需要存储规范化后的数字的符号位，指数位和尾数位就可以。

- 符号：一 个 数 的 符 号 可 以 用 一 个 二进 制 位 来 存 储 (0 或 1 )。
- 指数：指 数 (2 的 幂 ) 定 义 为 小 数 点 移 动 的 位 数 。 注 意 幂可 以 为 正 也 可 以 为 负 。 余 码 表 示 法 ( 后面讨论)是用来存储指数位的方法。
- 尾数：尾数是指小数点右边的 二进制数。它定义了该数的精度。尾数是作为无符号整数存储的（它不是整数，而是像整数那样存储的小数部分）。



##### 余码表示法

指数（即显示多少位小数点应该左移或右移的幂次）是有符号的、且为十进制的形式表示的。虽然可以使用补码表示法将十进制的指数转为二进制数后存储，但实际上使用的是一种称为**余码系统**的新的表示法来转为二进制形式后存储的。

在该余码系统中，正的和负的十进制整数都可以作为无符号数存储。为了表示正的或负的十进制整数，用一个正十进制称为偏移量的整数加到每个十进制数字中，将它们统一移到非负的一边。这个偏移量的值是2^m-1 - 1，m是内存单元存储指数的大小。

![image-20230130132145506](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130132145506.png)

这种新的表示法与移位前的表示法相比，其优点在于在余码系统中的所有整数都是正数， 当我们对这些整数进行比较或运算时，不需要考虑符号。对于 4 位存储单元，如我们希望的那样，偏移量是2^(4-1) - 1=7。



##### IEEE标准

所有的浮点数都是区分符号的。

IEEE定义了几种存储浮点数的表示标准。最常用的——**单精度和双精度**。

![image-20230130132434620](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130132434620.png)

单精度数格式采用总共32位来存储一个二进制数规范化后的各个部分。

符号占用1位(0 为正，1 为 负 )，指数占用8位(使用偏移量127)，尾数使用23位(无符号数)。

双精度数格式采用总共64位来存储一个浮点表示法的实数。符号占用1位(0 为正，1 为负)，指数占用11位(使用偏移量1023 )，尾数使用52位。

![image-20230307221116283](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20230307221116283.png)



将一个**二进制**数以IEEE标准浮点数表示法存入内存中的步骤：

1. 先将二进制数规范化
2. 原数字是正，符号位取0；反之，取1
3. 提取出其中的指数（这里是以十进制表示的）和位数
4. 指数还需要加上偏移量后再转为二进制的形式表示
5. 然后直接拼接s,e和f



**将一个十进制的实数以IEEE标准以浮点数表示法存入内存中的步骤**：

1. 实数是正数，符号位(s)取0；反之，取1
2. 将实数转为二进制形式（可能存在精度损失）
3. 再将二进制数规范化
4. 提取出其中的指数（这里是以十进制表示的）和位数
5. 指数还需要加上偏移量后再转为二进制的形式表示
6. 然后直接拼接s,e和f



示例

将十进制5.75用浮点数表示。

1. 该数是正数，所以s=0

2. 将十进制5.75转为二进制表示，可以分开考虑，将整数部分5转为101，0.75转为0.11，所以5.75的二进制就是101.11

3. 将5.75对应的二进制进行规范化，101.11 = 1.0111 * 2^2

4. 然后将其中的E加上单精度浮点数的偏移量（2^(8-1) - 1 = 127） ，即E = 2+127 = 129

5. 将十进制的E转为8位的二进制表示，即10000001

6. F部分则是规范化后的数的小数点右侧的数字部分，即F = 0111

7. 对于位数不够的进行补零操作

   ![image-20230130192109562](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130192109562.png)



将十进制-161.875用单精度浮点数表示。

![image-20230130192222725](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130192222725.png)



将十进制-0.0234375用单精度浮点数表示。

![image-20230130192322694](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130192322694.png)

![image-20230130192340324](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130192340324.png)





**单精度浮点数还原为十进制数**

1. 找出浮点数中对应的S，E和F部分
2. 如果S=0，则十进制数为正数；反之，则为负数
3. 将二进制的E转为十进制，然后减去偏移量127
4. 然后根据原浮点数和E的大小进行去规范化
5. 将去规范化后的二进制数转为对应的10进制数
6. 加上符号即可



示例：

将内存中存储的位模式：1100101000000000010000111，以单精度浮点数规则转为十进制数。

![image-20230130193124810](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130193124810.png)



##### 浮点数溢出

对于浮点数，有**上滥和下溢**。 下图显示了使用32位内存单元 (余127码 )的浮点表示法范围。**该表示法不能存储很小或很大的绝对值**。试图存储绝对值很小的数导致 下溢的情况，而试图存储绝对值很大的数导致上溢的情况。

![image-20230130193529693](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130193529693.png)



##### 零

注意实数0及其的其他形式，如0.0，都是没办法使用上面十进制转浮点数的步骤进行存储的。因为0对应的二进制数在规范化的时候，小数点左边的那一位没法是1。参考如下：

![image-20230130194434029](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130194434029.png)

所以为了处理这个特例，约定在S=0，E=0，M=0时，表示的就是实数0。



##### 精度丢失

在用浮点数表示法存储一个十进制的实数时，最终存储到内存中的会是一个存在精度丢失的情况的。假如，需要往内存中存储一个未规范化的二进制数1111111111111111.1111111111。

该数字规范化后为：1. 11111111111111111111111111*2^15。但是在单精度浮点标准中，尾数只能有23位。

![image-20230130132434620](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130132434620.png)

所以这个尾数需要截短为23个1，换言之，存储在计算机中的是: 1. 11111111111111111111111

去规范化后的二进制数变为: 1111111111111111.11111111，只有23个1了，而原来的数有26个1。

小数部分右边的3了个1被截掉了。 这种原始数宇与还原后数字的差异称为截断错误 。 在使用很小或很大数字的地方，如宇航业的计算中，这种类型的错误是很严重的。这种情况下， 需要更大的内存单元和其他的表示法。为此，IEEE 定义了用于更大尾数的其他表示法。





#### 存储文本

一门语言的文本是由一系列的符号组成并能表达一定的含义。在英语中使用26个**符号**(A，B，C， ...，2)来表示大写字母，26个**符号**(a，b，c，...，2)表示小写字母，10个**符号**(0，1，2，...，9)来表示数字字符(不是等价于的数字)，以及符号( ，?，:，; ，...，!)来表示标点。另外一些符号(如空格、换行和制表符 )被用于文本的对齐和可读性。



可以通过特定的位模式（特定数量的0和1）来表示一个符号。比如英语单词“CATS”，可以用4个n位二进制数的位模式来表示。现在的问题是：**一门语言的所有文本符号，到底需要一个多少位二进制数的位模式才能全部表示，只能多余不能少于**。 这主要就取决于该语言集中到底有多少个不同的符号。

虽然位模式的长度取决于该门语言中符号的数量，但是它们的关系并不是线性的，**而是对数的**。 如果需要2个符号，位模式长度將是1位，如果需要4个符号，长度將是2位。同样，3位的位模式有8种不同的形式:000，001, 010, 011, 100, 101，110和11![image-20230130222949420](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230130222949420.png)



不同的位模式中所有可能的组合结果组成一个集合，该集合中的每一项都可以独立表示一个符号。一个集合就是被称为一个 **字符集**。而把一门语言中的不同符号转换为该字符集（代码）中一个特定的二进制组合项的过程就称为 **编码**。



##### ASCII字符集

美国信息交换标准代码（全写为 American Standard Code for Information Interchange），一套电脑编码系统。ASCII 码使用指定的8 位二进制数组合来表示256 种可能的字符（但是只用到了其中的127个就能表示所有美国人使用的全部字符了）。如今ASCII是Unicode字符集的一部分。



##### Unicode字符集

 这种字符集使用32位二进制数的不同组合来表示不同字符，能表示最大达2^32=4294967296 个符号。32位二进制数的不同部分被分配用于表示来自世界上不同语言的符号。其中还有些部分被用于表示图形和特殊符号。



#### 存储音频

音频即声音或者音乐。音频存储的本质和数字、文本不同。文本是有实体化的符号组合后与之一一对应，可以数出其中的符号的数量。但是，音频是不可数的，且音频随着时间的变化而变化。只能大致记录某一段时间声音的密度。

在计算机的内存中存储音频是，存储的是一个音频信号在一段时间内每个指定时刻的声音的密度。

音频是模拟数据。

![image-20230131130502492](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131130502492.png)

##### 采样

我们无法记录一段时间内音频信号的所有值，所以采用记录这一段时间内的一些值。在模拟信号上选择数量有限的点来度量他们的值并记录下来就是 **采样**。如下图：

![image-20230131130756447](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131130756447.png)

##### 采样率

每秒钟采集的音频信号上的样本值数量。如果模拟信号的变化剧烈，则需要采集更多的样本值，反之，则少采集。一般每秒钟采集40000个样本值的采集率就能满足对音频信号的记录。



##### 量化

每个采集的样本值都对应一个真实的数字，量化值的是将样本的值截取为最接近的整数值的一种过程。如，17.2取17；17.6取18。



##### 编码

量化后的样本值需要使用特定的编码方式进行编码，编码的结果就是将这些每一个数字转为特定的位模式来进行存储。一些编码方式为样本值赋正值或者负值。另一些则移动曲线到正的区间从而只赋正值。



##### 每样本位

对于采集到的每一个数值，系统需要决定分配多少位二进制数来存放该样本值。有8位，16位，24位甚至32位。每个样本值采用多少位来表示，这个位数就称为 **位深度**



##### 位率

如果称位深度或者每样本位的数量为B，则每秒采集的样本数为S，那么计算得出我们需要为每一秒的音频存储S*B位二进制数。

该乘积就称为 **位率R**。例如，每秒采集40000个样本值，每个样本值用16位二进制数来表示，那么位率R=40000*16=640000b/s = 640KB/s。

常见音频编码方式是：MP3，R=44100 *16。它是一种有损压缩方法。





#### 存储图像

计算机存储图像使用两种不同的技术：**光栅图和矢量图**

##### 光栅图

存储模拟图像（照片）时，用的是光栅图（位图）。一张照由模拟数据组成，类似音频信息。不同的是数据密度（色彩）因空间而变化，而不是时间而变化。所以数据还是需要采样，这种方式的采样又被称为 **扫描**。 采样得到的数据不再是具体的一个数值，而是一个像素（图像的元素）。即整个图像被分为小的像素，每个像素假定有独立的密度值。



**解析度**

和音频采样类似，在扫描图片时，需要决定 **每英寸的方块或者每格方向上的线条需要需要记录多少像素**，这就叫解析度。如果解析度足够高，人眼就看不出每个小像素之间明显的不连续的情况。



**色彩深度**

一个像素使用多少位二进制数来表示，这就是色彩深度。不同的编码技术表示颜色所采用的二进制的位数是不同的。



**真彩色**是指图像中的每个像素值都分成红、绿、蓝三个基色分量，每个基色分量直接决定其基色的强度，这样产生的色彩称为**真彩色**。它是常用的像素编码技术之一。 它采用24位二进制数字来编码一个像素，其中红、绿、蓝分别各占8位，因为8位二进制数能表示0～255中的一个数，所以每种颜色都由三部分组成。

![image-20230131200449433](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131200449433.png)

真彩色模式可以编码2^24 或16 777 216 种颜色。



**索引色**

由于真色彩模式能表示的颜色达到1600多万种。而许多程序用不了这么多种颜色。为此，产生了 **索引色**模式，它只使用了其中的一部分颜色值。该模式中，每个应用程序从大的色彩集中选择一些颜色（通常是256种）并对其建立索引。对选中的颜色赋值一个0～255之间的值。每种颜色由8位二进制数来存储。

![image-20230131201045128](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131201045128.png)

使用索引色模式减少了需要存储一个像素所需要的二进制数的位数。例如，真色彩模式中需要24位二进制数表示一个像素点的颜色；而采用索引色模式只需要8位二进制数就能存储一个像素。

一张300万个像素的照片使用不同模式存储时需要的二进制数的位数：

![image-20230131201429278](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131201429278.png)



**图像编码标准**

- JPEG编码，它使用真色彩模式，但是压缩图像来减少位的数量。
- GIF编码，使用索引色模式。



**缺点**

- 文件体积太大
- 重新调整图像大小会失真

放大光栅图意味着将一个像素扩大（原来该像素点周围的像素变得和该像素的值一样），导致放大后的图片看上去很粗糙。





##### 矢量图

矢量图图像编码方式并不存储每个像素的位模式，而是一个图像被分解为几何图形（线段，圆形或矩形等）的组合。每个几何形状由数学公式来表示。

矢量图是由定义如何绘制这些形状的一系列命令构成的。

当要显示或打印图像时，将图像的尺寸作为输入传给系统。系统重新设计图像的大小并用相同的公式面出图像。在这种情况下，每一次绘制图像，公式也将重新估算一次。因此， 矢量图也称为几何模型或面向对象图形。**改变图像大小不会改变绘图的质量。**



**缺点**

- 只能用于表示相对简单的图形，而不能用于相片这类复杂的图像。





#### 存储视频

视频是图像（帧）在时间上的表示。一个视频就是一系列的图片一张张的播放而形成动态的画面。 换言之，视频是随空间(单个图像)和时间(系列图像)变 化的信息表现。所以，如果知道如何将一幅图像存储在计算机中，也就知道如何储存视频；每一幅图像或帧转化成一系列位模式并储存。这些图像组合起来就可表示视频。需要注意现在视频 通常是被压缩存储的。







## 数据运算

前面讲解的是外部世界的不同类型的数据是如何经过不同的编码方式转为二进制数组合后，然后存到计算机中的。本章讲解，计算机中存储的这些数据是如何用于逻辑与算术运算。

对数据的运算主要分为三大类：**算术运算，逻辑运算和移位运算**



### 逻辑运算

逻辑运算可以对那些使用特定位模式存储在计算机中的**一个二进制数** 或者 **两个二进制数** 进行的一系列的操作。

1bit 二进数的逻辑运算组成一个一位位模式下的逻辑运算，2bit二进制数的逻辑运算组成一个二位位模式下的逻辑运算，以此类推。（即书中的：在**位层次**上和**位模式层次上**定义逻辑运算。模式层次 上的逻辑运算是具有相同类型 的位层次上的n 个逻辑运算，这里的n 就是模式中的位的数目。）



#### 位层次上的逻辑运算

一位可以表示两种状态， 可能是0或 1，可以假设“0”代表逻辑“假”，而“1”代表逻辑“真”。使用 **布尔代数**定义的运算去操作二进制位。布尔代数被广泛应用于计算机中的逻辑电路。

本节介绍4种用来操作二进制位的位层次上的运算：**非（NOT），与（AND），或（OR），异或（XOR）**。

4种运算的符号和真值表。

真值表定义了每一种输入与对应的输出值。输入可能是一位也可能是两位。

![image-20230131212926910](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131212926910.png)



#### 位模式层次上的逻辑运算

相同的4个运算符可以被扩展到n位二进制组成的数上（n位模式）。

![image-20230131213624783](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230131213624783.png)



#### 应用

1. 求反，使用非运算器

2. 复位（置0）一个二进制数的指定位，使用与运算器。用于复位的二进制数称为掩码

   ![image-20230201084742639](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230201084742639.png)

3. 置位（置1）一个二进制数的指定位，使用或运算器，用于置位的二进制数称为掩码

   ![image-20230201084944831](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230201084944831.png)

4. 反转

   ![image-20230201085124036](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230201085124036.png)

![image-20230201085131255](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230201085131255.png)



### 移位运算

用于将一个二进制数进行左移或者右移。将移位运算分为：**逻辑移位运算和算术移位运算**。



#### 逻辑移位运算

逻辑移位运算用于**不带符号位的数**的模式。如果将移位运算应用于带符号的二进制数，则可能改变数的符号。

左右位移：

![image-20230201090541644](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230201090541644.png)

循环移位运算：

![image-20230201090823340](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230201090823340.png)



#### 算术移位运算

算术移位运算假定n位0或1组成的位模式是用**二进制补码格式**表示的**带符号**位的**整数**。

算数右移等价于对整数除以2，而左移等价于对整数乘以2。这些运算不改变符号位（最左侧的位）。

算术右移保留最左侧的符号位，同时复制该符号位的值，放到符号位相邻右边的位中。

算术左移丢弃最左侧的符号位，接收原符号位左边的位作为新的符号位，如果新的符号位的值与原来的符号位的值相同，则运算成功，否则发生上溢或者下溢，结果非法。

![image-20230308224256013](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20230308224256013.png)

### 算术运算

分为整数和浮点数的加、减、乘、除。

#### 整数的加减

二进制补码表示法表示的整数的加法和减法运算。其中将减法统一转为加法进行运算。减去一个数等于加上这个数的二进制补码。

二进制补码表示法的加法是：列与列相加，如果有进位，就加到下一列中，但是，最后一列的进位被舍弃。

**A和B是二进制补码表示法表示的。**

![image-20230308225538681](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20230308225538681.png)



## 计算机组成

- 计算机的三个子系统
- 设计一台简单计算机（能运行程序，完成基本算术和逻辑运算）



### 组成硬件

- CPU
- 主存储器
- 输人/输出系统

![image-20230205120217953](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205120217953.png)



#### CPU

作用：用于数据运算。

在大多数计算机体系结构中，CPU由三个组成部分:

- 算术逻辑单元(ALU)：对数据进行逻辑、移位和算术运算
- 控制单元：控制各个子系统的操作。控制是通过从控制单元到其他子系统的电信号来进行。
- 寄存器组：用来存放临时数据的**高速独立的存储单元**。
  - 数据寄存器：用来存储输人数据和运算中间数据或者运算结果。
  - 指令寄存器：存放从内存中逐条地取出的程序指令，由控制其解释并处理指令。
  - 程序计数器：保存当前正在执行的**指令的内存地址**。当前的指令执行完后，程序计数器将自动加1，指向下一条指令的内存地址。
  - 通用寄存器
- 快速存储定位

![image-20230205120421549](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205120421549.png)



#### 主存储器

它是**存储单元的集合**，每一个存储单元都有唯一的标识，称为地址。数据以称为字的位组的形式在内存中传入和传出。

字可以是8 位、16位、32位，甚至是64位，如果字是8位， 一般称为1字节。

![image-20230205121448431](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205121448431.png)

- 存储地址
  在存储器中每个字对应的存储空间都有自身对应的标识符，但是在高级语言中，开发者使用各种变量名来命名指定的一块存储器中的存储空间，但是在硬件层面，每个字的存储空间都是通过地址来标识的。

  所有在存储器中标识的独立的地址单元的总数称为**地址空间**。例如， 一个64 KB、字长为1字节的内存地址空间的范围为0~ 65535。

  以10的幂的形式来近似表示字节数， 而实际上字节的数目是2的幂。 采用2的幂形式为单位使得寻址更方便 。

  ![image-20230205122045099](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205122045099.png)

  内存地址本身也是使用二进制数来进行寻址的。如果一个内存是64K(2^16)，字长为1字节，那么就需要16位二进制数来确定地址。（而地址使用无符号整数来表示），通过16位二进制数，能命名65536的内存空间（0000000000000000～1111111111111111）。**通常，如果一个计算机有N个字的存储空间，那就需要有1og2N位的无符号整数来确定 一个存储单元。**

  

  示例：

  1. 一台计算机有32 MB (兆字节)内存。需要多少位来寻址内存中的任意一个字节?
     内存地址空间是32MB，即223(2°×270)。这就意味着需要25位来标识每一个字节。
  2. 一台计算机有128MB内存。计算机字长为8字节，需要多少位来寻址内存中任意一个单字?
     内存地址空间是128MB，即2\^27。但是，每个字是8(2\^3)字节，这意味着需要24个字，也就是说要24位来标识每一个字。

  

- 存储器的类型

  - RAM（随机存取存储器）
    计算机内存的主要组成部分，可以使用存储单元地址来随机存取一个数据项，而不需要存取位于它前面的所有数据项。

    - 可读可写，通过覆盖来擦除同一个空间中的原有信息。

    - 易失性，系统断电后数据无法保存

    细分为：SRAM和DRAM。

    **静态RAM(SRAM)**技术是用传统的触发器**门电路**来保存数据。这些门保持状态(0或1)，也就是说当通电的时候数据始终存在，不需要刷新。SRAM速度快，但电路结构复杂，难以集成。
    **动态RAM ( DRAM)** 技术使用**电容器**。如果电容器充电，则这时的状态是1 ;如果放 电则状态是0。因为电容器会随时间而漏掉 一部分电，所以内存单元需要周期性地刷新。 DRAM比 较慢，但电路结构简单，容易集成。

  - ROM

    只读存储器(ROM)，当ROM进入闪存flash时代后，ROM也摆脱了只能读不能写的限制。

    - 非易失性， 当切断电源后，数据也不会丢失。通常用来存储那些关机后也不能丢失的程序或数据

  - PROM

  - EPROM

  - EEPROM

  - Flash

- 存储器的层次结构

  - 当对速度要求很苛刻时可以使用少量高速存储器。CPU 中的寄存器就是这种存储器。
  - 用适量的中速存储器（高速缓冲存储器）来存储经常需要访问的数据。
  - 用大量的低速存储器存储那些不经常访问的数据。

  ![image-20230205130239296](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205130239296.png)


  高速缓冲存储器通常容量较小，且常被置于CPU和主存之间。

  高速缓冲存储器在任何时间都含有主存中 一部分内容的副本。当CPU要存取主存中的一个字的时候，将按以下步骤进行:

    1. CPU首先检查高速缓冲存储器
    2. 如果要存取的字存在，CPU就将它复制;如果不存在，CPU将从主存中复制一份从需要读取的字开始的数据块。该数据块将覆盖高速缓冲存储器中的内容。
    3. CPU存取高速缓冲存储器并复制该字

![image-20230205153509714](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205153509714.png)

这种方式将提高运算的速度;如果字在高速缓冲存储器中，就立即存取它。如果字不在高速缓冲存储器中，字和整个数据块就会被复制到高速缓冲存储器中。因为很有可能CPU 在下次存取中需要存取上次存取的第一个字的后续字，所以高速缓冲存储器可以大大提高处 理的速度。

通常计算机花费80%的时间来读取20% 的数据。换句话说，相同的数 据往往被存取多次。高速缓冲存储器，凭借其高速，可以存储这20% 的数据而使存取 至 少快80%。



#### 输入/ 输出系统

该系统由一系列设备组成。用于计算机和外界的通信。

输人/ 输出设备可以分为两大类:非存储设备和存储设备。



**非存储设备**：使得CPU/ 内存可以与外界通信，但它们不能存储信息。

**存储设备**：存储空间比主内存大且便宜，且是非易失性存储。





### 组成硬件的互连

它们三者之间在内部是如何连接的。



#### CPU和存储器的连接

CPU和存储器之间通常由称为总线的三组线路连接在 一起，它们分別是:数据总线、地址总线和控制总线。

![image-20230205155244103](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205155244103.png)

**数据总线**是由多根线组成，每一根线上每次传送1位的二进制数。线的数量取决于计算机的字的大小。例如，计算机的字是32位(4字节)，那么需要有32根线的数据,总线，以便同一时刻能够同时传送32 位的字。



**地址总线**允许访问存储器中的某个存储空间，地址总线的线数取决于存储空间的大小。如果存储器容量为2^n个字，那么地址总线一次需要传送n 位的地址数据。因此它需要n根线。



**控制总线**负责在CPU和内存之间传送信息。例如，**有一个代码从CPU 发往内存，用于指定进行的是读操作还是写操作。**控制总线的线数取决于计算机所需要的控制命令的,总数。如果计算机有2^m条控制命令，那么控制总线就需要有m根，因为m位可以定义 2^m个不同的操作。





#### I/O设备的连接

输人/ 输出设备不能够直接连接CPU 和内存的总线相连。因为输人/ 输出设备的本质与CPU 和内存的本质不同，**输人/ 输出设备都是些机电、磁性或光学设备**，**而CPU 和内存是电子设备**。

与CPU和内存相比，输人/ 输出设备的操作速度要慢得多。因此必领要有中介来处理这种差异，输入/ 输出设备是通过一种被称为输入/ 输出控制器或接口的器件连接到总线上的。每个输入/输出设备都有一个特定的控制器。



**控制器**

控制器（接口）抹平了输入/输出设备与CPU及内存在本质上的差异。控制器可以是串行或并行的设备。串行控制器则只有一根数据线连接到设备上，而并行控制器则有 数根数据线连接到设备上，使得一次能同时传送多个位。

典型的控制器：SCSI、火线、USB和HDMI。

![image-20230205160634692](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205160634692.png)

#### 输入/ 输出设备的寻址

通常CPU使用相同的总线在主存和输入/输出设备之间读写数据。通过不同的指令区分数据是在CPU和内存还是CPU和输入/输出设备之间进行传输。

有两种方法用来对输入/ 输出设备进行寻址，即I/O独立寻址和I/0存储器映射寻址。



**I/O独立寻址**

在这个方法中，用来读/写内存的指令与用来读/写输人/输出设备的指令是完全不同的。有专门的指令完成对输入/ 输出设备的测试、控制以及读写操作。每个输人/ 输出 设备有自己的地址。因为指令的不同，所以输人/ 输出地址可以和内存地址重叠而不会产 生泥淆。例如，CPU可以使用读命令Read 101来从内存中读取宇101。它也可以使用输人 命令Input 101来从地址端又为101的输人/输出设备中读取数据。这里不会发生混淆，因 为Read 指令是规定从内存中读取数据，而Input 指令则是规定从输人/输出设备中读取数据 (图 5 - 1 7 ) 。

![image-20230205162412149](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205162412149.png)





**I/O存储器映射寻址**

在这个方法中，CPU将输人/输出控制器中的每一个奇存器都看作内存 中的某个存储宇。换言之，CPU 没有不同的指令用来表示是从内存或是从输人/ 输出设备传 送数据。例如，在指令集中只有一条Read 指令，如果地址指定的是内存中的某个单元，则 从内存中读取数据。如果地址指定的是输人/ 输出设备中的某个寄存器，那么就从寄存器中 读取数据。存储器映射的输人/ 输出的配置优点在 于有 一个较小的指令集，所有对内存的操 作指令都同样适合于输人/ 输出设备，其缺点是输人/ 输出控制器占用了一部分内存地址。 例如，假使有5个输人/ 输出控制器，每个控制器有4 个寄存器，则共占用20 个地址。相 应的内存的大小就减小 了20 个字。

![image-20230205162548283](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205162548283.png)

### 程序执行

现代计算机中用一系列指令组成的程序来处理数据，通过执行程序，将输入的数据处理后输出。程序和数据都放到内存中的。



#### 机器周期

一个简化 的周期包括3步 :取指令、译码和执行(图5-19)。

![image-20230205163129043](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205163129043.png)



**取指令**

在取指令阶段，控制单元命令系统将下一条将要执行的指令**复制**到CPU 的指令寄存器中。被复制的指令的地址保存在程序计数器中。复制完成后，程序计数器自动加1指向内存中的下一条指令所在的内存地址。



**译码阶段**

当指令置于指令寄存器后，该指令将由控制单元负责译码。指令译码的结果是产生一系列系统可以执行的二进制信号分别传给CPU的各个部分，统一配合执行某个操作。



**执行**

指令译码完毕后，控制单元发送任务命令到CPU的某个部件，例如，控制单元告知系统 ，让它从内存中加载(读)数据项，或者是CPU让算术逻辑单元将两个输入寄存器中的内容相加并将结果保存在输出寄存器。





#### 输入/输出操作

计算机通过指令把数据从I/0 设备传输到CPU和内存。I/0 设备为低速设备，因此需要CPU的操作**在某种程度上**必须和输入/ 输出设备同步。

有三种方法被设计用于同步，分别为:程序控制输人/ 输出、中断控制输人/ 输出、直接存储器存取 (DMA)。



**程序控制输人/ 输出**

CPU等待I/O设备。

CPU 和I/O 设备之间的数据传输是通过程序中的指令实现的。当CPU遇到 一条I/O 指令时，它就停止工作直到数据传输完毕。



![image-20230205164631530](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205164631530.png)





![image-20230205164707491](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205164707491.png)







![image-20230205164721381](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205164721381.png)





![image-20230205164755551](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205164755551.png)





#### 计算机体系结构



**CISC**

CISC是**复杂指令集计算机**。CISC体系结构的设计策略是使用大量的指令，包括复杂指令。该计算机体系结构的在编程时要更容易一些。因为每一项简单或复杂的任务都有一条对应的指令。程序员不需要写一大堆指令去完成一项复杂的任务。

劣势：指令集的复杂性使得CPU和 控制单元的电路非常复杂。

解决办法：程序在两个层面上运行。CPU不直接执行机器语言指令。CPU只执行被称为微操作的简单操作。复杂指令被转化为一系列简单操作然后由CPU执行。这种执行机制需要一个被称为**微内存**的特殊内存，它负责保存指令集中的每个复杂指令的一系列操作。使用微操作的程序设计被称为微程序设计。（微程序设计和存取微内存需要额外开销）。

 CISC体系结构的一个例子是英特尔公司所开发的奔腾系列处理器。



**RISC**

RISC是精简指令集计算机。 RISC体系结构的设计策略是**使用少量的指令完成最少的简单操作**。**复杂指令用简单指令子集模拟**。

在RISC 中进行程序设计比在其他设计中更难、更费时，因为复杂指令都用简单指令来模拟。



**流水线**

计算机执行每条指令分为：取指令、译码和执行三个阶段。

早期计算机中，每条指令的这三个阶段需要串行完成。 换言之，指令n需要在指令n+1开始它（n+1）的阶段之前完成它（n）的所有阶段。

![image-20230205172615999](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205172615999.png)



现代计算机使用称为**流水线**的技术来**改善吞吐量**(在单位时间内完成的指令总数)。这个理念是如果控制单元能同时执行不同指令的不同阶段，那么下一条指令就可以在前一条指令完成前开始。（允许属于不同指令的不同阶段的同时执行）

![image-20230205172625748](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205172625748.png)

换言之，当计算机在执行第一条指令的译码阶段时，它还能执行第 二条指 令的取指令阶段。第一台计算机在指定时间内平均执行9 个阶段，而流水线计算机在相同的 时间内能执行24 个阶段。如果假定每个阶段使用相同的时间，那第一台计算机完成9/3=3 条指令，而第二台计算机完成了24/3=8条指令。因此吞吐量提高了8/3或266%。



当遇到转移指令时，在管道中的指令应该被丢弃。但是，新的CPU 的设计已经克服了大部分缺点，有些新的CPU设计甚至能同时进行多个取指令周期。



**并行处理**

现代计算机可以拥有具有多个控制单元、多个算术逻辑单元和多个内存单元的计算机。实现并行处理，改善吞吐量。

**并行处理**把计算机的组织(**从数据处理来看**)分成4类，并行处理可能发生在数据流、指令流或两者都有。

![image-20230205173323308](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205173323308.png)

**SISD组织**表示计算机有一个控制单元、一个算术逻辑单元和一个内存单元。指令被顺序执行，每条指令可以存取数据流中的一个或多个数据项。

![image-20230205173625248](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205173625248.png)



**SIMD组织**表示计算机有一个控制单元、多个处理单元和一个内存单元。所有处理器单元从控制单元接收相同的指令，但在不同的数据项上操作。同时操作于一阵列数据的处理器阵列就是属于一类的。

![image-20230205173735068](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205173735068.png)

**MIMD组织**属于多个指令流的多个指令作用于多个数据流 (每条指令作用于一个数据项)。在这种体系结构 中，可以同时执行多个任务。这个体系结构可以使用单个的共享内存或多个内存区。

![image-20230205174054349](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205174054349.png)



### 模拟计算机

目的：解释计算机体系结构，计算机处理指令的过程。

![image-20230205174300200](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205174300200.png)

**数据寄存器组**

该计算机中有16 个16 位的数据寄存器组，它们的十六进制地址为0, 1, 2，...，F（0000～1111），称它们为R0到R15



**控制单元**

控制单元控制ALU的操作、对内存的存取和对I/O子系统的存取。它有两个专用的寄存器:程序计数器和指令奇存器。程序计数器 (PC) (只含有8 位)保存的是下一 条 将被执行的指令的内存地址。PC的内容指向含下一条程序指令的主存的存储单元的地址。在每个**机器周期**后，程序计数器将加1，指向下一条程序指令。指令寄存器(IR)含有16位值，它是当前周期译码的指令。



**内存**

内存有256 个16位的存储单元二进制的地址为(00000000到11111101），十六进制的(00到FD)。



**输入/输出子系统**

键盘和显示器，I/O系统是内存地址方式的一部分。这些设备有内存映射地址，像内存单元一样，它们的地址分别为(FE) 和(FF)。换言之，假定它们就像 16 位的寄存器，作为内存单元与CPU 进行交互。



**指令集**

该模拟计算机具有16 条指令集合，但只使用这些指令中的14 条。每条计算机指令由两部分构成:操作码(opcode)和操作数(operand )。

操作码(opcode)：指明在操作数上执行的操作的类型。

操作数(operand )：指令需要处理的数据或者数据来源地址。

每条指令由16位组成，被分成4个4位的域。最左边的域含有操作码，其他3个域含有操作数或操作数的地址，如图5-31所示。

![image-20230205213442450](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205213442450.png)

注意，并不是每条指令都需要3个操作数。任何不需要的操作数的域被填以0。例如，停机指令的所有3个操作数域、传送指令和NOT 指令的最后一个域都被填充为0。奇存器一共有16个，用4位二进制数就能选中16个寄存器中的一个，所以寄存器的地址是用4个二进制数来表示的，占4位。而内存空间一共有256个，需要用8位二进制数来选择内存地址。

![image-20230205214002601](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205214002601.png)



ADDI：整数的相加指令

ADDF：浮点数的相加指令

LOAD：从指定的源内存地址（内存或者输入设备）加载数据

STORE：从指定的寄存器中输出数据到输出设备或者内存

ROTATE：是将制定寄存器中的数据进行位移操作，第 三个操作数是0，就把R中的二进制数向右循环移位n个位置;如果第三个操作数是1，则向左循环移位

INC：加1

DEC：减1



**处理指令**

计算机使用机器周期， 一个周期有三个阶段:取指令、译码和执行。

在取指令阶段，指令所在的内存地址由PC中存储，从内存中得到，被装入IR 中。然后PC寄存器加1，指向下一条指令所在的内存地址。

在译码阶段，IR 中的指令被控制器译码，所需的操作数从寄存器或内存中取到。

在执行阶段，指令被执行，结果被放人合适的内存单元或寄存器中。

 一旦第三阶段结束，控制单元又开始新的周期，现在PC 是指向下一条指令的。处理过程一直继续，直到CPU遇到HALT指令。





**执行示例**

进行两个整数A和B相加。整数以二进制补码表示。（C =A + B）

假定前两个整数存储在内存地址40和41（16进制），结果回写到内存地址42中。

完成这个加法的指令如下：

![image-20230205215929720](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205215929720.png)

5条指令对应的汇编代码如下：

![image-20230205220019823](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205220019823.png)





**存储程序和数据**

可以从内存单元 00 到04 存储5行程序。数据也需要被存储在内存单元40、41和42中。





## 计算机网络



### 网络

互联网络由一系列可以通信的设备连接构成。

设备：

1. 主机（端系统）
2. 连接设备
   - 路由器：用来连接两个或多个网络
   - 交换机：将同一个网络中的端系统相连
   - 调制解调器：用于改变数据形式



#### 局域网

局域网(LAN) 通常是相对较小的范围内的几个主机相连的私有网络。（范围小）

在一个局域网中的每 一台主机都有在该局域网中唯一定义的一个标识符和一个地址。一台主机向另一台主机发送的数据包中包括源主机和目标主机的地址。

![image-20230205232026496](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205232026496.png)



#### 广域网

广域网( WAN) 也是通信设备互连构成的。（范围大）

局城网将主机互连，广域网则将交换机、路由器或调制解调器之类的连接设备互连。通常，局域网为机构私有，广域网则由通信公司创建并运营，并且租给使用它的机构。

**点对点广域网**

通过传输媒介(电缆或无线)连接两个通信设备的网络。

![image-20230211213140777](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230211213140777.png)

**交换广域网**

是一个有至少有三个端的网络。交换广域网用于当今全球通信的骨干网。

![image-20230205232613044](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205232613044.png)



#### 互联网

当两个或多个网络互相连接时，它们构成 一个互联网络，或者说网际网。

 一个网际网是两个或多个可以互相通信的网络。最大的网际网是因特网，它由成干上万个互连的网络组成。 



![image-20230205233116855](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205233116855.png)

上图将因特网展示为**几个骨干网、供应商网络和客户网络**。

**骨干网**为通信公司所拥有，这些骨干网通过 一些复杂的交换系统相互连接。把这些交换系统称为**网络对等交汇点**(peering point)。

**供应商网络**一些规模较小的网络，它们付费使用骨干网上的一些服务。这些供应商网络与骨干网相连接，有时也连接其他供应商网络。

**客户网络**在因特网的边缘的一些真正使用基于因特网服务的网络，他们向供应商网络付费来得到服务。



骨干网和供应商网络也被称为因特网服务供应商(ISP)，骨干网 通 常 被 称 为 **国 际 因 特 网 服务供应商**，供应商网络则被称为**国内或地域性因特网服务供应商**。

![image-20230205233626764](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230205233626764.png)



#### 硬件和软件

网络通过各种硬件设备互相连接在一起构成的基本结构。连接后，还需要通过硬件上的软件实现网络之间的通信。这些硬件和软件的组合通过协议分层来互相配合。



**协议分层**

**协议**定义了发送器、接收器以及所有中间设备必须遵守的规则，以保证有效地通信。当通信变得复杂时，可能需要将任务分配到不同的协议层中，在这种情况 下，我们在每一个协议层都需要一个协议，或者**协议分层**。

协议分层可以将大任务化简成几个更小、更简单的任务。

协议分层的一个优势就是可以将服务和其实施分开来。每层使用更低层的服务，并向较高 一层提供服务；并且不需要考虑该层是如何实施的。

协议分层的另一个优势就是，简化中间系统层需要支持的协议的种类，因为通信系统往往不仅仅具有两个端系统，还有一些只需要几个协议层而不是所有协议层的中间系统。如果我们不使用协议分层，整个系统会变得更复杂，因为那样得把每一个中间系统都变得和端系统 一样复杂。



**协议分层的原则**

1. 保证每一个协议层都可以进行两个对立且方向相反的工作（如听和说，加密和解密，接收和发送）
2. 在两个站点中每一层的两个对象必须完全相同（即每层的输入和输出都应该一致）

![image-20230207225343345](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207225343345.png)





#### TCP/IP协议族

**传输控制协议/网际协议( TCP/IP)**。互联网中使用的协议集(一组通过不同分层进行组织的协议)被称为TCP/IP 协议族。它是一个分层协议。

每一个高层协议都基 一个或多个低层协议提供服务。

![image-20230207225726074](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207225726074.png)

**分层架构**

TCP/IP 协议族中的分层在两台端系统通信中的作用图（简图）：

![image-20230207225927864](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207225927864.png)





**地址和数据包名称**

![image-20230207230556069](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207230556069.png)

传输层：端口号

网络层：IP地址

链路层：MAC地址，是在本地定义的地址，每一个链路层地址在计算机网络(局域网(LAN)或广域网( WAN))中定义一个特定的主机或者路由器。



### 应用层

应用层向用户提供服务。

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207231256541.png" alt="image-20230207231256541" style="zoom:50%;" />



应用层协议在协议族中的最高层。该层协议不向其他协议提供服务，只接收在传输层的协议提供的服务。这意味着该层的协议可以轻易去除。 只要新的协议可以使用传输层中任意一个协议提供的服务，这个新的协议就可以添加到应用层上。



**应用层模式**

网络通信是两台端系统之间上的应用程序进行的。根据这些程序之间是否都需要请求和提供服务两种功能，还是程序只需要两种的一种功能，发展出了两种模式：

1. 客户机一服务器模式
   在这种模式中，服务提供者是 一个应用程序，叫做服务器进程，这个进程一直持续运转，等待另一个叫做客户端进程的应用程序通过因特网连接要求服务。通常 一些服务器进程可以提供某特定种类的服务，但是向这些服务器进程请求服务的用户会很多，因此很多服务器进程需要一直运行，而客户端进程只在需要时运行。

   虽然在客户机一服务器模式中的通信是在两个应用程序之进行的，但每个应用程序的角 色完全不同，也就是说，不能把客户端程序当成服务器程序运行，反之亦然。

   ![image-20230207232934474](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207232934474.png)

   

   这种模式的一个问题是**通信负荷集中由服务器承担**，这说明服务器必须是一台极为强大的计算机。即使是一台极为强大的计算机也可能因为大量客户在同一时间尝试连接到服务器而过载。再就是成本高昂。

   一些传统服务仍然在使用这种模式 ，包括万维网(www)和它的超文本传输协议 ( HTTP )、文件传输协议(FTP )、安全外壳协议(SSH)、邮件服务等。

2. 端到端模式

   端到端模式(P2P 模式)是一个新的模式，在这种模式中，不需要一个一直运行并等待客户端进程连接的服务器进程。这 个责任是在端与端之间共享的。一台与网络相连接的计算机可以在一个时间段提供服务又在另 一个时间段接收服务。 一台计算机甚至可以在同一时间提供和接收服务。

   ![image-20230207233309152](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230207233309152.png)

典型应用是网络电话和资源共享。通过电话通信确实是一个端到端活动;任何一方都没有必要一直运行来等待另一方的呼叫。



**几种客户机一服务器应用程序**

1. Web（HTTP）

   Web是一个巨型的存储库，它连接分布在世界各地文档（也称为页面）中的信息。

   分布式每 一个Web 服务器都是这个存储库的一个部分。

   链接使一个网页可以参考存储在世界上另外一个地方的服务器中的另一个网页。

   在web应用中，容户可以通过浏览 器来访问使用服务器的服务。但是，提供的服务分布在许多地方，称为站点。每个站点存储的一个或多个文档称为网页。每个网页都包含到相同站点或不同站点的其他网页相连的链接。

   换句话说，一个网页可以很简单也可以很复杂。一个简单的网页不包含到其他网页的链按，一个复杂的网页则拥有一个或多个到其他网页的链接。每个网页都是一个具有名称和地址的文件。

2. 文件传输和电子邮件

3. 远程登录

4. DNS



### 传输层

传输层提供的服务：

1. 进程间通信， 一个应用层进程是使用传输层服务的应用层实体，网络层只负责数据在两个端系统层面的通信，这是一个不完整的传递，这个消息仍然需要被传递给正确的运行在端系统的上的对应进程中才行。

   

   ![image-20230219220911848](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219220911848.png)

   ![image-20230219210533971](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219210533971.png)

   

2. 地址: 端口号
   本地主机和远程主机用I 地址进行定义，为了定义这些进程需要第 二个标识符，称为端口号。在TCP/IP 协议族 中，端口号是0和65535 (16 位)之间的整数。

   客户程序的端口号叫做**临时端口号**，时效性短且是随机的（建议使用大于1023的数）。
   服务器程序也必须定义一个端又号。然而，这个端口号不可以随机选择。TCP/I P 协议族已经决定给服务器使用通用端口号，这些端口号被称为知名端口号。 每一个客户进程知道相应服务器进程的知名端口号。
   ![image-20230219215029841](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219215029841.png)

传输层协议：

典型的传输层协议：UDP（用户数据报协议）和TCP（传输控制协议）

1. UDP

   是不可靠的无连接传输协议。UDP 是一个很简单同时开销最少的协议。如果一个进程想要发**送一条短的消息且不关心可靠性**， 就可以使用UDP。通过UDP 发送一条短的消息比用TCP发送造成的发送者和接收者之间的互动要少得多。UDP 数据包，也叫做用户数据报，有一个固定大小为8字节的头。

   ![image-20230219215447996](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219215447996.png)

   用户数据报是存储在总长度为65535字节的IP数据报中的，所以七整体长度会比较短。

2. TCP
   是一个面向连接的可靠协议。它明确地定义了建立连接、数据传输和连接断开 以提供面向连接的服务。来自应用层的同一消息中的所有数据包(段)之间有连接( 关联)。TCP使用序列号来定义段的顺序。

   序列号与每一段数据的字节数有关。比如在 一个6000字节的消息中，第一段的序列号是0，第二段的序列号是2000，第三段的序列号是4000 (简化)。这样，如果一段丢失了，接收者会持有另外两段**直到**发送者重置丢失的那段（传输层的对头阻塞问题）。

   段：在传输层，TCP 将一些字节组合成一个叫做段的数据包。TCP 在每一段之前加上 一个头(目的是方便控制)，并且将这些段发送至网络层进行传输。这些段都封装在IP数据报里进行传输。

   ![image-20230219220500789](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219220500789.png)



### 网络层

网络层负责源地址到目标地址(计算机到计算机或主机到主机)的消息发送。源主机、目标主机和路径中的所有路由器都涉及网络层。

路由器只用到三层，路径中的路由器通常指少与两个数据链路层和至少两个物理层同时展示，因为它从一个网络接收数据包，然后将该数据包传递至另一网络。

假设Alice和Bob的计算机只有一条路径相连：

<img src="C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219220842327.png" alt="image-20230219220842327" style="zoom:50%;" />

网络层提供的服务：

1. 打包

   打 包 :在源主机的网络层数据包中封装有效负荷(从上 一 层接收的数据)， 并且从来自目的主机网络层的数据包中解封装有效负荷。将有效负荷不加改动或利用地从源送到目的地。

   ![image-20230219221501985](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230219221501985.png)

   1. 源网络层协议从传输层协议接收数据包，添加包含源地址和目标地址以及其他网络层协议所需信息的头。
   2. 网络层协议在逻辑上将该数据包传递至目标处的网络层协议。
   3. 目标主机接收网络层数据包，解除有效负荷的封装并将其传输至上一层协议。

   如果在源主机或在路径中的路由器处时数据包为碎片状，网络层有责任等待直到所有碎片到达，对它们重新组合并发送至上层协议。

   **传输层的有效负荷可以封装在几个网络层数据包中。**

2. 数据包传递
   网络层的数据包传递是无连接且不可靠的。
   不可靠传递：意味着这些数据包可能毀损、丢失或者重复（网络层提供的是尽力而为的传输）。可靠性通过使用传输层协议中的TCP 协议保证。

   无连接传递：网络层对每个数据包的处理是单独的，如果 一个传输层数据包由4个网 络层数据包构成，那么无法保证这4 个数据包到达的顺序与它们发送的顺序相同;这是由于 每个数据包都可能依照不同的路径到达目的地。
   ![image-20230220195715434](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220195715434.png)


   一个传输层数据包分成了4个网络层数据包，它们按顺序发出(1，2，3， 4)，但是收到时它们的顺序是乱的(2，4，3，1)。目的地的传输层负责等待和按收所有数据包再将它们组合在一起并传送至应用层。

   

3. 路由
   物理网络是网络(LAN 和WAN)和连接这些网络的路由器的集合，这意味着 从源到目的地有不止一条路线。网络层的责任是在这些可能的路线中找到最优路线。
   它需要有一些特定的策略来定义最优路线。在现在的网络中，这个是通过在数据包到达时运行一些路由协议来帮助多个路由器协调它们对于周边的路由器的数据并且提出一致的路由表来实现。



网络层协议：
网络层有很多协议，最主要的是网际协议（IP），其他协议都是辅助协议。用来标记每个设备和互联网之间的连接的标识符叫做网络地址或IP地址。

1. IPv4
   该协议的地址空间和数据包格式较小。IPv4地址是一种32位的地址。 这种地址唯一但形式又通用地定义了主机或路由器与网络之间的连接。
   **IP地址是连接的地址而不是主机或者路由器的地址。**这些设备移动到另一个网络之后，它的IP地址就很可能改变。如果一个设备( 例如路由器)有多个网络连接，那 么它就有多个IPv4 地址。

   IPv4的表示法：

   1. 二进制表示法，IPv4地址展示为32 位，为了方便阅读，每8 位之间会添加一个到两个空格
   2. 十进制表示法，用8位二进制数转为对应的十进制数，不同字节利用小数点分开，8位二进制数能表示的十进制数的范围是0～255
   3. 十六进制表示法，用4位二进制转为对应的十六进制数，一个32位的地址由8 个十六进制数宇构成。

   ![image-20230220201429670](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220201429670.png)

   

   IP协议中，地址系统都是分级的（类似省市县镇村）。IPv4只分成两个部分。地址的第一部分叫做**前缀**，定义网络 ; 地址的第二部分叫做后缀，定义节点(设备和网络的连接)。

   前级的长度是n 位，后级的长度就是(32- 1)位。前缀和后缀的长度取决于网络(组织)的站点。
   ![image-20230220201830862](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220201830862.png)

   网络层的数据包称为数据报，IPv4 数据报的格式：
   ![image-20230220201944456](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220201944456.png)

   数据报是一种长度不一的数据包，这种数据包包括两部分:头和有效负荷(数据)。头的长度是20 ~60 字节， 并且他包含路由和传递时必要的信息。注意， 一个字节是8位。

2. IPv6
   是一个在扩大IPv4的地址空间的同时重新设计IP 数据包的格式并修改一些辅助性协议的协议。
   为了防止地址粍尽，IPv6使用128位来定义任何连接到网络的设备。

   IPv6的表示法：

   1. 二进制

   2. 冒号分割的十六进制

      ![image-20230220202844392](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220202844392.png)


      IPv6中的地址定义了三个等级: 站点(组织)、子网和到主机的连接。
      ![image-20230220203010591](./计算机科学导论.assets/image-20230220203010591.png)


​      


      IPv6数据报的格式：
    
      ![image-20230220203456590](./计算机科学导论.assets/image-20230220203456590.png)



### 数据链路层

TCP/IP协议族没有定义数据链路层中的任何协议。

网络通过各种连接设备（路由器，交换机，有线、无线）连接起来构成互联网。网络层提供的是一个数据报是从一台主机传输到另外一台主机的服务，中间需要通过这些连接设备。

数据链路层的通信由多个分开的逻辑连接组成，这些逻辑连接在路径中的数据链路层之间。在源和目标处只包括一个数据链路层，但在每个路由器处都有两个数据链路层。每个路由器都从一个网络中得到输人并将输出发送至另 一个网络。



**节点和链接**

应用层、传输层和网络层的通信是**端到端**的，数据链路层的通信是**节点对节点**的。

网络中的数据包经过多个网络（局域网LAN和广域网WAN）到达目的地。这些LAN 和WAN都是通过**路由器**连在一起的。传统上会将两个端主机和路由器看作节点，它们之间的网络看作链接。

![image-20230220205701000](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220205701000.png)





**局域网**

局域网可以用于共享资源这一单一目的而连接组织内各计算机的孤立网络。现在大多数的LAN也链接到广域网(WAN)或因特网上。

1. 有线LAN:以太网
   它的发展经历了四代:标准以太网(10Mbps) 、快速以太网(100Mbps)、千兆以太网(1Gbps)和万兆以太网(10Gbps)。数据速率，也就是每秒传输的位数，在每 一代都增加 了10 倍。

   数据可以从工作站传输至LAN的速度被定义为数据速率。在以太网中,这些位不是一个接着一个发送的，每组数据都被打包起来并称为**帧**。帧中不仅包括从源地址到目标地址的数据，还带有一些诸如源地址(48位)、目的地地址 ( 4 8 位 )、数据类型、实际数据的信息和一些其他作为守卫水帮助检查传输中数据完整性的控制位。
   在LAN中，数据包都封装在数据帧中：

   ![image-20230220211348296](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220211348296.png)

   万兆以太网被考虑放在城市范围内使用，它扩展以太网的技术、数据速率和覆盖距离，这样以太网就可以用做LAN 和MAN (城域网)。



2. 无线LAN
   在有线LAN中，使用电缆来连接主机。在无线 LAN 中，传输媒介是空气，信号通常是在空气中传播的。在这个领城现在有两种技术:无线以太网和蓝牙。

   **无线以太网**：它是电气和电子工程师协会 (IEEE)为无线LAN 定义的规格，又称为WiFi。这个标准定义了两种服务：基本服务集 ( BSS) 和扩展服务集（ESS)。第 二个服务使用额外设备(接入点)或(AP)作为连接其他LAN或WAN的开关。
   ![image-20230220212251059](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230220212251059.png)


   **蓝牙**：用于连接不同功能的设备，只要这些设备之间的距离比较短。蓝牙 LAN 是一个临时网络， 这也就意味这这个网络是自发的。这些设备互相连接之后可以形成一个叫做蓝牙微网的网络。







**广域网**

1. **有线WAN**









## 操作系统

操作系统是一个计算机软件的集合

- 操作系统的作用，定义
- 操作系统加载到内存的自举过程
- 操作系统的组成部分
- 内存管理，进程管理

计算机系统由两个主要部分组成的:**硬件和软件**。

硬件：计算机的物理设备。

软件：使得硬件能够正常工作的程序的集合。

计算软件分类：操作系统和软件用程序。

操作系统控制计算机系统用户对硬件的访问。

![image-20230221190625021](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221190625021.png)

操作系统的常见定义：

1. 操作系统是介于计算机硬件和用户(程序或人)之间的**接口**。
2. 操作系统是一种用来使得其他程序更加方便有效运行的**程序(或程序集)**。
3. 操作系统作为**通用管理程序**管理着计算机系统中每个部件的活动，并确保计算机系统中的硬件和软件资源能够更加有效地使用。当出现资源使用冲突时，操作系统应能够及时处理，排除冲突。



操作系统的主要目标：

1. 有效地使用硬件。
2. 容易地使用资源。



操作系统为应用层系统提供运行支持，它负责把其他程序装人内存以便运行。但是操作系统本身也是程序，它也需要被装载到内存中才能被CPI运行。

那操作系统又是如何被装载到内存中的？将操作系统存储到ROM（磁盘，固态硬盘）中，CPU的程序计数器可以被设置为这个ROM 的开始处。当计算机被加电时， CPU从ROM 中读取指令，执行它们。从磁盘中取指令的效率很低，且要全部加载到RAM中，占用RAM空间。

解决方法：**自举过程**。操作系统的加载执行分为两个过程，当计算机通电时，加载操作系统中的一小部分称为自举程序的代码到RAM中，CPU 计数器被设置为自举程序的第一条指令，并执行程序中的指令。这个 **自举程序** 唯一的职责就是把操作系统本身 (需要启动计算机的那部分)装 人RAM内存。当装人完成后，CPU 中的程序计数器就被设置为RAM中操作系统的第一条指令，操作系统就被执行 。

![image-20230221192336986](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221192336986.png)





操作系统的演化：

1. 批处理操作系统，控制大型计算机，只保证计算机所有资源被从一个作业转换到另一个作业（串型执行）。
2. 分时操作系统，为了有效使用计算机资源，多道程序的概念被引人。它可以将多个作业同时装人内存， 并且仅当该资源可用时分配给需要它的作业。例如，当一个程序正使用输人/ 输出设备时，CPU 则处于空闲状态，并可以供其他程序使用。
   多道程序带来了分时的概念:资源可以被不同的作业分享。每个作业可以分到一段时间来使用资源。因为计算机运行速度很快，所以分时系统对 于用户是隐藏的，每个用户都感觉 整个系统在为自己服务。
   操作系统可以**调度**:给不同的程序分配资源并决定哪一个程序什么时候使用哪一种资源。
   这个阶段产生了一个术语：**进程**。 一个作业是一个要运行的程序， 个进程则是在内存中等待分配资源的程序。

3. 单用户操作系统，用于个人计算机。
4. 并行操作系统，在同一计算机中安装了多个CPU, 每个CPU可以处理一个程序或者一个程序的一部分。（很多任务可以并行地处理而不 再是串行处理）
5. 分布式操作系统，一个以往必须在一台计算机上运行的作业现在可以由远隔千里的多台计算机共同完成，通过网络交换数据。
6. 实时操作系统，指在特定时间限制内完成任务。它们被用在实时应用程序中。



### 操作系统的组成

现代操作系统至少具有以下4种功能:**存储管理、进程管理、设备管理、文件管理**，外加 **用户界面或命令解释程序**，它负责操作系统与外界通信。

![image-20230221201010391](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221201010391.png)



**用户界面**

指用来接收用户(进程)的输人并向操作系统解释这些请求的**程序** 。



### **内存管理器**

计算机需要为处理的程序和数据分配内存，进行管理以避免“ 内存滥出” 的错误。

操作系统按照内存管理可以分为两大类:单道程序和多道程序。

**单道程序**

在单道程序中，大多数内存用来装载单一的程序。仅仅 一小部分用来装载操作系统。在这种配置下，整个程序装入操作系统内存运行，运行结束后，程序区域由其他程序取代。

这时内存管理器的工作是：将程序载入内存、运行它、程序再装入新程序。

不足：

1. 程序必须完整的能够载人内存。如果内存容量比程序小，程序将无法运行。
2. 当 一个程序正在运行时，其他程序不能运行。 一个程序在执行过程 中经常需要从输人设备得到数据，并且把数据发送至输出设备。但输人/ 输出设备的 速度远远小于CPU，所以当输人/ 输出设备运行时，CPU 处于空闲状态 。而此时 由于其他程序不在内存中，CPU 不能其服务。这种情况下CPU和内存的使用效率 很低。

![image-20230221203120935](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221203120935.png)



**多道程序**

在多道程序下，同一时刻可以装入多个程序并且能够同时被执行。CPU轮流执行他们。

![image-20230221203158808](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221203158808.png)

![image-20230221203257450](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221203257450.png)



非交换：意味着程序在运行期间始终驻留在内存中。

交换：在运行过程中，程序可以在内存和硬盘之间多次交换数据。



**分区调度**：

在这种模式中 ，内存被分为不定长的几个分区。每个部分或分区保存一个程序。CPU 在各个程序之间交替执行指令。它由一个程序开始，执行一些指令， 直到有输人/ 输出操作或者分配给程序的时限到达为止。CPU 保存最近 使用的指令所分配的内存地址后转人下一个程序。对下一个程序采用同样的步骤反复执行下 去。当所有程序服务完毕后，再转回第 一个程序。当然，CPU可以进行优先级管理，用于控制分配给每个程序的CPU时间。

![image-20230221203725384](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221203725384.png)



不足：

1. 每个程序完全载人内存，并占用连续的地址。
2. 分区的大小必领由内存管理器预先决定。如果分区小了，有的程序就不能载人内存。 如果分区大了，就会出现空闲区。
3. 即使分区在刚开始时比较合适，但随着新程序的交换载人内存后有可能出现内存碎片。
4. 当空闲区过多时，内存管理器能够紧缩分区并删除空闲区和创建新区，但这将增加 系统额外开销。



**分页调度**：

在分页调度下，内存被分成大小相等的若干个部分， 称为**帧**。程序则被分为大小相等的部分，称为**页**。页和帧的大小通常是 一样的，并且与系统用从存储设备中提取信息的块大小相等。

程序的页被夹在到内存的帧中，同时必须整个程序的所有页都加载到内存的帧中，但是不需要是连续的帧。程序中连续的页可以占用内存中不连续的帧。

不足：

分页调度在一定程度上提高了效率，但整个程序仍需要在运行前全部载人内存。这意味着在只有4 个不连续帧时，一个需要6个空闲帧的程序是不能载入的。





**请求分页调度**

分页调度不需要程序装载在连续的内存中，但仍需要程序整体载入内存中运行。请求分页调度不需要程序整个加载到内存中运行。

在请求分页调度中，程序被分成页，但是页可以依次载入内存、运行， 然后被另一个页代替。

![image-20230221215009140](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221215009140.png)



**请求分段调度**

在分页调度中 ，不像程序员以模块来考虑程序，程 序实际是分为大小相等的页。程序通常由主程序和子程序组成， 在请求分段调度中，程序将按程序员的角度划分成段，它们载入内存中、执行，然后被来自同一程序或其他程序的模块所代替。因为在内存中的段是等长的，所以段的一部分可能是空的。

![image-20230221215545036](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221215545036.png)







### 进程管理器



**程序、作业和进程**

程序：是由程序员编写的 一组稳定的指令，存在磁盘(或磁带)上，它可能会也可能不会成为**作业**。



作业：从一个程序被选中执行，到其运行结束并再次成为一个程序的这段过程中，该程序称为作业。

属于作业的情况：

1. 一个驻留在磁盘上的程序在被操作系统选中，等待调人内存时
2. 在内存中等待CPU执行时
3. 驻留在内存中等待 一个输人/输出事件时
4. 在内存中被CPU运行

每个作业都是程序，但并不是所有的程序都是作业。



进程：是一个运行中的程序。该程序正在运行中。进程是一个驻留在内存中正在被CPU执行的作业。它是从众多等待作业中选取出;来并装人内存中的作业。 一个进程可以处 于运行状态或者等待CPU 调用。只要作业装人内存就成为 一个进程。需要注意的是，每个 进程都是作业，而作业未必是进程。



![image-20230221221439668](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230221221439668.png)

1. 一个程序当被操作系统选中时就成为作业并且成为保持状态。
2. 直至它载人内存之前都保持这个状态。
3. 当内存可以整体或者部分地载人这个程序时，作业转成就绪状态， 并变成进程。
4. 它在内存中保持这个状态直至CPU运行它;这时它转成运行状态 。
5. 当处于运行状态后，可能出现 下面三种情况：
   - 进程运行直至它需要I/O资源  ，进程进人等待状态直至输人/ 输出结束。
   - 进程可能耗尽所分配的时间片， 直接进人就绪状态
   - 进程终止， 进人 终止状态并且不再是进程。



## 算法

算法是一组明确步聚的有序集合，它产生结果并在有限的时问内終止。

它可以独立于计算机系统 。算法接收一组输入数据，同时产生 一组输出数据。

### 最大值算法

从一组数中找出最大的一个数字。

```js
function findMaxNum(...args){
  let largest = args.shift()
  while(args.length){
		largest<args[0]?largest = args.shift():args.shift()
  }
	return largest
}
```



### 排序算法

#### 选择排序

在这种排序中，一组数字组成的列表被假设分为两个子列表，已排序的和未排序的。他们中间的边界位置不断改变。**找出未排序子列表中最小的元素并把它和未排序子列表中第一个元素进行交换， 经过每次选择和交换，两个子列表中的边界中间位置向前移动一个元素，这样每次排序列表中将增加一个元素而未排序列表中将减少一个元素，每次把一个元素从末排序列表移到已排序列表就完成了一轮排序。**

 一个含有n个元素的数宇列表需要n- 1轮排序来完成数据的重新排列。即在未排序的子列表中已经找到最小的数字之后，还需要n-1轮排序才能完成数据的重新排列。

![image-20230222210033265](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230222210033265.png)

选择排序列表关键：使用双重循环。外层循环每循环一次实现一次未排序子列表中最小的元素和未排序子列表中第一个元素的交换，内存循环则是在未循环的列表中求出最小的元素。

选择排序的UML图：

![image-20230222210520994](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230222210520994.png)



```js
function selectionSort(...args){
  	const len = args.length
    for(let turns=0; turns<len; turns++){
      let smallest = [args[turns],turns]
      for(let index = turns+1;index<len; index++){
       	 if(smallest[0]>args[index]){
           smallest = [args[index],index]
         }
      }
      let temValue =  args[turns]
      args[turns] = args[smallest[1]]
      args[smallest[1]] = temValue
    }
  return args
}
```



#### 冒泡排序

在冒泡排序中，数字列表被分为两个子列表:已排序的和未排序的。在未排序子列表中，**最小的元素**通过冒泡的方法选出来并移到已排序子列表中。当把最小的元素移到已排序列表后，墙向前移动一个元素，使得已排序元素的个数增加1个，而未排序元素的个数减少1个。每次元素从未排序子列表中移到已排序子列表中，便完成一轮。

一个含有n 个元素的列表，冒泡排序需要n-1轮来完成数据排序。

![image-20230222215720852](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230222215720852.png)

冒泡排序的关键：使用双重循环。外层循环每轮迭代一次;内层循环的每次迭代则将某一元素冒泡至顶部(左部)。冒泡排序有两种方向：将较大的数字冒泡排到右侧，或者将小的数值冒泡排到左侧。

```js
function bubbleSort(...args){
	const len = args.length;
  for(let turns=1; turns<len; turns++){
    for(let index=0; index<len-turns; index++){ 
      if(args[index]>args[index+1]){
        let temValue = args[index]
        args[index] = args[index+1]
        args[index+1] = temValue
      }
    }
  }
  return args
}
```



#### 插入排序

在这种排序中，排序列表也被分为两组，已排序和未排序的。

```js
function insertionSort(arr) {
  var len = arr.length;
  var preIndex, current;
  for (var i = 1; i < len; i++) {
    preIndex = i - 1;
    current = arr[i];   // 这一步等价于将未排序的列表中的第一项提出来
    while(preIndex >= 0 && arr[preIndex] > current) {  // 如果current的值小于已排序列表中的最后一项时，且未超出已排序列表的第一项时
      arr[index] = arr[preIndex];
      preIndex--;
    }
    arr[preIndex+1] = current;
  }
  return arr;
}
```



上面的这三种算法是快速排序、堆排序、Shell排序、桶式排序、合并排序、基排序的基础且这三种排序算法是效率最低的排序算法。

有些排序算法对部分排序的数据很有效，另一些对完全未排序的数据很有效。

一个算法的好坏通过 **算法复杂度** 来衡量。



### 查找

是一系列在列表中确定目标所在位置的算法。对于**列表**有两种基本的查找方法:**顺序查找和折半查找**。

顺序查找可以在任何列表中查找。折半查找则要求列表是有序的。





### 递归

递归是算法自我调用的过程。

递归解决问题的特点：**首先将问题从高至低进行分解，然后从低到高解快它。**



编写算法常常用到： **迭代和递归**。

如果算法的定义不涉及算法本身的调用，则该算法是迭代定义的算法。

![image-20230223201410129](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230223201410129.png)



迭代通常包含一个循环。

```js
function factorialIteration(n=1){
  let iteration = 1
  while(n){
    iteration = iteration * n
    n = n - 1
  }
  return iteration
}
```



如果一个算法出现在它本身的定义中，该算法就是递归定义的算法。

![image-20230223201422913](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230223201422913.png)

```js
function factorialRecursion(n){
  if(n===0) {
    return 1
  }
  return n * factorialRecursion(n-1)
}
```





## 程序设计语言

比较不同的编程语言。

### 机器语言

每种CPU架构都有其自己能识别的机器语言，这些机器语言由0或1组成。

机器语言是计算机硬件唯 一能理解的语言，它由具有两种状态的电子开关构成:关(表示0)和开(表示1)。

用机器语言编写的程序真实地表示了数据是如何被计算机操纵的。但是它存在的不足：

1. 不同的CPU架构的机器语言各不相同
2. 用机器语言编写程序枯燥繁琐，且很难调试



![image-20230223204041941](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230223204041941.png)



### 汇编语言

用带符号或助记符的指令和地址代替二进制码。

![image-20230223204103944](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230223204103944.png)

汇编语言和不同架构的CPU的机器语言是一一对应的。不具有可移植性。每条机器指令都有其对应的汇编代码。



### 高级语言

高级语言同汇编语言有一个共性:它们必须被转化为机器语言，这个转化过程称为**解释或编译**。

高级语言程序被称为源程序。

被翻译成的机器语言程序称为目标程序。



**编译**：编译程序通常把整个源程序翻译成目标程序。

**解释**：使用解释器把源程序翻译成目标程序。解释是指把源程序中的每一行翻译成目标程序中相应的行，并执行它的过程。

JAVA之前的解释执行：

纯解释型语言，在这种解释中，源 程序的每一行被翻译成被其使用的计算机 上的机器语言，该行机器语言被立即执行。如果在 翻译和执行中有任何错误，过程就显示消息，其余的过程就被中止。程序需要被改正，再次从头解释和执行。 这个过程缓慢。



JAVA的解释执行：

JAVA的采用了编译加解释的方式。

Java 语言能向任何计算机移植。为了可移植性，源程序到目标程序的翻译分成两步进行:编译和解释。Java 源程序首先被编译，创建Java的字节代码，字节代码看起来像机器语言中的代码，但不是任何特定计算机的目标代码，它是一种虚拟机的目标代码，该虚拟机称为Java 虚拟机或JVM。

字节代码然后能被任何运行JVM 模拟器的计算机编译或解释，也就是运行字节代码的计算机只需要 JVM模拟器，而不是Java 编译器。



高级编程语言的代码执行过程：

编译在执行前翻译整个源代码，而解释一次只翻译和执行源代码中的 一行。但是，两种方法都遵循相同的翻译过程：

![image-20230223222138208](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230223222138208.png)



### 编程模式

高级编程语言根据它们解决问题的方法进行分类。因此，**模式**是关于计算机语言如何看待要解决问题。

编程语言的4种模式：过程性 (强制性）、面向对象、函数式和声明式



#### 过程式模式

在该模式中，把程序看成是操纵被动对象的主动主体。就像一个工具不能主动发出动作一样，它们需要从一个动作主体那里接受动作。

过程式模式下的程序就是主动主体，该主体使用称为数据或数据项的被动对象。

数据或数据项存放在内存中，程序发出动作（调用方法）被称之为过程，等价于一个接受参数的函数（过程），其中的参数就是被动对象。

程序调用不同的预定义过程，作用于固定的目标对象后，以完成一些列的任务。

![image-20230224183320658](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230224183320658.png)



在这种模式下，程序不定义过程，它只触发或调用过程。过程在调用之前必须已经存在。

在过程式编程语言中，程序仅由许多过程调用构成。即使使用像加法运算符 (+)这样的运算符时，也是正在使用一个过程，调用一个已经编写的过程。换言之，表达式A+B 是add (A，B)的缩写。 语言的设计者编写了这些过程，才能调用它。

面向过程编程的三个构成部分：

1. 对象创建部分
2. 一组过程调用
3. 定义一个个过程的一组代码

其中有些过程在语言本身中已经被定义好的。

![image-20230224184343556](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230224184343556.png)





#### 面向对象模式

该模式处理活动对象（就是该对象已经具备一些功能），而不是被动对象。在这些对象上执行的动作都包含在这些对象中:对象只需要接收合适的外部刺激来执行其中一个动作。

对比面向过程模式，对象身上包含了被一些用户处理对象自身的过程。在这种模式的程序中，程序仅仅是去通知对象执行相应的方法。

![image-20230224202024740](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230224202024740.png)



只要是相同类型的对象就能共享这些方法。同时也被继承了该类对象的其他对象所共享。

过程式模式中的方法（函数）是独立的实体，但面向对象模式中的方法是属于对象的特性。在面向对象编程语言中，使用 **类** 来创建对象和对象上的方法。

![image-20230224202457061](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230224202457061.png)

一般，面向对象编程中的方法和面向过程编程中的函数很相似，每个方法有它的头、局部变量和语句。

在面向对象编程语言中的特性：

1. 继承性

   一个对象能从另 一个对象继承方法。当一般类被定义后，可以定义继承了一般类中一些特性的更具体的类，同时这些类具有一些一般类不具有的新特性。

2. 多态性

   在面向对象编程语言中，多态性是指可以定义一些具有相 同名字的操作，而这些操作在相关类中做不同的事情。





#### 函数式模式

在该模式中，程序被看成是一个数学函数。关于这点，函数是把一组输人映射到一组输出的黑盒子。该模式还是和过程式编程有些相似的。

函数式语言相对过程式语言具有两方面优势:它支持模块化编程并且允许程序员使用已经存在的两数来开发新的两数。



### 编程语言的共同特点

1. **标识符**，所有高级语言都有标识符，用来为内存空间地址起别名，计算机中每一个数据都存储在一个唯一的物理地址中。如果没有标识符来符号化代表数据的位置，就需要去了解并直接使用数据的地址来操纵它们。

2. **数据类型**，数据类型定义了一系列值及这些值能进行的一系列操作。  每种数据类型值的集合称为数据类型的域。大多数语言都定义了两类数据类型:**简单数据类型和复合数据类型**。

   - 简单数据类型（原子类型、基本类型、标量类型或内建类型），是不能分解成更小数据类型的数据类型。如：
     - 整数类型
     - 实数类型
     - 字符类型
     - 布尔类型
   - 复合数据类型是一组元素，其中每个元素都是简单数据类型或复合数据类型
     - 数组
     - 对象

3. **变量**是物理存储单元的别名，每个内存单元在计算机中都有 一个地址，虽然计算机内部使用地址，但对程序员而言却十分不方便，首先，程序员不知道内存中数据项的相对地址。其次，数据项在内存中可能占据多个地址。
   因为变量是用来存储一个具体属于某个数据类型的真实数据的，数据有数据类型一说，所以变量也有类型一说，用来说明该变量是用来存放哪一类或者几类中的。

   绝大多数语言要求使用变量前必须进行变量声明，用于告知计算机指定名称的变量将在程序中被使用，同时计算机需要预留出存储区域，并给它起变量名作为别名。

4. **字面量**是程序中使用的预定义的值。比如数学中的pi，圆周率，布尔字面量值等，

5. **常量**(像变量一样)是一个可以存储值的命名的位置，但值在程序开始处被定义后就不能改变。

6. **输入和输出**

7. **表达式**

8. **运算符**



#### 语句

每条语句都使程序执行一个相应动作。它被直接翻译成**一条或多条**计算机可执行指令。

1. 赋值语句

2. 复合语句，包含0到多个语句的代码单元或者代码块（包括在一个左大括号、一个可选语句段以及一个右大括号中）

3. 条件控制语句，在计算机机器语言中，为这种背离顺序执行所提供的指令称为jump 指令，早期的强制性语言使用g0 to 语句来模拟jump 指令

   ![image-20230224221421093](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230224221421093.png)

4. 循环语句
   ![image-20230224221440895](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230224221440895.png)











## 软件工程

![image-20230225094033566](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230225094033566.png)





软件开发过程有4个阶段：分析、设计、实现和测试。

开发阶段的常见模型：瀑布模型和增量模型。

瀑布模型中，开发过程只有一个方向的流动。这意味着前一个阶段不结束，后一个阶段不能开始。

![image-20230225094232869](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230225094232869.png)



优点：在下一个阶段开始前每个阶段已经完成，后一个阶段能准确知道前一个阶段的结果。

缺点：难以定位问题:如果过程的 一部分有问题，必须检查整个过程。





增量模型中，软件的开发要经历 一系列步骤。开发者首先完成整个系统的 一个简化版本，这个版本表示了整个系统，但不包括具体的细节。

![image-20230225094456968](/Users/wuyi/Desktop/study-note/计算机基础/计算机科学导论.assets/image-20230225094456968.png)







### 分析阶段

这个阶段生成规格说明文档，这个文档说明了软件要做什 么，而没有说明如何去做。

分析阶段使用有两种独立的方法，具体使用哪一种方法，依赖于编写程序时编程语言所选择的编程模式是面向过程编程模式还是面向对象编程模式。



**面向过程分析**

如果实现阶段使用过程式语言，那么面向过程分析 (也称为结构化分析或经典分析)就是分析阶段使用的方法。这种情况下的规格说明可以使用多种建模工具。

- **数据流图**
  数据流图显示 了系统中数据的流动。它们使用4 种符号: 方形盒表示数据源或数据目的，带圆角的矩形表示过程(数据上的动作)。末端开又的短形表示数据存储的地方，箭头表示数据流。
  例如：旅馆预订系统
  ![image-20230225095243738](/计算机基础/计算机科学导论.assets/image-20230225095243738.png)

- **实体关系图**，这是另一个建模工具。因为这个图也用于**数据库的设计**

- **状态图**，它通常用于当系统中的实体状态在响应事件时将会改变的情况下。电梯例子：

  ![image-20230225095958249](/计算机基础/计算机科学导论.assets/image-20230225095958249.png)





**面向对象分析**

如果实现使用面向对象语言，那么面向对象分析就是分析过程使用的。这个过程是用的规格文档工具：

- **用例图**，它给出了系统的用户视图:它显示了用户与系统问的交互。用例图使用4种组件: 系统、用例、动作者和关系。系统(用矩形表示)执行功能。系统中的行动由用例显示，它用圆角的短形表示。动作者是使用系统的某人或某事。虽然动作者用线条人物来表示，但它 们并不需要表示人类。


![image-20230225100638974](/计算机基础/计算机科学导论.assets/image-20230225100638974.png)

- **类图**，分 析 的 下 一步就是创建系统的类图。为了做这些，需要考虑系统涉及的实体。在电梯系统 中，有两个实体类:按钮和电梯本身。但是，有两种不同类型的按钮:在走廊里的电梯按钮和在电梯里的楼层按钮，那么就需要一个按钮抽象类，和两个继承该抽象类的具体类按钮。

  电梯按钮类和楼层按钮类是按钮类的子类。但是，电梯类与两个按钮类(电梯按钮和楼层按钮)间的关系是一对多关系。

  ![image-20230225101415185](/计算机基础/计算机科学导论.assets/image-20230225101415185.png)

- **状态图**，类图完成之后，就可以为类图中的每个类准备状态国。面向对象分析中的状态图与面向 过程分析中的状态图起相同作用。



### 设计阶段

设计阶段定义系统如何完成在分析阶段所定义的需求。在设计阶段，系统所有的组成部 分都被定义。



**面向过程设计**

该过程中，既要设计过程，也要设计数据。







## 数据结构

变量用于存储单个实体（也就是存储具体的数据），但是面对复杂问题时，单变量很难有效地组织数据和处理数据。

数据结构像是一种抽象的数据类型。可以将数据结构看作相似变量的集合，这些集合能够单独或作为一个整体被访问。换句话说， 一个数据结构代表了有特殊关系的数据的集合。



### 数组

数组是元素的**顺序**集合，通常这些元素具有相同的数据类型。 数组是一种随机存取结构，这意味着数组的每个元素可以随机地被存取，而不需要存取该元素前面的元素或后面的元素。

数组中的每一项称为元素。索引表示元素在数组中的顺序号，顺序号从数组开始处计数（从0开始）。数组中的每一个索引位置都表示一个独立的内存地址。

数组的操作：

1. 查找
2. 插入（尾部，头部和中间插入），其中头部和中间插入的效率很低
3. 删除（尾部，头部和中间删除），其中头部和中间删除的效率很低
4. 检索
5. 遍历

如果有一个表，在表创建后有大量的插人和删除操作要进行，这时就不应该使用数组。当删除和插人操作较少，而有大量的查找和检素操作时，这时比较适合使用数组。







### 链表

链表是一组数据的集合，其中每个元素包含下 一个元素的地址; 即每个元素包含两部分: **数据和链**。

数据部分包含可用的信息，并被处理。链则将数据连在一起，它包含一个指明列 表中下一个元素的指针(地址)。另外， 一个指针变量标识该列表中的第一个元素。列表的名字就是该指针变量的名字。

![image-20230225122809978](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230225122809978.png)

链表上的每一个元素被称为 **节点**。



数组的元素在内存中是 一个接 一个中间无间隔存储的，即列表是连续的。而链表中的节 点的存储中间是有间隔的:节点的链部分把数据项“连” 在一起。

换言之，计算机可以选择 连续存储它们或把节点分布在整个内存中。这样有一个优点:在链表中进行的插人和删除操 作更容易些，只需改变指向下一元素地址的指针。



链表操作：

1. 查找链表，链表的查找算法只能是顺序的，因为链表中的节点没有特定的名字。
2. 插入节点，插入节点一般需要借助两个变量：pre (先前的)和cur (当前的)
   ![image-20230225124735029](C:\Users\dukkha\Desktop\study-notes\书籍阅读\images\image-20230225124735029.png)
3. 删除节点
   ![image-20230225124852224](/计算机基础/计算机科学导论.assets/image-20230225124852224.png)

当需要对存储数据进行许多插人和删除时，链表是一种非常高效的数据结构。链表是一 种动态的数据结构，其中表从没有节点开始，然后当需要新节点时，它就逐渐增长。与数组 的情况相比，节点很容易被删除，不需要移动其他节点。

链表可以无限增长，也可以缩短为空表。额外的开销是为每个节点含有 一个额外的域。 但是对于需要经常查找的数据来说，应该避免使用链表。









