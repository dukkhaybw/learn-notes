# 数据结构与算法

## 算法的衡量

衡量一个算法好坏时，要考虑算法执行在什么样的设备和软件环境下。

作者读了大量数据结构与算法数据，同时边读边练，然后在开发时，就不由自主的采用数据结构与算法中的思想编写了时间复杂度和空间复杂度低的优秀代码。



- 怕数据结构难学
- 工作中自发避让数据结构与算法
- 换工作被卡在数据结构和算法，读不懂开源项目的源码
- 和大牛比起来，学习和接受“新”知识的节奏慢





## 数据结构

数据结构：在计算机中存储和组织数据的方式。

程序设计 = 数据结构 + 算法

数据结构即关系的集合，它是数据元素相互之间存在的一种或者多种特定的关系的集合。

数据结构：

- 逻辑结构：数据元素之间的相互关系
- 物理结构：数据的逻辑结构在计算机中的存储形式

## 逻辑结构

​		四大逻辑结构：

- 集合结构
  集合结构中的数据元素除了同属于一个集合外，它们之间再无其他关联

  

- 线性结构

  线性结构中的数据元素之间是一对一的关系
  
- 树形结构
  树形结构中的数据元素之间是存在一种一对多关系和层次关系

  

- 图形结构

  图形结构中的数据元素之间是多对多的关系

  

## 物理结构

研究的就是如何把数据元素存储在计算机的存储器中。存储器主要指的是内存。像硬盘，U盘等则是用文件结构来组织数据的。

数据元素的存储结构形式有两种：

- 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
  例如编程语言中的数组等。对于时常要变化的结构，顺序存储结构并不科学高效。
- 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以不连续，链式存储结构中数据元素存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样就可以通过地址找到相关联的数据元素的位置。数据元素在内存中的存放顺序是随意的，但是每个元素都多用一点空间，用于存放除了自身数据之外的指针，指针指向的就是下一个数据元素的地址。





## 算法

### 算法小案例

计算1到100的总和

```
方式一：
let sum =  0 
for(let i=1;i<=100;i++){
	sum = sum + i
}
console.log( sum )
 上面代码循环需要执行100次


方式二：
let n = 100 ,sum = 0
sum = (n+1)*n/2
console.log( sum )
这里只需要执行一次
```

算法：解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。

### 算法的五个特征：

- 输入：有零个或多个输入
- 输出：有至少一个或多个输出
- 有穷性：算法在执行有限的步骤后会自动结束而不是无线循环，并且每个步骤花费的时间都是在可接受的范围内的
- 确定性：算法的每个步骤都有明确的含义，在一定条件下只能有一条执行路径，相同的输入只能得到相同输出
- 可行性：算法的每一步都是必须可执行的，每一步都能通过有限次数来完成



### 算法设计的要求

- 正确性：算法至少要具有输入，输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案
  - 算法程序不能有语法错误
  - 算法程序对合法输入能产生满足要求的输出
  - 对于非法输入能产出满足要求的说明
  - 对于故意刁难的测试输入都有满足要求的输出结果
- 可读性
  - 算法程序要便于阅读，理解和交流
- 健壮性
  - 当输入不合法时，算法也能做出相关的处理，而不是产生异常，崩溃或者莫敏的结果
- 时间效率高，存储量低



## 算法效率的度量

主要指的是执行时间

- 事后统计方法：通过针对某个算法设计好的测试层序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较
- 事前分析估算方法：在计算机程序编写前，依据统计方法对算法进行估算

一个高级语言编写的算法执行所需要的时间决定因素有：

- 算法采用的策略和方案
- 编译产生的代码的质量
- 问题的输入规模
- 机器执行指令的速度

排除掉那些硬件和软件（编译器）的因素，一个算法程序的运行效率往往就取决于算法本身好坏和问题的输入规模。

在研究算法的**复杂度**时，侧重研究算法随着输入规模的扩大，增长量的一个抽象，而不是精确定位需要执行多少次。不考虑循环索引的递增执行次数，循环终止条件的判断次数，变量声明和打印结果等操作的次数。

在分析一个算法的运行时长时，重要的是把基本操作的次数和输入模式关联起来。	

例如：

```
2n+2 和 2 的差距在算法估算中就看作 n 和 1 之间的差距

2n+3 和 3n+1 的差距在算法估算中就看作 2n 和 3n 之间的差距，其中的加常数可以直接忽略。

4n+8 和 2n^2+1 的差距在算法估算中就看作 n 和 n^2 之间的差距，其中的加常数可以直接忽略和与n相乘的常数项。

2n^2+3n+1 和 2n^3+3n+1 的差距在算法估算中就看作 n^2 和 n^3 之间的差距，其中的加常数可以直接忽略和与n相乘的常数项。

```

在判断算法效率时，主要关注的就是阶数最高的一项，也不用过多关注与最高阶数项相乘的常数项。

### 算法的时间和空间复杂度

#### 算法的时间复杂度——代码运行耗时

##### 大O记法

需要自己有一些数学基础。

算法时间复杂度的定义：在计算算法分析时，语句总的执行次数T（n）是关于问题规模( n )的函数，进而分析T（n）随着n的变化情况并确定T（n）的数量级。 算法的时间复杂度，也就是算法的时间度量，记作：T(n) =O( f(n) )。它表示随着问题规模（n）的增大,算法执行时间的**增长率**和f(n)的**增长率**相同，称为算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

一般情况下，随着输入规模n的增大，T( n )增长最慢的算法是最优算法。

分析一个算法的时间复杂度：

- 用常数1取代运行时间中的所有加法常熟（就是判断在数据比较大的情况下，函数的哪些部分可以忽略不记）
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高项存在且不为次数不为1，则去除与这个项相乘的常数
- 结果就是算法的大O记法的时间复杂度



时间复杂度的几种常见类别：

1. 常数阶

```
let i = 0,
	sum = 0
consloe.log(123)
consloe.log(123)
consloe.log(123)
consloe.log(123)
consloe.log(123)
sum = (sum+1)/(sum/2)
上面这段代码的时间复杂度就是:O(1),而不是O(8)

```

2. 线性阶

一般含有非嵌套循环涉及线性阶， 线性阶就是随着问题规模n的增大，对应的计算次数呈现直线增长。

```
int i, n=100,sum = 0
for(i=0; i<n;i++){
	sum = sum +1
}
上面这段代码的时间复杂度就是:O(n)
```



3. 平方阶

一般含有嵌套循环涉及高阶，高阶就是随着问题规模n的增大，对应的计算次数呈现指数级增长。

```
int i,j, n=100,sum = 0
for(i=0; i<n;i++){
	for(j=0;j<n;j++){
		printf('123')
	}
}
上面这段代码的时间复杂度就是:O(n^2)
```

```
int i,j, n=100,sum = 0
for(i=0; i<n;i++){
	for(j=i;j<n;j++){
		printf('123')
	}
}

上面这段代码的时间复杂度就是:O(n^2)
```

4. 对数阶

```
int i =1 n= 100;
while(i < n){
	i=i*2
}
2^x = n => x=log(2)n
上面这段代码的时间复杂度就是:O(logn)
```



##### 函数调用的时间复杂度分析

```
int i, j;
for(i=0;i<n;i++){  //外层循环的时间复杂度是：O(n)
	function(i)
}

void function (int count){  //函数体的时间复杂度是：O(1)
	printf('%d', count)
}

上面这段代码的时间复杂度是:O(n)，线性执行的情况下，整体代码取决于耗时最长的那部分
```

```
int i, j;
for(i=0;i<n;i++){  //外层循环的时间复杂度是：O(n)
	function(i)
}

void function (int count){  /内层循环的时间复杂度是：O(n)
	int j;
	for(j=count;j<n;j++){
		printf('%'，j)
	}
}

上面这段代码的时间复杂度是:O(n^2)，嵌套执行的情况下，整体代码取决于全部嵌套语句执行完的耗时 
```



常见的时间复杂度：

| 例子            | 时间复杂度 | 术语    |
| --------------- | ---------- | ------- |
| 456412          | O(1)       | 常数阶  |
| 3n+4            | O(n)       | 线性阶  |
| 3n^2+4n+5       | O(n^2)     | 平方阶  |
| 3log(2)n+4      | O(logn)    | 对数阶  |
| 2n+3nlog(2)n+14 | O(nlogn)   | nlogn阶 |
| n^3+2n^2+4n+6   | O(n^3)     | 立方阶  |
| 2^n             | O(2^n)     | 指数阶  |



常用时间复杂度所消耗的时间从小到大排序：

  O(1)<  O(logn) <  O(n) <   O(nlogn)<  O(n^2)<  O(n^3)<O(2^n)<O(n!)<O(n^n)



在执行一段代码。如查找某个有n个随机数字的数组中的是否有某个数字时，最好的情况就是第一个数字就是要找的数字，此时算法的时间复杂度为O(1),最坏的情况时要找的数字在数组中的最后一个位置，那么时间复杂度就为  O(n) 。

平均运行时间是期望的运行时间。



#### 算法的空间复杂度——代码所需空间需求

空间换时间 或者 时间换空间。

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度计算公式：S(n) = O( f(n) ),n表示问题的规模，f(n)为语句关于n所占存储空间的函数。







冒泡

排序

链表

