# 计算机科学概论



## 电路基础

物质的最小化学单位是原子，而原子由原子核（正电）和核外电子（负电）组成，核外电子在电场力的作用下可以移动，移动方向是从低电压的方向流向高电压的方向，而形成的电流方向和核外电子的移动方向相反。

电场的方向是从正极指向负极。不同的物质对最外层电子的约束能力不同，所以表现出来的导电性就不同（电阻不同）。单位时间内通过某个平面的电子的数量就表示电流。

欧姆定律：当电压一定，电阻越大，电流就越小。 U=IR

热的本质是组成物质的微观粒子因为运动而碰撞而震动的剧烈程度。

焦耳定律：发热功率等于电压乘以电阻，P=U\*R ， P=I^2\*R。



### 电子二极管

加热灯丝以发射电子。

![image-20220904111936139](..\typora-user-images\image-20220904111936139.png)

![image-20220904112009889](..\typora-user-images\image-20220904112009889.png)

二极管（只让电流从一个方向通过，另一个方向不能通过）用于电子电路中的整流（将交流电变为直流电）。



### 电子三极管

![image-20220904112251085](..\typora-user-images\image-20220904112251085.png)

第三极通上正电，将明显加强原来的二极管中的电流强度，如果加上负电则会明显减弱原来二极管的电流强度。第三极的微小变化必定会引起另外两级之间的电流的巨大变化。**通过这个特性就可以放大信号，实现无线电的远距离传输。**

真空二极管和真空三极管就作为第一批电子工业的重要元器件被广泛使用。

真空电子管的缺点：

1. 体积大
2. 功耗高
3. 容易发生故障（是通过燃烧灯丝工作，灯丝容易烧断）

电子二极管的优点：

1. 面对电磁干扰，电子管有很强的抗干扰性，晶体管则不行

2. 电子管在温度发生较大变化时也可以工作良好，晶体管则不行

基于上面的种种原因，后面出现的晶体管，并逐渐取代了电子二极管。



### 晶体二极管

有的物质容易失去最外层电子（金属类物质），有些物质倾向于获得电子，同时不容易失去最外层电子（绝缘体类物质），而有的物质即不容易失去电子也不容易获得电子（半导体）。

常用半导体物质是 Si——硅，纯硅组成的物质被称为本征半导体，如果往纯净的硅中加入一些磷，磷的最外层 5 个电子，多出的电子容易移动，这就形成了 N 型半导体，如果在纯净的硅中加入最外层 3 个电子的硼，就组成了 P 型半导体。

当将 P 型半导体和 N 型半导体组织在一起后，在接触面中，电子会从高浓度的 N 型半导体中转移一部分到 P 型半导体中，这样 N 型半导体的接触面就因为缺少部分电子而显正电性，P 型半导体的接触面就因为富余部分电子而显负电性，这样就在接触面两端形成了电压，从而阻止电子的继续扩散。

由于两端电子浓度差的差异，导致两端有电子从 N 型半导体往 P 型半导体移动的倾向，同时由于电子的不断移动，又导致 N 型半导体端对电子有吸引力，最后会形成一个平衡，同时伴随一定的以因 电子浓度差而带来的电压（电场）。这个内部的电场区域就称为 PN 节。

如果引入一个外部电场，该电场的电压方向和 PN 节的内部电场的电压方向一致，这样就能阻止更多区域的电子的扩散，也就形成了断路。反向引入一个外电场时，就会吸引更多区域的电子进行扩散，一旦外部电场的电压大于内部 PN 节形成的电场，这就形成了通路。

PN节的内电场一般需要0.7V的电压（导通电压）。



### 晶体三极管



![image-20221001101808896](.\images\image-20221001101808896.png)		

上图中，无论怎么通电，电路都不会导通，因为有两个背对背的 PN 结。



![image-20221001101924663](.\images\image-20221001101924663.png)

中间的 2 号区域被做得很薄；1 号 N 区域被故意参杂了许多最外层 5 个电子的磷元素，导致电子浓度很高；一旦 1 号和 2 号直接通电打通 PN 结，则 1 号中的电子会瞬间大量涌入 2 号中，由于 2 号很薄，所以一下子很难快速消费掉这些电子；3 号被故意做得很大且电子浓度低一些，这时 2 号和 3 号之间就因为电子浓度差，导致 2 号中的电子因为扩散作用而扩散到 3 号中，由于 3 号接正极，所以电子能从这里流出。

![image-20221001102547777](.\images\image-20221001102547777.png)

![image-20221001102625902](.\images\image-20221001102625902.png)

可以理解位 2 号和 3 号之间通电，而 2 号的电子来源于 1 号，所以间接的 1 号和 3 号之间通电了。

由于 2 号很薄，消费来自 1 号的电子的能力有限，所以电流一般比较小，3 号由于空间大，吸收电子能力强，所以电流一般比较大。二号极小的信号改变就会导致 1 号电子涌入量的巨大变化，从而引起 1 号和 3 号之间电流的巨大变化。

![image-20220904121727091](..\typora-user-images\image-20220904121727091.png)

![image-20220904162147902](..\typora-user-images\image-20220904162147902.png)



### 场效应管

mos 管的场效应结构图

![image-20220904172103511](..\typora-user-images\image-20220904172103511.png)

下面的半导体材料和 1，2，3 号金属之间有一个非导体的二氧化硅层，所以 2 号金属和下面的半导体材料是分开的，而 1 和 3 号则是和 N 型半导体直接连接的。

P 型和 N 型半导体之间有 PN 节，如果 1 和 2 都接到负极，而 3 号接到正极，则 3 号不能克服 PN 节而和 1 号导电。这是上图的情况整个电路就是关闭状态。

如果将 2 号电压换为正极，2 号的金属通过中间的二氧化硅层后，和下面的半导体材料形式一个电场，即和 2 号金属靠近的半导体材料的一侧的电子浓度高，如下图：

![image-20220904172740854](..\typora-user-images\image-20220904172740854.png)

这样的结果导致上图右边的原来的 N 型半导体和 P 型半导体在靠近二号金属的部分的 N 和 P 就要互换了（反型层），在中间接近金属 2 的区域 P 型半导体的电子量多余了两侧的 N 型半导体，于是电子开始向 N 型半导体中扩散，具体是向 3 号金属一侧扩散，因为左侧接着电源的负极，会排斥电子。

![image-20220904173229392](..\typora-user-images\image-20220904173229392.png)

左边的 N 型半导体因为链接负极，所有会有电子不断补充进来，以供应 3 号的电子需求。这样 1 号和 3 号在 2 号的控制下通电了。

![image-20220904173300946](..\typora-user-images\image-20220904173300946.png)

最后一号和 3 号金属在 2 号的控制下形成了通路。

![image-20220904173414812](..\typora-user-images\image-20220904173414812.png)

![image-20220904173422736](..\typora-user-images\image-20220904173422736.png)

栅极的正负控制着电路的通阻，如果正电表示 1，负电表示 0，那就能在栅极上通过 0 和 1 控制电路的通与断。所以**场效应管目前已经成各类门电路，集成电路，芯片的基础结构。**

其他许多电路和元器件都是在晶体管的基础上以不同的结构组织起来实现的。



### 布尔代数

把逻辑推导进行了符号化，这和逻辑电路联系紧密。

在香农的论文中，将布尔代数应用到逻辑电路系统中，继电器是一种电磁机械装置，利用电生磁的原理，通过线圈的通电去吸引导体导通电路。

<img src="..\typora-user-images\image-20220904175238266.png" alt="image-20220904175238266" style="zoom:50%;" />



电压和电位：电压是绝对的，电位是相对的。一般在研究电路中，为了简化问题，一般会选择一个明显的电位参考点并默认他的电位是 0，分析电路时，各个点的电位都参考选择的那个点。比如电源的负极就是一个很好的零电位点，电路设计中一般将所有的零电位汇集的点称为接地点。

在电路中，一般将电位位 0 的参考点称为地（GND），连接这一点的线就是接地线。

在数字电路中，其实并不需要关系电压具体是多少，需要做的是把通电和断电区分开来，可以具体多少到多少电压代表通电，多少到多少代表断电。一般把有电通过数字 1 表示，没电通过数字 0 表示。



### 逻辑非

输入 1，输出 0

输入 0，输出 1



晶体三极管表示的逻辑非电路：

![image-20220904201325798](..\typora-user-images\image-20220904201325798.png)

![image-20220905212355188](..\typora-user-images\image-20220905212355188.png)



### 逻辑与

输入 1 和 1，输出 1

输入 1 和 0，输出 0

输入 0 和 0，输出 0

![image-20220902214034595](..\typora-user-images\image-20220902214034595.png)

晶体二极管表示的逻辑与电路：

![image-20220904200147236](..\typora-user-images\image-20220904200147236.png)

A:0, B:0 => Y:0

A:1, B:0 => Y:0

A:0, B:1=> Y:0

A:1, B:1 => Y:1

![image-20220904200246697](..\typora-user-images\image-20220904200246697.png)

![image-20220904200330329](..\typora-user-images\image-20220904200330329.png)

![image-20220905213119253](..\typora-user-images\image-20220905213119253.png)

![image-20220905213156307](..\typora-user-images\image-20220905213156307.png)

![image-20220905213238610](..\typora-user-images\image-20220905213238610.png)

![image-20220905213250709](..\typora-user-images\image-20220905213250709.png)

![image-20220905213306127](..\typora-user-images\image-20220905213306127.png)

![image-20220905213332179](..\typora-user-images\image-20220905213332179.png)

### 逻辑或

输入 0 和 0，输出 0

输入 1 和 0，输出 1

输入 1 和 1，输出 1

![image-20220902214052519](..\typora-user-images\image-20220902214052519.png)

晶体二极管表示的逻辑或电路：

![image-20220904200916515](..\typora-user-images\image-20220904200916515.png)

![image-20220905212447895](..\typora-user-images\image-20220905212447895.png)

![image-20220905212728901](..\typora-user-images\image-20220905212728901.png)

![image-20220905212800873](..\typora-user-images\image-20220905212800873.png)

![image-20220905212819638](..\typora-user-images\image-20220905212819638.png)

![image-20220905212853360](..\typora-user-images\image-20220905212853360.png)

![image-20220905212914924](..\typora-user-images\image-20220905212914924.png)

### 逻辑与非

图中的小圆圈可以表示在原来逻辑的计算结束后，再做一下非运算输出。

输入 1 和 1，输出 0

输入 1 和 0，输出 1

输入 0 和 0，输出 1

![image-20220902214122454](..\typora-user-images\image-20220902214122454.png)

![image-20220904201636617](..\typora-user-images\image-20220904201636617.png)

![image-20220902214754618](..\typora-user-images\image-20220902214754618.png)

![image-20220905213338049](..\typora-user-images\image-20220905213338049.png)

### 逻辑或非

输入 1 和 1，输出 0

输入 1 和 0，输出 0

输入 0 和 0，输出 1

![image-20220902214139882](..\typora-user-images\image-20220902214139882.png)

![image-20220902214736905](..\typora-user-images\image-20220902214736905.png)

![image-20220905212921593](..\typora-user-images\image-20220905212921593.png)

### 逻辑异或

两个输入不同，则输出为 1，两个输入相同，则输出为 0。

![image-20220902215307918](..\typora-user-images\image-20220902215307918.png)

![image-20220902215240276](..\typora-user-images\image-20220902215240276.png)

![image-20220905213752516](..\typora-user-images\image-20220905213752516.png)

![image-20220905213519467](..\typora-user-images\image-20220905213519467.png)





#### 半加器

**异或门可以用来作加法运算。**

在一个异或逻辑门电路中，这个逻辑门只能处理一比特的数，所以 1 加 1 虽然在二进制中等于 10，但是异或门只能表示一位，而无法处理进位而选择丢弃。 二进制的的进位发生在两个都是 1 的时候，这就是一个与逻辑门。把两个输入通过与门运算作为一个进位 。

![image-20221001181558126](.\images\image-20221001181558126.png)

下图中，虽然我们的电路具有输出进位的功能。但是并不具备接受进位的功能。低位的进位 1 并没有被高位接收，这种加法器叫**半加器**。

![image-20221001181709272](.\images\image-20221001181709272.png)

![image-20221001181834612](.\images\image-20221001181834612.png)

#### 全加器

支持接收进位的加法器——全加器。

![image-20221001181953353](.\images\image-20221001181953353.png)

在用门电路设计一个数字电路系统时，一般的步骤是：

1. 先明确电路的输入输出功能 

![image-20221001182148897](.\images\image-20221001182148897.png)

2. 画出该系统的真值表，也就是列举所有输入和输出之间的对应关系 

![image-20221001182245368](.\images\image-20221001182245368.png)

3. 根据真值表推导得出电路的逻辑函数

> 在逻辑代数中用 •（点乘符号）代表逻辑与
>
> 用 +（加号）代表逻辑或
>
> 用 ⊕ 表示异或逻辑
>
> 用 X` 表示 X = 0 的状态 ，X 表示 X = 1 的状态

找出上图**本位**输出 Y 为 1 时，输入的情况，就可以得到输出 Y 关于输入的逻辑代数表达式：

```
Y = Ci`•A`•B + Ci`•A•B` + Ci•A`•B` +  Ci•A•B
```

找出上图**进位**输出 Co 为 1 时，输入的情况，就可以得到输出 Y 关于输入的逻辑代数表达式：

```
Co = Ci`•A•B + Ci•A`•B + Ci•A•B` +  Ci•A•B
```

4. 用逻辑数学公式化简上面的函数或者用卡诺图化简该函数
5. 用化简后的逻辑关系函数设计连接门电路

![image-20221001183548633](.\images\image-20221001183548633.png)

上图，输出 Y 是输入 A，B 异或的结果再异或上进位 Ci。进位输出 Co 的结果是 A 与上 B 再或上 进位 Ci 与上 A 和 B 异或的结果。

**上面就是用逻辑代数的定理公式以及卡诺图去化简逻辑函数，从而简化电路的过程。**



数字电路也有一套自己的数学工具和通用的精细化设计方法。

![image-20221001184243953](.\images\image-20221001184243953.png)



<img src="../计算机基础/images/image-20221106111451524.png" alt="image-20221106111451524" style="zoom:50%;" />

 

#### 全减器

![image-20221001184609045](.\images\image-20221001184609045.png)

![image-20221001184637940](.\images\image-20221001184637940.png)

![image-20221001184705110](.\images\image-20221001184705110.png)



减法器往往不需要单独设计电路，可以在加法器的基础上设计一套算法实现减法器的功能。



### 同或门

![image-20220905214011039](..\typora-user-images\image-20220905214011039.png)

上面演示了同或门和异或门为了方便理解使用了 10MOSFET，在实际设计电路的过程中，一般会用传输门来设计同或门和异或门。

借助传输门实现的异或门电路图：

![image-20220905214434452](..\typora-user-images\image-20220905214434452.png)

![image-20220905214456596](..\typora-user-images\image-20220905214456596.png)z

![image-20220905214520426](..\typora-user-images\image-20220905214520426.png)

借助传输门实现的同或门电路图：

![image-20220905214541665](..\typora-user-images\image-20220905214541665.png)

![image-20220905223627413](..\typora-user-images\image-20220905223627413.png)

讲解逻辑门的目的：

逻辑门是构成运算单元的最基本结构，比如用一个异或门加一个与门就可以构成一个半加法器，如图：

![image-20220905223822351](..\typora-user-images\image-20220905223822351.png)

半加法器可以计算一位二进制的加法。

用两个异或门加两个与门加一个或门就可以组成全加法器，如图：

![image-20220905224025959](..\typora-user-images\image-20220905224025959.png)

把两个全加法器组合在一起就能实现两位二进制的加法器，如图：

![image-20220905224129545](..\typora-user-images\image-20220905224129545.png)

四个全加法器组合实现四位二进制数的加法器，如图：

![image-20220906174102736](..\typora-user-images\image-20220906174102736.png)

香农定义 bit 作为信息的度量单位。

### 比特存储装置

通过一个设置位开关，控制了 1 比特信息的输入。简易符号：

![image-20220902220757061](..\typora-user-images\image-20220902220757061.png)

![image-20220902220704089](..\typora-user-images\image-20220902220704089.png)

![image-20220902215404856](..\typora-user-images\image-20220902215404856.png)

in：表示输入

out：表示输出

set：负责控制输入能否被被设置到输出

首先初始 out 的值为 0，然后将 in 的状态设置为 1，将 set 设置位打开，1 表示打开，0 表示关闭。 如此设置好后，最后由输入 in 1 得到输出 out 为 1，然后 c 被重新设置为 0，out 仍然是 1。 这就得到输入的和输出是一样的值。

![image-20220902220005535](..\typora-user-images\image-20220902220005535.png)

上图导致 out 被重置为 1：

![image-20220902220036443](..\typora-user-images\image-20220902220036443.png)

当输入 in 为 0 时，out 继续用前上面设定的 1：

![image-20220902220211443](..\typora-user-images\image-20220902220211443.png)

上图最终导致 out 值为 0

![image-20220902220323980](..\typora-user-images\image-20220902220323980.png)

将设置位 set 关闭（即设置值为 0 的情况），且假设 out 原来的状态就为 0，最后 out 的值并不会变化。

![image-20220902220531145](..\typora-user-images\image-20220902220531145.png)

### 字节存储装置

将 8 个比特存储装置串起来，通过一个设置位同时控制 8 个比特的输入，那就可以一次控制一个字节的输出，即字节存储装置。

<img src="..\typora-user-images\image-20220902220909323.png" alt="image-20220902220909323" style="zoom:50%;" />

![image-20220902221022350](..\typora-user-images\image-20220902221022350.png)

上图字节存储装置只能控制是否允许输出。

### 字节输出装置

![image-20220902221717936](..\typora-user-images\image-20220902221717936.png)

![image-20220902221807930](..\typora-user-images\image-20220902221807930.png)

![image-20220902221753784](..\typora-user-images\image-20220902221753784.png)

上图中如果 e 位打开（设置为 1），则 8 位输入经过 8 个与门后将保持原值输出。如果 e 位关闭（设置为 0），则无论输出值为多少，都将输出 0。所以这种装置可以用于控制输出。

### 将字节存储和字节输出装置组合

![image-20220902222108114](..\typora-user-images\image-20220902222108114.png)

**就得到一个即能控制是否输入，也能控制是否输出的装置——寄存器**。上图时一个 8 位寄存器。简易画法：

![image-20220902222234001](..\typora-user-images\image-20220902222234001.png)

![image-20220902223642490](..\typora-user-images\image-20220902223642490.png)

将输入输出的一组 8 根线，简化为一根总线。

![image-20220902222510042](..\typora-user-images\image-20220902222510042.png)

上图是在总线上连接的三个寄存器。

将寄存器 R1 中存储的状态输出到寄存器 R3，首先，先将 R1 的 e 位打开，R1 中存储的状态就输出当总线中，在将 R3 的输入 S 打开，就将总线设置到了 R3，随后先关闭 R3 的输入，再关闭 R1 的输出，这样就将 R1 和 R3 设置为了相同的状态，也就是所谓的将字节从 R1 移动到了 R3。

![image-20220902223439351](..\typora-user-images\image-20220902223439351.png)

![image-20220902222621854](..\typora-user-images\image-20220902222621854.png)

**后续讲解怎样选择特定的寄存器，并控制该寄存器的输入和输出（即内存的工作原理）。**

现在有两行两列共 4 个寄存器，通过总线相连，这四个寄存器有各自的输入控制位和输出控制位，现在的需求是明确控制某个寄存器，打开或者关闭它的输入或者输出控制位，以选中 R1 的输入控制为例子（即将 R1 的 S 位设为 1）：

![image-20220903162402763](..\typora-user-images\image-20220903162402763.png)

但是 R1 的输入是否到打开有两个条件，而且两个条件必须都成立才行，所以适合在 R1 的 S 位前放置一个与门，一个输入来自 CPU 的状态，另一个输入来自寄存器的选中状态，而是否选中某个寄存器也有两个条件（即寄存器所在行被选中和寄存器所在列被选中），而且必须两个条件都满足，才能表示选中指定位置的寄存器，所以也适合用于个与门。参考下图：

![image-20220903163152986](..\typora-user-images\image-20220903163152986.png)

这样总线的状态就被设置到 R1 寄存器中了。

即控制输入也控制输出的示图：

![image-20220903163255930](..\typora-user-images\image-20220903163255930.png)

打开 R3 的输出：

![image-20220903163451413](..\typora-user-images\image-20220903163451413.png)

打开 R2 的输出：

![image-20220903163540802](..\typora-user-images\image-20220903163540802.png)

### 编码器

编码器一般用来将多路通道信息转换成二进制数编码，用于后续电路的分析。

### 译（解）码器

译码器一般将特定位数的二进制数字编码翻译为不同的信号输出。

**选择特定行和列寄存器。**

通过解码器选择特定行和列寄存器。解码器的作用就是根据不同的输入状态对应不同的输出状态，这样就可以通过解码器的输入，来控制哪一个输出状态是 1。

2\*4 解码器：

![image-20220903164033911](..\typora-user-images\image-20220903164033911.png)

![image-20220903163723784](..\typora-user-images\image-20220903163723784.png)

![image-20220903163808363](..\typora-user-images\image-20220903163808363.png)

![image-20220903163822759](..\typora-user-images\image-20220903163822759.png)

![image-20220903163853518](..\typora-user-images\image-20220903163853518.png)

3\*8 解码器：

![image-20220903164119957](..\typora-user-images\image-20220903164119957.png)

![image-20220903164149945](..\typora-user-images\image-20220903164149945.png)

有了解码器就可以定位到任意一个寄存器，从而实现寄存器到总线，总线到寄存器，以及寄存器到寄存器的字节移动，这种随机地址存储器，就是所谓的 RAM（Random Access Memory）——内存。

**解码器也需要输出，所以还有提供一个提供行号和列号的寄存器。**即内存地址寄存器（Memory Address Redigter）

案例：

![image-20220903165321778](..\typora-user-images\image-20220903165321778.png)z

![image-20220903165346301](..\typora-user-images\image-20220903165346301.png)

使用逻辑门进行算数或者逻辑运算，尝试一步步的执行指令 ——CPU。

### CPU

通过一个逻辑与可以得到两个比特的逻辑与运算结果：

![image-20220903170514351](..\typora-user-images\image-20220903170514351.png)

如果想获得两个字节的逻辑与运算结果，可以把 8 的逻辑与门组合起来实现。

两个字节的逻辑与运算：

![image-20220903170640637](..\typora-user-images\image-20220903170640637.png)

两个字节的逻辑或运算：

![image-20220903170659014](..\typora-user-images\image-20220903170659014.png)

两个字节的逻辑异或运算：

![image-20220903170758384](..\typora-user-images\image-20220903170758384.png)

一个字节的逻辑非运算：

![image-20220903170856122](..\typora-user-images\image-20220903170856122.png)

移位运算：

![image-20221002154153423](.\images\image-20221002154153423.png)

![image-20221002154221121](.\images\image-20221002154221121.png)

![image-20221002154232884](.\images\image-20221002154232884.png)

#### 加法器

二进制的加法计算某一位的相加结果时，需要考虑三个二进制数字的逻辑运算结果，这三位分别是两个二进制数的本位和 两个二进制数的前一位的相加结果（进位）的值；同时记录相加的结果值和得到输出的进位值。

![image-20221006193916531](.\images\image-20221006193916531.png)

情况：

1. carry in 为 0 ，当 a 和 b 相同时，sum 为 0 ；不同时 sum 为 1 ，对应 a 和 b 的异或逻辑

2. carry in 为 1，当 a 和 b 的异或逻辑为 1 时，sum 为 0；当 a 和 b 的异或逻辑为 0 时，sum 为 1

   考虑 carry out

3. carry in 为 0，当 a 和 b 都为 1 时，carry out 为 1

4. carry in 为 1，当 a 和 b 的异或逻辑为 1 时，carry out 为 1；或者当 a 和 b 的与逻辑为 1 时，carry out 为 1

对应的逻辑电路图：

![image-20221006194732220](.\images\image-20221006194732220.png)

比特加法器：

![image-20221006194849103](.\images\image-20221006194849103.png)

一字节的加法器：

![image-20221006195024811](.\images\image-20221006195024811.png)

![image-20221006194920069](.\images\image-20221006194920069.png)

![image-20221006195013960](.\images\image-20221006195013960.png)

#### 比较器

比较两个字节的大小。当比较两个字节时，会从两个的高位比特开始，上一位 bit 相等则继续比较下一位。

逻辑门电路图：

![image-20221006195403402](.\images\image-20221006195403402.png)

![image-20221006195503564](.\images\image-20221006195503564.png)

![image-20221006195546675](.\images\image-20221006195546675.png)

判断一个字节是否全为零：

![image-20221006195635085](.\images\image-20221006195635085.png)

#### ALU

运算器

![image-20221006195723739](.\images\image-20221006195723739.png)

![image-20221006200305517](.\images\image-20221006200305517.png)

![image-20221006200342119](.\images\image-20221006200342119.png)

虽然上图右侧的 ALU 工作时，每种运算逻辑电路都会同时接收到相同的输入，也都会工作，但上图的 3\*8 解码器，每次会根据输入，选择唯一的一个逻辑电路的运算结果，打开输出电路，将结果作为输出。



接下来，在该内存中存储一些操作指令（二进制机器码），并规定每种操作对应的二进制编码。

IAP寄存器：存储下一步执行的指令的内存地址（在RAM中位置）。

IR寄存器：存储当前要被执行的计算机指令二进制码。

Control Section：就是CPU中的控制器，里面的布线十分复杂，可以识别指令寄存器（IR）存储的二进制码是什么类型的指令，并将指令处理后进行对其他寄存器进行输入输出控制或者将指令解析后传递ALU进行运算。

即使是一个简单指令，可能也需要经过好几个操作步骤才能完成。

比如，执行LOAD R1 R2。寄存器R1中存储了RAM中的一个内存地址，该内存地址中存储了数据， LOAD指令负责将R1中的内存地址中的数据加载到R2中，首先，会将打开R1寄存器的输出，和MAR的输入，将R1中的地址数据通过总线，存放到MAR中，有解码器解析内存地址数据，选中指定的内存，同时通过控制器让该内存地址的存储器的数据输出到数据总线中，然后打开IR的寄存器输入，将指令同步到IR寄存器中，然后在通过控制器，进过类型的控制，将IR寄存器中的数据同步到R2中。

这中间有一些列一步步的操作，这就依靠不步进器实现的。



![image-20221006205724449](.\images\image-20221006205724449.png)

控制器对指令寄存器中存储的指令进行解析。

#### 步进器

![image-20221007184643688](../typora-user-images/image-20221007184643688.png)

![image-20221007184652760](../typora-user-images/image-20221007184652760.png)

借助它组装步进器。



![image-20221007184744833](../typora-user-images/image-20221007184744833.png)

![image-20221007184753412](../typora-user-images/image-20221007184753412.png)

M表示存储一比特信息的逻辑电路，通过set能控制该装置能不能将out和in进行同步。

CLK链接这这些比特装置的输入控制位，reset通过非门链接第一个比特装置的输入位，后面前一个比特装置的输出out连接到下一个比特装置的输出in，最初这些M存储的状态都是0。二号比特装置初始状态是0，所以经过非门后，输出为1，所以初始状态时，setp1是打开的，如下图：

![image-20221007190108783](./images/image-20221007190108783.png)

当clk第一次变为1时，所有偶数序号比特装置的输入控制打开



 <img src="./images/image-20221007190221860.png" alt="image-20221007190221860" style="zoom:33%;" />

但是二号装置没有变化，setp1仍旧是打开的，接下来clk变为0，所有偶数序号的比特装置的输入控制都关闭，奇数为的打开

<img src="./images/image-20221007190328731.png" alt="image-20221007190328731" style="zoom:50%;" />

1号存储装置的状态变为1，2号因为输入控制位关闭，所有2号的状态不受影响，所以在时钟滴答的第一个周期内，setp1处于打开状态。

![image-20221007191346930](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007191346930.png)



在第二个时钟周期中，clk再次变为1，偶数号的装置输入都又被打开，这次2号装置接受到1号装置的输出1，这导致setp1被关闭，而4号装置的状态是0，所以setp2被打开，clk再次变为0时，奇数位装置的输出被打开，3号装置接受到2号的输出1，还是不影响4号的输出，setp2仍旧是打开的。

![image-20221007191718340](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007191718340.png)

如此往复 ，下个时钟周期关闭step2，开发哦step3，所以这个步进器可以按照顺序在每个时钟周期内打开一个step输出，而关闭其他。当步进器走到最后的第12个装置后，第12号的out连接到reset，将reset置为1。

![image-20221007192113489](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007192113489.png)

这时下面的或门的输出都为1，导致所有比特装置的输入都打开，然后一个接一个的被重置状态为0，恢复到初始setp1被打开的状态。

![image-20221007192347287](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007192347287.png)

![image-20221007192422091](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007192422091.png)

上面就是步进器的工作原理。

下图是步进器的图形表示：

![image-20221007192532444](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007192532444.png)

如果在步进器的每个setp中控制一些寄存器的输入和输出，就可以一步步的实现编程逻辑。



针对下图的这两个时钟装置：

![image-20221007210111733](C:/Users/shuyi/Desktop/study-notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA.images/image-20221007210111733.png)

将时钟装置中的线路延长，让clk d 的时钟周期的变化往后延迟，如果将它们组合到一起来控制输入和输出，clk和clk d都为1时，输入控制位才会被打开，而它们两者只要有任何一位为1时，都会打开输出控制位，所以输出控制位会先于输入控制位打开，并且在输入控制位关闭后才会关闭输出控制。

这样做的目的：**在移动字节时，要先将源寄存器中的内容输出到总线，然后才可以打开目的寄存器的输入，而且要先关闭目的寄存器的输入，再关闭源寄存器的输出。**

![image-20221007210321973](./images/image-20221007210321973.png)



现在将时钟的输出控制位连接到寄存各个输出设置，将时钟的输入控制位连接到各个寄存器的输入设置，这样就能保证寄存器的输出控制位先于输入控制位打开，输入控制位先于输出控制位关闭。CPU中的控制器就是利用步进器控制一团团的布线完成各种操作指令。

<img src=".\images\image-20221006205814667.png" alt="image-20221006205814667" style="zoom: 50%;" />

<img src="./images/image-20221007210632162.png" alt="image-20221007210632162" style="zoom:33%;" />

假如有这样一组布线，在setp1打开时，打开指令地址寄存取（IAR）的输出和内存地址寄存器的（MAR）的输入，指令地址寄存器存储的是下一条待执行指令的内存所在地址，将这个地址存入内存地址寄存器（MAR）；在setp2中，将setp1中的指令地址寄存器中通过解码器解码选中的内存（RAM）中存放的指令输出到指令寄存器（IR）中，这样就完成了一次指令的加载。

问题：**指令地址寄存器怎么在加载完一条指令后，就存储下一条指令所在的内存地址？**

这就要用到上图中的ACC和TMP寄存器。

ACC寄存器：用于存储运算器（ALU）的计算结果。

TMP寄存器：是一个没有输出控制位的寄存器，放到TMP中的数据就是要在ALU中使用的。

Bus1：它是一个比特位，如果bus1为0，经过非门后，TMP的高七位都会和1进行与运算，第一位和0进行或运算，则TMP的输出不会发生任何变化并且输出到运算器的输入；当bus1打开，即为1时，TMP高七位都于0进行与运算，则高七位都为0，第一位都和1进行或运算，输出1，所以无论TMP输出的是什么，在bus1打开时，输入到运算器的B的值都为1。

<img src="./images/image-20221007211907546.png" alt="image-20221007211907546" style="zoom:50%;" />

 而运算器（ALU）的operation默认存储的是000，选中加法运算，这样只要将指令地址寄存器，同时将bus1置为1，并打开ACC的输入，则运算器的输入A就是总线上的指令内存地址（指令地址寄存器的内容），运算器的输入B就一定是1，此时ACC会接受到家发器的运算结果，即内存地址加1后的下一个内存地址，如下图：

<img src="./images/image-20221007213909562.png" alt="image-20221007213909562" style="zoom:50%;" />

对应到控制器中布线，如下图：

步进器中step1为1时，控制IAR的输出和bus1，并打开内存地址寄存器（MAR）和ACC的输入，这样指令地址寄存器中的数据就输出到总线并设置到MAR中，而总线上的IAR和打开的bus1会经过运算器进行加法运算存储到ACC中；

在step2中，将RAM输出到IR中（即将内存地址中的指令放到指令寄存器中）；

在step3中，将ACC输出到IAR中，IAR中存储的就是相邻的下一个内存地址。

![image-20221007214759304](./images/image-20221007214759304.png)

对于每一条指令而言，前三步都是这样布线的，所以只能在4，5，6中实现指令的对应操作。





时钟装置，周期性变化，借助时钟装置就可以组装步进器

CPU 的最基本的结构：MOSFET（金属氧化物半导体场效应晶体管）

逻辑门

运算单元

存储单元

时钟同步

从最底层理解 CPU 内部怎么利用电进行计算以及 CPU 是如何通过一个个的逻辑门电路搭建和制造的。

对 CPU 的工作原理和制作生产过程有了解。

#### 晶体二极管

![image-20220905200153629](..\typora-user-images\image-20220905200153629.png)

在 N 型半导体中，电荷的载体（载流子）是电子

在 P 型半导体中，电荷的载体（载流子）是空穴

![image-20220905200226351](..\typora-user-images\image-20220905200226351.png)

![image-20220905200251194](..\typora-user-images\image-20220905200251194.png)

![image-20220905200335741](..\typora-user-images\image-20220905200335741.png)

![image-20220905200453117](..\typora-user-images\image-20220905200453117.png)x

![image-20220905200349986](..\typora-user-images\image-20220905200349986.png)

![image-20220905200427083](..\typora-user-images\image-20220905200427083.png)

#### MOSFET（晶体三极管）

基于二极管制作的用电压控制的开关。

工作原理：

![image-20220905200547979](..\typora-user-images\image-20220905200547979.png)

![image-20220905200618711](..\typora-user-images\image-20220905200618711.png)

![image-20220905200642099](..\typora-user-images\image-20220905200642099.png)

![image-20220905194218967](..\typora-user-images\image-20220905194218967.png)

![image-20220905200902400](..\typora-user-images\image-20220905200902400.png)

上图得到一个可以通过电压控制电路通断的装置。当给中间的电极加上正电，当电压高于阈值电压后，mosfet 可以导通，低于阈值电压则不能导通。这就是 mosfet 的工作原理。

**上图中是在高于阈值电压时电路导通，低于阈值电压时电路断开的晶体三极管叫——NMOS**

![image-20220905210114266](..\typora-user-images\image-20220905210114266.png)

**上图中是在高于阈值电压时电路断开，低于阈值电压时电路导通的晶体三极管叫——PMOS**

电路图中的表示符号：

![image-20220905210253294](..\typora-user-images\image-20220905210253294.png)

将 NMOS 和 PMOS 的漏极连接在一起，就得到了 CMOS：

![image-20220905210439281](..\typora-user-images\image-20220905210439281.png)

如果把 G 级连接起来作为输入端，两个 D 极的作为输出端 B，如下图：

![image-20220905210652441](..\typora-user-images\image-20220905210652441.png)

VDD：供电电压

VSS：接地电压

上图就组成了一个非门电路，当 A 输入 正向偏压，电压高于 NMOS 的阈值电压时，PMOS 不导通，NMOS 导通，相当于 B 端直接和接地电压（低电压）连接，是相对低电压；当 A 中输入反向偏压时， PMOS 导通，NMOS 不导通，相当于 B 直接和供电电压相连接，输出的就是相对高压。

![image-20220905210749868](..\typora-user-images\image-20220905210749868.png)

![image-20220905211148209](..\typora-user-images\image-20220905211148209.png)

![image-20220905211247642](..\typora-user-images\image-20220905211247642.png)

如果现在规定相对高压代表 1，相对低压代表 0，上面的电路就是对输入结果取反，即非门逻辑。

![image-20220905211434605](..\typora-user-images\image-20220905211434605.png)

![image-20220905211459578](..\typora-user-images\image-20220905211459578.png)

MOSFET 是构成逻辑门电路最基本的单元，当把各种逻辑门组合在一起就可以形成运算端单元，这就是 CPU 的雏形，如果再加上各种存储单元和其他电路就构成了完整的 CPU。

#### CPU 计算加法

通过 NMOS 和 PMOS 进行不同的连接与组合，就可以得到用于计算的逻辑门电路。

前置知识：

1. 二进制和十进制

十进制换算为二进制采用的是除 2 取余逆序排列法。

![image-20220905224651597](..\typora-user-images\image-20220905224651597.png)

29=>11101

二进制转为十进制：

![image-20220905224745818](..\typora-user-images\image-20220905224745818.png)

![image-20220905224812042](..\typora-user-images\image-20220905224812042.png)

2. 本位和数 与 进位

![image-20220905225026325](..\typora-user-images\image-20220905225026325.png)

本位和数：Sum，S

进位：Carry，C

如果只看本位的相加结果：

![image-20220905225206403](..\typora-user-images\image-20220905225206403.png)

这个结果是异或门逻辑。因此，A+B 的本位和数 S 就是 A⊕B

![image-20220905225527656](..\typora-user-images\image-20220905225527656.png)

如果只看进位的结果：

![image-20220905225604231](..\typora-user-images\image-20220905225604231.png)

这个结果是异与逻辑。

![image-20220905225735889](..\typora-user-images\image-20220905225735889.png)

用一个异或门来得到本位和数的值，用一个与门得到进位，就得到了一个可以计算一位二进制数的结构，如图：

![image-20220905230013882](..\typora-user-images\image-20220905230013882.png)

![image-20220905225952187](..\typora-user-images\image-20220905225952187.png)z'z

半加法器没有进位输入，这就导致它只能计算一位二进制的加法，如果想计算多为二进制数的加法，比如 111+101，

第一位是 1+1，本位和数是 0，进位是 1，这是后需要将它们的进位 1 输入给第二位，计算第二位数时，本质上是在计算加数的第二位，被加数的第二位和第一位的进位这三个数的和，如图：

![image-20220905230438301](..\typora-user-images\image-20220905230438301.png)

所以需要一个可以输入上一位进位的加法器，也就是具有三个输入的加法器，输出依旧是两个，本位和数和进位，**本位的结果可以先让 A 和 B 异或一次，在让这个异或输出和 C 异或一次。**对于进位，对于进位是 1 的情况，则需要 A,B,C 中至少又两个数是 1。

![image-20220905230645368](..\typora-user-images\image-20220905230645368.png)

如果 ABC 中有至少 2 个 1 时，就让进位输出 1，方法一：

让 A•B A•C B•C

![image-20220906192022783](..\typora-user-images\image-20220906192022783.png)

![image-20220906192055789](..\typora-user-images\image-20220906192055789.png)

![image-20220906192412724](..\typora-user-images\image-20220906192412724.png)

![image-20220906192447959](..\typora-user-images\image-20220906192447959.png)

![image-20220906192810923](..\typora-user-images\image-20220906192810923.png)

四位二进制全加法器：

![image-20220906193200566](..\typora-user-images\image-20220906193200566.png)

这个加法器必须计算完低位的进位情况 和 和位情况才能算高位的，是串行的——形波进位全加法器，它的延迟很高。

并行进位全加法器：

![image-20220906193743262](..\typora-user-images\image-20220906193743262.png)

![image-20220906195132508](..\typora-user-images\image-20220906195132508.png)



#### CPU 计算减法

减去一个数等于加上这个数的负数。所以只需要将减数表示为负数的形式，然后用加法器执行加法运算就行，所以需要先了解二进制数的负数如何求得。

假设有一个可以存储和计算 4 位二进制数的计算机系统，那这个系统可以存储和计算的二进制数的范围就是 0000~1111，对应十进制数就是 0~15，这种直接将十进制转换为二进制的表示方法就简称为直接表示法，直接表示法的问题是无法表示负数。

![image-20220906204238012](..\typora-user-images\image-20220906204238012.png)

而二进制数的特点是每一位数只可能是 0 或者 1，刚好可以表示正负两种状态，所以有一种表示法是用最高位来表示正负（符号位），0 代表正，1 代表负，其它位为数值位。这种表示正负的方法叫原码表示法：

![image-20220906204620875](..\typora-user-images\image-20220906204620875.png)

![image-20220906204709776](..\typora-user-images\image-20220906204709776.png)

![image-20220906204837356](..\typora-user-images\image-20220906204837356.png)

原码表示法有一个问题：符号不同的数不能直接相加。

![image-20220906204947747](..\typora-user-images\image-20220906204947747.png)

原码表示法表示的一个二进制数值是不能直接用于运算的，有一种方法可以表示清除负数的同时可以用于运算——**补码**

在一个 4bit 的计算机系统中，如果使用直接表示法，能表示的最小数是 0000，最大数是 1111，如果对 1111 加 1 就会变为一个 5bit 的数。但是由于这个系统只能容纳 4bit 的二级制数，第 5 位的 1 就溢出了，在系统中无法被表示，会被自动舍弃，所以最后的结果就是 0000。

![image-20220906205318201](..\typora-user-images\image-20220906205318201.png)

对于存在溢出后重新回到 0 的模运算系统（上面的 4bit 计算机系统或者时钟）来说，加上一个负数和加上这个负数的补数是等价的。

<img src="..\typora-user-images\image-20220906211316110.png" alt="image-20220906211316110" style="zoom:50%;" />

<img src="..\typora-user-images\image-20220906211402163.png" alt="image-20220906211402163" style="zoom:50%;" />

原数每一位按位取反。

<img src="..\typora-user-images\image-20220906211438293.png" alt="image-20220906211438293" style="zoom:50%;" />

**把原数按位取反，然后再加 1 得到的二进制数和原数相加刚好是 0，那这个数和原数相加的数就是元数对应的负数。**——补码表示法

**在计算机中，正数的补码就是正数本身对应的二进制编码，而负数的补码就是负数对应的绝对值的原码取反后加一**

<img src="..\typora-user-images\image-20220906212024960.png" alt="image-20220906212024960" style="zoom:50%;" />

补码的最高位也代表正负，0 为正，1 为负。

<img src="..\typora-user-images\image-20220906212120985.png" alt="image-20220906212120985" style="zoom:50%;" />

和原码不一样的地方是，补码的符号位可以直接参与运算的。

![image-20220906212221061](..\typora-user-images\image-20220906212221061.png)

![image-20220906212243473](..\typora-user-images\image-20220906212243473.png)

### 正负数

#### 补码

八位二进制数 00000001 对应十进制下的 1，而-1 对应的二进制数则是和 00000001 相加为 00000000 的那个数（缘起性空）—— 11111111，相加的结果第九位是 1，后八位是 0，但是对于八位加法器而言（计算机的计算是需要硬件作为载体的），在 8 位加法器中，最高位向第九位进位的时候，因为没有第九个全加器，所以会被丢弃（溢出）。所以在 8 位二进制体系下 11111111 + 00000001 的结果就是 00000000。

将这种和1的二进制数相加后的结果湮灭为零的编码用来表示1的相反数-1。

基于正数，用和这个正数“互补（性空）”的编码定义负数的方式，称之为 **补码**。

负数的二进制数对应为： 该负数的绝对值对应的二进制数按位取反后再加一获得。——**补码**

减法可以看作正数和负数相加，所以可以利用补码的方式表示正负数，也就将加法和减法统一为了加法，所以计算机并不需要为减法计算单独设计一个减法器而导致电路设计上的复杂（规模和功耗）



#### 原码

用原码方式来表示正负数，在原码中，简单的把最高位作为符号位，0开头则表示正数，1开头则表示负数。原码表示的不足如下：

<img src="../计算机基础/images/image-20221106112857011.png" alt="image-20221106112857011" style="zoom: 33%;" />

上面的情况的计算结果就是不对的。但是用补码的方式就能避免这个问题。



### 数据选择器

<img src=".\images\image-20221002091448048.png" alt="image-20221002091448048" style="zoom:50%;" />

上图是一个 4 选 1 的数据选择器，当选择端为 00 时输出 A 路的输入，01 时输出 B 路的输入，其他情况类似，上图就是寻址的一种简单工作模型，通过数据选择控制引脚选择使用哪一路的数据，两个地址引脚就能实现对四个地址的选择，三个引脚能实现对 8 个地址的选择。

如果多路数据输入引脚连接着内存或者寄存器组，那么这个数据选择器就完成了对内存或者寄存器组的寻址功能。



### 实验

题目：在一个实验中，有八杯水有一杯是有毒的液体，同时还有 3 只小鼠，但是小白鼠在喝了有毒液体后 7 天后才会毒性发作，请问如何在一次周期内找到有毒的一杯水？

例子：七段数码管。

将电路中的二进制数字显示到七段数码管中，七个 LED 管随着不同的通电方式，显示出不同的符号或者数字

![image-20221002091517405](.\images\image-20221002091517405.png)





CMOS 管

![image-20221002093654595](.\images\image-20221002093654595.png)

对于上图，如果没有初始的触发信号，则输出是悬空状态。

![image-20221002093848549](.\images\image-20221002093848549.png)

上图在什么都没有输入的情况下，处于悬空状态。如果给电路左侧通上高电压（1），这是两个二极管中间的电压表示 0，右侧输出电压为 1，整个电路中电压分布不矛盾，如果现在撤掉初始推动电压，这个电路仍然维持下图的稳定状态：

![image-20221002094142987](.\images\image-20221002094142987.png)

对于初始输入为 0 的情况也是一样的，像这样有两种稳定状态的系统被称为 **双稳态系统**。



### SR 锁存器

两个或非门互接尾部。

初始状态：

![image-20221002094417910](.\images\image-20221002094417910.png)

现在来考虑给左侧两个输入端输入不同点位，整个系统的变化，

![image-20221002094538565](.\images\image-20221002094538565.png)

情况一：输入 0 0

这种情况并没有什么确定性的输出。所以如果系统一开始是未定义的状态，那输入 0 0 的时候，输出仍旧是未定义状态。

![image-20221002094847758](.\images\image-20221002094847758.png)

情况二：输入 0 1

![image-20221002094922251](.\images\image-20221002094922251.png)

![image-20221002094928675](.\images\image-20221002094928675.png)



情况三：输入 1 0

![image-20221002094952914](.\images\image-20221002094952914.png)

情况四： 输入 1 1

直接锁死为 0，作为输出。

![image-20221002095016615](.\images\image-20221002095016615.png)

电路中的输入不都是外部接入，有两个输入来自输出。

输入 1 0，输出 0 1 ，然后将输入变为 0 0 ，输出将不变，还是 0 1。

![image-20221002121346903](.\images\image-20221002121346903.png)

再将输入变为 0 1，输出将变为 1 0 ，然后再将输入变为 0 0，这是输出还是不变，为 1 0 。**所以当输出为 0 0 的时候将保持上一个状态不变。**

![image-20230121095739380](..\计算机基础\images\image-20230121095739380.png)



因为输出 Q 和 Q`都有可能作为输入，从而影响输出，如果将输出 Q 作为一个输入的话，对应的真值表如下图：

![image-20221002122416666](.\images\image-20221002122416666.png)



这样的一个电路可以用来存储数据，把 Q 作为数据存储端，Q\` 作为和 Q 互补的一个辅助输出端。认为 Q=1，Q\`= 0 时，这个结构存入数据 1；Q=0，Q\`= 1 时这个结构被复位为 0。 S=1，R=0，则输出 Q=1，Q\`= 0；当 S 端的 1 恢复为 0 后，Q 的数据仍旧保持 1 不变，这是就规定向存储单元写入数据 1，S 端也叫置位端（置 1 端）。 S=0，R=1 则输出 Q=0，Q\`= 1，当 R 端的 1 恢复为 0 后，Q 的数据仍旧保持 0 不变，这是规定存储单元被复位为 0。 R 端也叫复位端（置 0 端）。

上面的结构叫**SR 锁存器**。

<img src="../计算机基础/images/image-20221108182431124.png" alt="image-20221108182431124" style="zoom:50%;" />



S=1，R=1是一种特殊的状态，这时 Q=0，Q\`= 0 ，  这不符合前面对这个存储单元中定义的 Q和Q\`必须一个是0，一个是1的定义。 如果只是用Q端存储数据，当 S=1，R=1时，Q端被复位为0。来看一个客观上的问题，不论S=1，R=0，还是S=0，R=1 ，其中都只有一个动作电位，当该动作信号变为0的时候S=0，R=0，输出Q和Q\`仍旧保持不变。如果S=1，R=1，则相当于有两个动作信号，那在撤去之后电路的输出是多少?  假设先撤去S（S=0,R=1）,这样Q=0，Q\`=1，相当于设置输出为0，然后再撤去R（S=0,R=0），这时输出仍就不变（Q=0，Q\`=1）；或者假设先撤去R（S=1,R=0）,这样Q=1，Q\`=0，相当于设置输出为1，然后再撤去S（S=0,R=0），这时输出仍就不变（Q=0，Q\`=1）。

首先这不符合S=0,R=0的输入是保持原有状态不变得定义，两次不同顺序得信号撤离方式得到了不同的结果。如果同时把S和R的1同时置为0，这就是一个办不到的事情（理论上可以，但是实际上一定会因为电路的情况有一个先后。）主观上想一步实现的操作，一定是客观的被分成了两步，结果可能使得SR触发器进入 Q=1，Q\`=0或者Q=0，Q\`=1，但是没法事先确切的确定具体进入的状态。

![image-20230121100210694](..\计算机基础\images\image-20230121100210694.png)



![image-20230121102029942](..\计算机基础\images\image-20230121102029942.png)

![image-20230121102109518](..\计算机基础\images\image-20230121102109518.png)



问题“

- 当电路中有许多SR锁存器时，它们各自动作，改变的时间都不尽相同，信号处理复杂

- 用SR锁存器存储数据时需要两个输入（S置1端，R复位为0端），实际上希望只需要一个输入就可以，输入为1，则设置为1，输入为0则复位为0。

  

为了**同步动作**，产生了**SR触发器**：

<img src="../计算机基础/images/image-20221112213923178.png" alt="image-20221112213923178" style="zoom:50%;" />

CLK为1时，输入功能被锁死为不能输入（S，R不论怎么变都不会影响Q和Q\`）；CLK为0时，输入功能被正常打开工作。

![image-20230121103230759](..\计算机基础\images\image-20230121103230759.png)

多个锁存器使用同一个CLK信号就可以同步出发SR触发器的动作一致性。





为了**单端输入**，产生了D触发器：

<img src="../计算机基础/images/image-20221112214217419.png" alt="image-20221112214217419" style="zoom:50%;" />



![image-20230121103846169](..\计算机基础\images\image-20230121103846169.png)

![image-20230121103900290](..\计算机基础\images\image-20230121103900290.png)

![image-20230121103925424](..\计算机基础\images\image-20230121103925424.png)

这样就只能有3中信号输入了（1，0；0，1；0，0）。

CLK信号则是数字电路中用来一步步控制执行流程的时钟信号（主频）





在数字电路中会遇到很多（包括寄存器）在内的能够暂存数据的单元，基本都是从 SR 锁存器的结构上演化得到。

S=1，R=1 是一种特殊状态，输出 Q=0，Q\`= 0。首先这不符合我们对这个存储单元中，Q和Q\`必须一个是1状态和一个是0状态的定义。

上面的锁存器是用过或非门组成的，也可以使用与非门组成 SR 锁存器。

![image-20221002130710573](.\images\image-20221002130710573.png)



上面介绍的都是电平触发器，电平触发器的一个弱点，即：在一个电平周期内，输入信号可能返回，输出被多次改变，如果遇到电磁干扰就很容易得到错误的输出。于是有出现了其他不同触发方式的触发器。



### 脉冲触发器

**这节课的电平SR触发器定义为高电平的时候触发存储动作，低电平的时候锁上SR触发器。**

下图就是两个SR触发器组成的脉冲触发器（在时钟信号改变的边沿触发信号动作）：

![image-20230121121343623](..\计算机基础\images\image-20230121121343623.png)



低电平时，第一个SR触发器的输入被锁死，输出就固定了，第二个SR触发器的输入被打开。

高电平时，第一个SR触发器的输入被打开，第二个SR触发器的输入被锁死。

这样当在高电平时输入信号可以在第一个SR触发器中反复变化，而第二个SR寄存器的输入被关闭，但是一旦进入低电平时，第一个SR触发器的输入就被锁死，第二个SR锁存器的输入被打开，第一个SR触发器的输出不再改变，而不再改变的输出作为第二个SR触发器的输入，从而在一个电平周期内触发器的输入只会改变一次。

脉冲触发器的不足：主触发器的输入信号反复变化的时候，脉冲的下降沿可能导致错误的输入，不论在高 电平时间内，输入信号如何变化，下降沿的最后一个应该是这个脉冲触发器的最终结果。下降沿之前的高电平期间，主触发器按照输入的信号进行改变，一旦脉冲下降为低电平，那么主触发器被锁死，从触发器把主触发器的输出作为输入，输出在这个周期内和输入毫无关系了，只在脉冲下降的时候完成一次主从交接的信号传输过程，保证从触发器的输出在脉冲周期内只变化一次。

虽然在脉冲周期内只完成一次动作，但是这一次动作对于这种由电平触发的SR触发器组成的脉冲触发器而言，可不一定是准确的，例如，在高电平期间，先是主触发器的S=1，R=0，这时主触发器输出的Q=1，Q\`=0，如下图：

![image-20230121122021136](..\计算机基础\images\image-20230121122021136.png)

紧接着，主触发器的S=0，R=0，，这时应该是SR触发器的状态保持状态，所以这时，主触发器的输出仍然是Q=1，Q\`=0，等到下降为低电平的时候，虽然想当然的认为下降沿来之前的最后一次输入S=0，R=0是这个脉冲触发器的最终的一个输入信号，所以讲道理这个脉冲触发器的SR触发器整体的效果应该是保持上一次的状态不变，但是实际上主触发器的输出是1，0，因此从触发器得到的输入也就是1，0，而不是我们认为脉冲下降前的最后一次输入0，0。   

此时，这两个由电平触发器的SR触发器组成的SR脉冲触发器，就不太符合SR触发器的基本要求了，也就是当输入S=0，R=0的时候，要保持上一个状态不变。

简单来说，我们之所以用两个电平触发的SR触发器来构成脉冲触发器，无非是让主触发器充当信号的传递者，并且在下降为低电平的时候，具有保持这个信号不在受输入干扰的功效。，从触发器作为真正的动作响应单元。  

一个好的数据传递着，最重要的基本素养就是不要改变数据，但是这种情况下，主触发器就是一个不合格的数据传递者。因为在脉冲下降前的最后一次输入信号改变为0，0的时候，主触发器的输出居然没有变为0，0。这也是电平SR触发器的一个特点。





### D触发器（边沿触发器） 

将脉冲触发器中的SR触发器换位D触发器。

<img src="../计算机基础/images/image-20221113115111066.png" alt="image-20221113115111066" style="zoom: 33%;" />

在高电平期间，D触发器的主触发器的输出不论何时都和输入保持一致，在电平下降那一刻也是一样的，电平下降主触发器锁死，从触发器触发，从触发器的输出一直和主触发器的输入输出保持一致。这种触发器的输出只取决于脉冲下降边沿那一刻的输入信号，所以这种用两个D触发器组成的脉冲触发器开始表现出其”边沿动作“的特性，在下降沿之前之后的任何输入都无法改变其最终的输出。将数据读取的时刻压缩到下降沿的一瞬间，所以也成这种触发器为边沿触发器。

电平触发器和脉冲触发器因为工作时无法应对输入信号的反复横跳，而导致输出变得不可控而很少得到使用。常用的就是D触发器了。

触发器可以用于构造CPU中的寄存器。

如果是一个8位的计算机，其CPU中的寄存器就是用来临时存储一个8位数据的寄存器单元。





下面这个电路结构：

<img src="../计算机基础/images/image-20221109190310432.png" alt="image-20221109190310432" style="zoom: 33%;" />

这是一个移位寄存器，八位数据不再需要一次性的输入，可以在一个脉冲周期内输入1位，然后通过脉冲信号依次将其右移。这样八个脉冲周期后，这个移位寄存器就存入了一个八位的数据。当然，输出倒是仍旧可以同时读取。

作用：

可以用来节省数据传输占用的数据线，从八位并行变成了一位串行。

<img src="../计算机基础/images/image-20221109190438024.png" alt="image-20221109190438024" style="zoom:50%;" />

再比如实现串行到并行的数据转化：

<img src="../计算机基础/images/image-20221109190548310.png" alt="image-20221109190548310" style="zoom:50%;" />

还有移位其实是计算机底层中一种非常重要的操作。比如用补码加法和移位操作来实现乘除的算法。

在接触触发器之前，我们接触的电路结构都有一个特点，输入数据后输出就被输入确定下来。输出只和当前的输入有关，比如八三编码器，三八译码器、加法器等。

但是从触发器之后，因为电路开始具有记忆，我们的输出就开始和之前的输入变得息息相关了。比如我们刚才所说的移位寄存器，后面的触发器的输出取决于前几次的输入。因为电路能够记住之前的事情。在此之前的逻辑电路都是通过拼拼凑凑组合起来，称之为**组合逻辑电路**。而在此之后，我们的逻辑电路因为具有记忆功能，就开始在脉冲信号的驱动下，开始一步一步的变化，每一步的输出都和之前的输入息息相关。这种按照脉冲时间序列动作的电路，我们称之为**时序逻辑电路**。时序逻辑电路其实很简单，就是在组合逻辑电路的基础上，插入了具有记忆功能的存储电，这样每次输出就被存储下来。下一次输入的时候和输入数据一起发挥作用。



## 存储器

关于存储，不同的场景有不同的命名。

- ROM和RAM
- 内存和硬盘（电脑）
- 运行内存和存储空间（手机）



本质是两种存储方式：**易失性存储器和非易失性存储器**。

易失性存储器断电后就无法存储数据。

非易失性存储器断电后数据人就可以保存。

 

### 非易失性存储器

主要分类：

- 磁：机械硬盘，一张磁片（磁片上有密密麻麻的磁化微粒，这些微粒有不同的磁性，N和S）和一个磁头（磁头上有一个电磁结构），点击带动磁片高速旋转。磁头上通过控制线圈的电流走向产生不同方向上的磁场，利用磁化效应改变微粒的磁性，这样主机就能通过传输二进制电信号把信息写入磁盘的微粒中。磁头上还有一个磁性探头，将各个微粒的磁性转换为二进制电信号，实现数据的读取。
  
  ![image-20230121162210226](..\计算机基础\images\image-20230121162210226.png)
  
  ![image-20230121162230043](..\计算机基础\images\image-20230121162230043.png)
  
  
  
  - 水平式
  
    ![image-20230121181236847](..\计算机基础\images\image-20230121181236847.png)
  
  - 垂直式
  
    ![image-20230121181317297](..\计算机基础\images\image-20230121181317297.png)
  
  - 叠瓦式（性能差，依赖缓存空间），两个存储单元叠在一起，由于工艺的原因，写磁头不能像读探头一样可以做得很小，所以在一次随机的写数据过程中，磁头势必会影响旁边的存储微粒，微粒保证旁边微粒的存储数据不被影响，只能将他们临时放在缓存中，写完后再从缓存中恢复回来。本来只想改变一个微粒中的数据，却一次性动了一片磁盘的扇区（磁道上有不同扇区），速度自然慢。
  
    ![image-20230121181404801](..\计算机基础\images\image-20230121181404801.png)
  
    ![image-20230121181717975](..\计算机基础\images\image-20230121181717975.png)

![image-20230121182118208](..\计算机基础\images\image-20230121182118208.png)



![image-20230121182257007](..\计算机基础\images\image-20230121182257007.png)

由于叠瓦式在写数据的时候非常依赖缓存实现数据的搬迁和恢复，所以缓存一般都比较大，比如上图中256M的缓存看上去很好，但是很可能说明该硬盘是叠瓦式的。



- 光：光盘，利用光在不同材料上的反射能力不一样实现存储的。

  

- 电：固态硬盘
  磁和光，在断电后数据仍旧可以继续长久保存。电的话，一般断电后将很难继续保存数据。



通过电存储的存储器：

早期，为了永久性的存储数据，设计了只读不写的存储器，这样在断电的情况下也能永久存储数据。依靠的就是半导体场效应管。

![image-20230121231326446](..\计算机基础\images\image-20230121231326446.png)



利用mos管的开关特性就可以制作一个存储单元。

![image-20230121225525190](..\计算机基础\images\image-20230121225525190.png)



![image-20230121225542732](..\计算机基础\images\image-20230121225542732.png)



#### 掩膜ROM

只读不写。

<img src="../计算机基础/images/image-20221113122808904.png" alt="image-20221113122808904" style="zoom: 50%;" />



<img src="../计算机基础/images/image-20221113122900924.png" alt="image-20221113122900924" style="zoom: 50%;" />

选择在对应的W线上通上高电平信号，产生不同的数据输出。

控制每一位上的mos管的有无来存储数据，每一位上的mos管的有无由用户向生产厂商提交设计电路后由厂商生产。生产商在生产这种存储器的时候，需要用到用户定制的数据模板，称之为掩模版（掩膜ROM）。生产后电路结构就写死了，无法改变，就不能编程了。

掩膜ROM虽然简单，但是很麻烦，新的产品需要找厂商重新定制。（游戏卡）



#### PROM

可编程ROM，在电路和COM管之间上加一个低熔点的合金丝，通过加高电压就可以烧掉合金丝，从而等价于去掉对应位置的COM管，从而实现一定程度的可编程。



![image-20230121232055194](..\计算机基础\images\image-20230121232055194.png)



![image-20230121232241407](..\计算机基础\images\image-20230121232241407.png)



厂商生产出这种布满合金丝的存储器 ，再提供给用户一个针对ROM的编程器，用户就可以按照自己的需求写入数据。

 

#### EPROM

可擦除可编程ROM（Erasable Programmable Read Only Memory）

<img src="../计算机基础/images/image-20221113123957448.png" alt="image-20221113123957448" style="zoom: 50%;" />



<img src="../计算机基础/images/image-20221113124530211.png" alt="image-20221113124530211" style="zoom: 50%;" />

通过在浮置栅注入电子来控制这个MOS管的通电或者断电，从而实现存储数据的能力。浮置栅注入电子后，即使控制栅加高电压也不能导通电路，等价于没有MOS管，反之，则是有MOS管。

EPROM是采用热电子注入技术向浮置栅注入电子，而擦出浮置栅上的电子，则用紫外线或者X射线照射MOS管的二氧化硅层，产生电子空穴对，实现电子放电。 



#### EEPROM

EEPROM是使用量子遂川效应发明的功耗更低，时间更快的电子注入和擦除技术的可擦除可编程ROM

EEPROM仍然需要单独的编程器进行编程。



#### Flash（闪存）

闪存结构将写入和擦除所需要的高电压通过升压和降压控制电路统一集成到闪存芯片中，不在需要借助单独的编程器。因此可以边工作边进行读和写。

固态硬盘，SD卡，优盘等的底层结构都是闪存，这些不同电子产品只是对闪存的不同的使用方式。



为了能在单位面积上，增加能够存储的数据的密度，降低成本，在闪存结构上又有不同设计（闪存颗粒）：

- SLC：Single level cell
  浮置栅上只有两种状态，有电子和没有电子，从能表示两种状态，存储1bit 的信息
- MLC：Multi level cell
  浮置栅上电子的状态分为4种，满电子，2/3，1/3， 无电子，通过这四种状态，能存储2bit 的信息，通过测量管子的四种不同的开启电压的状态，再经过转换就可以得到四个数据。
  <img src="../计算机基础/images/image-20221113130608229.png" alt="image-20221113130608229" style="zoom:33%;" />
- TLC：Triple level cell
  原理和MLC一样
- QLC：Quad level cell
  原理和MLC一样 

但是受到制作工艺和控制难度的约束，目前就止步于QLC，再往下就容易出问题，浮置栅上的电子状态越多，对注入的电子的精度要求就越高，耗时就越长。而读取数据的时候，需要尝试更多的开启电压值，也降低了读取速度。

![image-20230122114329082](..\计算机基础\images\image-20230122114329082.png)

闪存只是用来存储数据的电路结构，其上面的数据最后还是需要交给主机使用，闪存和主机之间并不直接交互，而是通过闪存的**主控电路**来链接。

前面说到的不同产品的底层结构都是闪存，但他们之所以不同，主要是因为他们的主控电路和闪存的使用方式上的不同。



<img src="../计算机基础/images/image-20221113131519328.png" alt="image-20221113131519328" style="zoom:50%;" />



固态硬盘就是闪存结构加主控电路的结合。主控电路的设计门槛高，目前只有为数不多的几家厂商可以设计生产，如下图：

<img src="../计算机基础/images/image-20221113131348657.png" alt="image-20221113131348657" style="zoom:33%;" />

#### 主控电路

功能：

1. **管理闪存**

   - 地址映射管理，在使用闪存时，一般不直接使用闪存的物理地址，而是使用一个虚拟的逻辑地址，所以需要维护一个逻辑和物理地址的映射表。

     ![image-20230121234317827](..\计算机基础\images\image-20230121234317827.png)

   - 垃圾回收（GC）
     SSD越用越慢，这是因为SSD在使用的过程中，会产生垃圾块，对于一个新的SSD来说不是问题，因为还有很多未使用的空间可以存储新的数据，但随着使用时间的增长，可使用的空间越来越少，当写入时空间不够，SSD就必须将垃圾块回收再利用，什么时候回收，回收的策略，这都是SSD的主控电路的GC模块需要考虑的。

   - 磨损平衡
     SSD在使用的过程中，可能会出现有的存储块经常被使用，而有的几乎没有被使用过，主控电路就不得不平衡这种读写频率上的差异，因为闪存的读写是有寿命的，因为向浮置栅上反复的充放电会对二氧化硅层造成不可逆的损耗， 浮置栅上的电子会越来越容易外逃，闪存保存数据的时间也会越来越短，如果不同存储块的使用频率差距过大就会导致那些经常使用的存储块迅速老化。平衡闪存块的磨损也是主控电路的任务，比如把经常使用到的热数据放到之前使用频率较低的存储块中的动态平衡算法，和将使用频率低的数据放到之前使用频率很高的存储块中的静态平衡算法。

   - 掉电恢复
     当SSD异常断电时，如何保护好数据不丢失，比如加一个大电容应急，采用什么样的算法在下次通电时重现数据等。

   - 坏快管理
     闪存中会出现坏块，来源有：1. 增长坏块，不断使用后产生的坏块；2. 出厂坏块，和闪存的制作工艺有关。所以闪存的坏块难以避免，所以在使用SSD时，主控电路需要处理好和坏块的关系，比如鉴别出坏块，遇到坏块是直接忽略还是使用好的存储块来代替。
     - 原厂
     - 白片
     - 黑片

   - Cache

   - 数据维护

   - 防止bit翻转

     

计算机中的其他设备要和CPU通过总线进行通信，需要循序数据沟通的流程规范。


2. **控制闪存和主机的数据流转**

   控制数据从主机写入闪存和从闪存读取数据送入主机的过程。

   - SATA总线接口规范（Serial ATA）：串行ATA。

     01年，由Intel、APT、Dell、IBM、希捷、迈拓这几大厂商设计了一套数据沟通的“流程规范”，SATA总线接口规范。

     ![image-20230122123910808](..\计算机基础\images\image-20230122123910808.png)

     之前还有一个叫PATA，并行ATA，Parallel ATA。同样属于ATA规范，SATA比PATA更加先进，数据并行传输不是比串行的要更快吗？比如两个模块之间传输8bit的数据，在并行模式下一次就可以完成，在串行模式下，需要分8次传输。

     从这种角度看待串行和并行的传输速度只在第一层，更深层次的原理是这样的：在过去，设备工作频率不高的时候，也就是驱动时序电路工作的时钟频率比较低，串行确实不如并行传输的多路开工。但是随着这些年设备的工作频率不断上升，并行信号的同步问题变成了影响速度的瓶颈。

     8bit的并行数据并不能同时达到，这种差异时间一旦超过了时钟信号的周期时间，时钟信号需要等待它们都准备好了才能驱动输出。不同步的原因有很多，甚至布线的长短都会影响这个时间，还有并行数据在高速下的相互干扰，这样就增加了控制的难度，并行的优势在主频的不断提速下反倒变成了劣势。

     而串行的方式由于控制简单，没有信号的相互干扰，这些年逐渐成为各种传输协议的主流，全面压倒并行方式，包括接下来会讲到的PCIE，NVME，以及手机的UFS都采用串行化技术。

     计算机数据传递流程也被划分成为不同的层级。SATA规范中规定了4个层级：
   
     1. 应用层
     2. 传输层/事务层
     3. 数据链路层
     4. 物理层

     SATA总线接口规范中两个设备数据通信的过程就像数据包在网路中的传输过程。SATA的物理层有一个特点，数据接收和发送虽然有独立的通道，但一次却只能干一个活，发送数据的时候不能接受数据，而接受的时候则不能发送数据，这种模式也称之为半双工，SATA的这个特性则为现在的逐渐没落埋下了一个伏笔。SATA规范中只有一条数据通道（发送和接受算一个），SATA的应用层使用的是AHCI协议，严重限制了数据传输的效率等。

     在机械硬盘时代，SATA规范还是很优秀的，因为速度瓶颈不在传输上而在存储介质（HDD）本身的速度。SATA3.0中极限速度可以达到600MB/s，这是很多机械硬盘达不到的速度，所以在机械硬盘的时代，SATA完全够用。

     但是随着SSD高速发展，存储介质（闪存）本身的速度已经不是瓶颈，现在市面上的SSD动辄好几个G每秒的读写速度早就超越了SATA的传输极限。

     

   - PCIE总线接口规范

     ![image-20230122124746045](..\计算机基础\images\image-20230122124746045.png)

     PCIE和SATA一样也是一种总线接口规范，完整的规定了设备中数据传输的流程，PCIE也分为和SATA类似的四层。在物理层，PCIE相对于SATA有了很大和改善。首先它也是用更加先进的串行通信，可以看出串行技术取代并行是大的趋势。

     SATA只能半双工，PCIE可以让发送和接受数据同时工作互不干扰，也就是全双工，再次提升了速度。

     PCIE支持多个通道，比如单通道，2通道，4通道，8通道，16通道以及最多能够达到的32通道。我们电脑主板上就有PCIEx1，PCIEx4，PCIEx16等等不同通道的PCIE插槽。
   
     ![image-20230123092220704](..\计算机基础\images\image-20230123092220704.png)
   
     相对于SATA而言，PCIE的传输速度得到了大幅度的提升。这是一张PCIE从1.0到3.0的速度表。相比于SATA3.0的600MB/S的极限值，PCIE简直快到飞起。
   
     
   
     PCIE其实只规定了4层协议的下三层，虽然速度相对于SATA已然让飞升，然而应用层协议，却并没有在PCIE规范中。
   
     一开始走PCIE接口的应用层协议借用的是SATA中常用的AHCI，这是一个很古老的的应用层协议，简单来说这个它很不现代化，极大的约束了数据传递的速度。（自行车上高速）
   
     ![image-20230123092612822](..\计算机基础\images\image-20230123092612822.png)
   
     
   
     所以虽然PCIE很快，但是如果使用AHCI作为应用层协议，并不会比SATA快出天际。于是在2011年几大巨头企业（又有因特尔这个规范狂人）专门针对SSD制定了新的应用层协议标准——NVME。
   
     相对于AHCI而言，NVME将PCIE的全部能力释放了出来，推出之初就将PCIE规范作原配协议，这就是目前SSD接口规范中的黄金搭档。（法拉利跑高速）
   
     ![image-20230123092557398](..\计算机基础\images\image-20230123092557398.png)
   
     
   
     ![image-20230123092720154](..\计算机基础\images\image-20230123092720154.png)
   
     **SATA和PCIE属于总线接口规范，规定的是计算机内数据传输的规则（可以简单理解为和CPU通信的的规范），这个数据传递可以是任何设备，只要这个设备支持SATA或者PCIE，就可以通过这些接口总线和CPU通信数据。**
   
     
   
   - AHCI协议
   
   - NVME协议
   
     虽然原理上被分层的协议直接可以被随意组合，但是我从没有见过NVME配合SATA的下三层协议的产品出现，这是一种让法拉利跑越野的感觉。
   
     但是我见过短暂出现的三星的SM951固态硬盘，它有AHCI+PCIE的版本，这是一种自行车上高速的行为。
   
     和AHCI相比，NVME的命令集合更加的精简，因为它就是为SSD而推出的，可以完全抛弃HDD（机械硬盘）需要的命令，而寄生在HDD时代产生的AHCI+SATA下的SSD则需要照顾很多用不着的命令。
   
     **NVME还有一个甩AHCI几条大街的特性，那就是任务队列的数量和深度。**
   
     
   
     NVME属于应用层协议，直接处理设备（这里就是我们的SSD）和主机之间的通信流程，主控电路中NVME的控制单元负责这件事情。NVME协议中需要用到一个任务队列（Submission Queue），主机向SSD发送命令的时候，并不直接执行而是先打入这个队列中。
   
     ![image-20230123095706861](..\计算机基础\images\image-20230123095706861.png)
   
     这时候通过向NVME控制单元的一个叫DoorBell的寄存器写入数据来通知SSD有新任务，DoorBell的意思就是门铃，好比我们在餐厅点菜，写好后按一下铃铛让厨师去做一样。
   
     SSD在收到通知后去取出SQ中的命令，执行完毕后把结果在写入一个完成队列（Completion Queue）中，并通知主机者过来取结果。这种异步队列模式，使得SSD的工作变得高效。
   
     NVME协议中这个队列最多可以放65536个任务，也就是队列深度可达65536，而队列本身的数量最多也可以达到65535个，所以NVME的队列最多可以容纳65535*65536=4294901760个任务，这是一个很大的数量。
   
     ![image-20230123095832581](..\计算机基础\images\image-20230123095832581.png)
   
     反观AHCI协议，只有可怜的1个队列，而且这个队列的深度最多只有32个。
   
     NVME的全称——Non-Volatile Memory Express，`非易失性存储器规范`，取这么大的一个名字足以看出NVME要一统非易失性存储器的野心。
   
     现在的电脑主板上不仅有SATA的插槽用来安装SATA规范的SSD，也可以在各种通道的PCIE插槽上装PCIE规范的SSD，还有一种兼容性极高的M.2插槽，同时兼容SATA和PCIE接口规范。
   
     ![image-20230123100014587](..\计算机基础\images\image-20230123100014587.png)





**手机上的闪存技术**

手机中目前主要使用的两种存储器的规范，`eMMC和UFS`。

基于eMMC和UFS的存储器可以看成是手机设备上的SSD，但是针对移动设备做了优化，包括功耗和尺寸等方面。eMMC和UFS闪存的主控芯片也完整的包含了闪存管理和通信协议两大基本功能。

和电脑中的SATA，PCIE总线接口规范很类似，eMMC正在被淘汰，由UFS逐渐代替。UFS要比eMMC快很多，这和它们的实现方式有关。

- eMMC是半双工，而UFS是全双工。
- UFS的协议层和NVME一样支持多任务队列，而eMMC不支持
- eMMC是并行传输，UFS采用的是更加先进的串行传输。再一次证明了串行化的趋势。
- 串行传输的UFS和PCIE一样还支持多通道。而且和SATA，PCIE的串行技术一样使用差分信号来提高速度和抗干扰性。

总之UFS在性能和速度上都要比eMMC好，这是eMMC和UFS的读写速度的对比。

![image-20230123100402920](..\计算机基础\images\image-20230123100402920.png)

这几年手机也渐渐的从eMMC闪存向UFS过度。



### RAM

ROM的R是Read，Read Only Memory，`只读存储器`。ROM进入电存储的Flash时代后，Read Only 的意义就已经消失了，可以认为他也是一个支持随机访问和写入的存储器，和RAM类似。

RAM的R是Random，Radom Access Memory，`随机访问存储器`。

目前RAM和ROM单从能实现的功能上来看，区别已经不大，差异主要体现在电路结构和工作特点上：相对于ROM，**RAM要更迅速。** **RAM断电后无法保持数据。**



##### 锁存结构的RAM

RAM的电路设计，基于锁存器。

![image-20230123103141166](..\计算机基础\images\image-20230123103141166.png)



精简的4个mos管的锁存结构：

![image-20230123103242403](..\计算机基础\images\image-20230123103242403.png)

这就是一个可以保存一位数据的电路单元。锁存器动作要比Flash通过浮置栅充放电子实现数据存储要快很多。

同样，锁存器在系统断电后数据丢失，所以很适合用来做内存单元。

当我们搭建出许多个这样的单元就构建出一个存储阵列

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZoonWpyJnmX1ZqFJwXluwyudMQRiciaUXyw86Rh0AibxMq1iarh1pyXpQEx8A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



##### 选择特定的数据单元

使用行和列选中一个存储单元。

**选择行**

首先来改造一下这个存储结构：

![image-20230123103503704](..\计算机基础\images\image-20230123103503704.png)

在锁存结构的输入和输出两侧各加一个MOS管做开关控制，所以我们在这一根线上通上高电平也就让锁存结构导通，存储单元进入工作状态，反过来在这一根通上低电平，这个存储单元的输入输出被封闭。

在阵列里，我们就可以让某一行存储单元的X线为高电平从而被选中。

![image-20230123103723030](..\计算机基础\images\image-20230123103723030.png)



**选择列**

同样利用MOS管的开关控制作用，再加两个MOS管：

![image-20230123103809448](..\计算机基础\images\image-20230123103809448.png)



Y线通高电平时存储单元的输入和输出被导通，反之被封闭，通过X和Y这两根线的配合就可以在一大片存储阵列中选出一个存储单元。



**控制读或写**

RAM的初衷在于可以自由的读和写，那么如何控制这个存储单元到底是读还是写？

添加一个读写控制电路：

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZoosVbOTdEL3oxcg8thJ0BrMHHoobJ6Keic5Dq66zwibLicT8uosQT7DY2tg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

为了简化理解，不分析读写控制器内部的电路细节，封装起来，只需要知道当R/W’这个端口等于1的时候，最下面的线和右边的读取通路导通，此时处于读取模式，数据从锁存结构通过这根线向外流出。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZooMHvjlT9DQUZiatcaibS3tgXSjRZibHev38L0tAbXz5BEC3TiajiaXzicL3nw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



反过来如果R/W’这个端口等于0，这根线和左边的写入通路导通，此时处于写入模式，数据通过最下面的线从外部流入锁存结构。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZooZHqJgPIlFG3O399JccQrNdIlf37ZEYZaOGODHjsENbiaVcV35kEreLA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

最下面的线因为同时支持读和写，所以称之为I/O线（Input，Output）



当然，这个控制器除了控制读和写以外，为了方便扩展，一般还有一个CS’控制全局，CS’=0时正常工作，CS’=1时全局封死这个单元。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZoonHd3YUAjJYj1QrsHYJZewZk1yHwJBoAs7sUN9nffKrDlAKP6hpubQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)





![image-20230123104737328](..\计算机基础\images\image-20230123104737328.png)



事实上，人们确实用这种结构制造内存，锁存器很快，功耗也很低，但是这种结构也有明显的缺点。

如果你仔细观察这个存储单元电路图，就会发现它太复杂了，用到的晶体管太多了！这对于大规模的集成电路工艺来说就很不友好，集成度上不去，单位面积上的容量就上不去，目前电脑手机里动辄好几个G的内存用这种结构难以实现。

**所以这种结构的RAM一般只用在对性能要求比较高的缓存场景中**，而内存的方案中的RAM则靠的是另外一种结构。



##### 电容结构的RAM

通过向电容中充入电荷和释放电荷产生不同的电位值实现数据的存储，当然这种充放电的过程和电擦除ROM中利用热电荷和量子隧穿进行充放电完全不一样，电荷是直接进入和释放，速度非常快。

![image-20230123112318140](..\计算机基础\images\image-20230123112318140.png)

为了在充电后，电荷不会流失，我们加一个MOS管作为开关，当X线为高电平的时候导通，电容根据B线的电平充电或者放电。

X线变为低电平的时候MOS管截止，电容被封锁，数据就保存在了电容中。这是写入的过程。

读取的时候，让X线通高电平，MOS管打开，这时候B线上的电位也就是电容的电位，一般再加一个电容用来承接电荷，B线就可以读出我们的数据。

![image-20230123112720610](..\计算机基础\images\image-20230123112720610.png)

这就是一个存储单元的全部结构，唯两个电容，一个MOS管，相当简洁，很适合用来做大容量高集成的存储产品！

电容在读取的时候电荷向外流动，数据会被破坏。所以在这种存储结构中在读取后需要额外的去恢复这个电容的电量。

同时因为MOS管有漏电流的存在，所以在截至的时候并不能完全封锁电容，电荷会慢慢的从电容中通过MOS管向外渗漏，所以随着时间的增长，电容里的电荷越来越少，最后导致数据丢失。所以我们需要定期向这个电容中补充电荷，称之为刷新再生。

还有一个问题，由于存储电容容量很小，读取时信号很微弱，所以需要一个能够放大信号的灵敏放大器。

所以对比SSD，RAM产品也有自己的类似于主控的外围电路。

![image-20230123112845393](..\计算机基础\images\image-20230123112845393.png)

而上述的各种问题其实都指明了一个问题，用电容工艺制造的RAM需要更加复杂外围电路配合，处理像电荷刷新，恢复，信号放大这样的工作。

和用锁存结构制造的存储器的控制电路相比，虽然电容结构的控制电路要复杂很多，但是这种复杂是值得的，因为主体部分的存储单元的结构已经很简单了。

对比两种存储结构，后者因为需要不断动态刷新和恢复数据，我们一般称之为动态RAM（DRAM），而前者对应称之为静态RAM（SRAM）。

目前计算机内存从性价比和集成度，容量等角度考虑，使用的都是DRAM结构。这就是RAM存储器的电气原理，



##### DDR

实际上不论是SRAM还是DRAM，他们的工作流程都很类似。

一块内存阵列，想要操作一个存储单元，首先选择一行，然后选择一列，最后读数据或者写数据，当然内存在操作数据的时候还需要很多复杂的工作流程，这里为了简化理解我们只取出这三个过程来讲解。

根据前面学过的时序逻辑电路我们知道，每个动作都发生在脉冲信号的边沿。所以读取一个数据需要经历两个步骤：行选脉冲信号上升沿驱动选行动作=>列选信号上升沿驱动选列动作，数据输出。

根据前面学过的时序逻辑电路我们知道，每个动作都发生在脉冲信号的边沿。所以读取一个数据需要经历两个步骤：行选脉冲信号上升沿驱动选行动作=>列选信号上升沿驱动选列动作，数据输出。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZoouKtBibKpzjgMYolWZydico6zVWD5F1LBjhoJeVBl0t0utLDICTTE768Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



而写入一个数据需要经历三个步骤：行选脉冲信号上升沿驱动选行动作=>列选信号上升沿驱动选列动作=>数据写入脉冲信号上升沿驱动数据写入动作。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZoofWy5ABHawRc9lMFCUNRvuxqWSxpic37z455J6MREDUol1hOWNc0pMBw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

上个世纪，人们驱动存储电路时采用的脉冲信号是异步的，也就是说控制器按照自己方式产生脉冲信号控制着数据读写的流程，和CPU的时钟无关。不论是原始的SDRAM还是改进版的FPM，EDO，BEDO方案，都是如此。

这是一种适应性很差的方案，当CPU频率改变的时候内存不会主动适应。所以人们采用了同步脉冲的方案。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9Zoo3l3Z3zqbIC006hmoBgULlHCIKaTu5IElMby7aVJEjhfzicbIwNaic5pw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在控制器中加入了处理器的同步时钟信号，用这个时钟信号控制着存储结构的动作。这样所有的动作都在统一同步时钟信号的控制下执行。如果处理器的频率变快了，这个过程将会自动适应新的频率。

在异步脉冲下工作的DRAM我们称之为ADRAM，现在已经很少见了。而在同步时钟信号下工作的DRAM我们称之为SDRAM，是目前的主流方案。

而在SDRAM的基础上人们又提出了双倍数据率的改进方案，之前只在脉冲的上升沿动作，而现在让上升沿和下降沿处都可以动作，这样SDRAM的方案的速度就提升了1倍。

![图片](https://mmbiz.qpic.cn/mmbiz_png/qwJKzuygHiaGpXDFCyprInK2RhzCQ9ZoorcPs0ZshL4XfhnvlMiaTlaWvYEBEiapiajfb0rc83Xdd4zbCW1u92wibKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

双倍数据率，也就是Double Data Rate，简称DDR，所以DDR的全称是：

「Double Data Rate Synchronous Dynamic RAM（DDR SDRAM）」

而通过对DDR方案的不断改进出现了DDR2，DDR3，DDR4等等，速度依次翻倍。DDR也逐渐成为内存驱动方案中的事实标准，计算机主板中安装内存条的插槽由于使用的是DDR方案，所以一般称之为DDR插槽。

![image-20230123154228500](..\计算机基础\images\image-20230123154228500.png)





## 设计一台计算机

如何学习计算机科学？从最初计算机科学，最底层的角度去逐步学习。

设计出一台可以编程的计算机，围绕完成贪吃蛇所涉及的要素来实现计算机架构设计。产生一个类型MIPS指令集的一个指令子集，它包含一些核心的基本操作。



贪吃蛇游戏分析：

![image-20230124101240180](..\计算机基础\images\image-20230124101240180.png)

计算机应该所具备的基本功能：

![image-20230124101509130](..\计算机基础\images\image-20230124101509130.png)





### 冯诺依曼结构和哈佛结构

计算机主要部分：

- CPU
- 主板
- 硬盘
- 内存
- ...



**在冯诺依曼体系结构中**，程序和数据的情况：程序存储在硬盘中，要执行程序时，计算机会将硬盘中的程序指令读取到内存中，然后交给CPU去执行程序，执行过程中产生的数据是由CPU回写到内存中，其中程序的指令和程序执行过程中产生的数据都一起存放在内存中。程序和数据在CPU和内存之间共用一套地址和IO线路，硬盘只是程序的一个非易失性存储备份。

这种体系结构由于不区分数据和程序，所以动态性能很强，十分灵活，但缺点是数据和程序交织在一起，管理起来十分麻烦且容易出错。



**在哈佛体系结构中**，程序和程序产生的数据应该时分开的存放在不同的存储器中，由于程序只能读不能写，所以一般存放在ROM存储器中，而程序运行时产生的数据可以随时读写，所以存放在RAM存储器中。程序所在的ROM、数据所在的RAM和CPU之间分别走不同的数据线路。

哈佛结构实现方式简单，虽然在计算机领域并没有普及，但是在嵌入式系统中应用广泛，比如单片机，微控制器等。

**本次设计的计算机是基于哈佛体系结构的。**



贪吃蛇在哈佛体系结构的计算机中的运行：CPU从ROM中取出一条指令，创建蛇（假设只有一个蛇头），创建一条蛇的过程就是将指令执行后产生的蛇头坐标数据存入RAM中。 CPU继续从ROM中取出下一条指令，执行移动蛇的操作，比如蛇向右移动，则CPU取出RAM中蛇头的X坐标值进行加1（在CPU中进行），然后再回写到RAM中最新的蛇头的X坐标值，覆盖原来的坐标值。

![image-20230125095429753](..\计算机基础\images\image-20230125095429753.png)

![image-20230125095450040](..\计算机基础\images\image-20230125095450040.png)





### 存储器

#### ROM

一个256字节的存储器，有编号0~255个一字节存储空间，存储器对外提供两部分线路，一个叫地址线，一个叫数据线，如果存储器中的数据是8位，那数据线就是8根。如果存储器的存储空间有256个字节，那么选中这256个存储空间中的某一个存储空间地址就需要8位二进制数（2^8=256），也就是地址线需要8根。如果存储器的容量是512个字节，那么地址线就需要9根。

如果想获取指定地址内的存储指令或者数据只需要将地址线设为能选中该地址的值即可（寻址），数据线就能将对应地址上的数据输出。

![image-20230124103237483](..\计算机基础\images\image-20230124103237483.png)



#### RAM

RAM除了读取数据外，还能随机写入数据，所以RAM还有一个**读写控制线**。同样的地址线输入，**如果在读写控制线输入为低电平0的时候，那么就是进行读取操作**，RAM的数据线中会输出选中地址上的数据。

![image-20230124103712370](..\计算机基础\images\image-20230124103712370.png)

**如果读写控制线为高电平1，那么此时RAM就是进行写入操作**，RAM单独有一根写数据线，写的时候不太一样，就像数字电路部分说的，任何具有记忆功能的时序逻辑电路，在写入的时候都需要一个脉冲信号来驱动，所以RAM还有一个边沿触发的脉冲线。

![image-20230124104115697](..\计算机基础\images\image-20230124104115697.png)



![image-20230124104209525](..\计算机基础\images\image-20230124104209525.png)



![image-20230124104232750](..\计算机基础\images\image-20230124104232750.png)





### 寄存器组

![image-20230124111321853](..\计算机基础\images\image-20230124111321853.png)

虽然有ROM和RAM用来存储程序和数据，但是在处理数据和程序的时候，CPU也有一组临时存放数据和指令的地方——寄存器组。

CPU的一切操作都是围绕寄存器组来实现的，本次课程设计的计算机的CPU中只有8个寄存器，分别是从r0到r7，因为寄存虽然快速，但是耗电量高，集成度相对于电容结构的DRAM也上不去。本次课程设计的是一个8位的计算机，所以CPU中的寄存器也是8位，一个寄存器可以存放一字节的数据。

ROM，RAM，寄存器组的电气结构：

ROM：通过擦写浮置栅MOS管实现存储。

RAM：通过电容加外围电路实现。

寄存器组：使用MOS管的锁存结构实现。

![image-20230124112344657](..\计算机基础\images\image-20230124112344657.png)



按照现代计算的设计，数据送入CPU处理时，数据需要线进入CPU中的寄存器组中的寄存器中，而CPU处理完后的数据也需要先存放到寄存器组中的寄存器中，再放入内存中。

作为同样可以随意读写的存储结构，寄存器组可以看作是RAM的一个镜像。但是更快，容量更小，所以寄存器组的外部线路和RAM的外部线路基本类似。

![image-20230124112743795](..\计算机基础\images\image-20230124112743795.png)



寄存器组的内部结构：

参考MIPS指令集，读地址和写地址线虽然有5位二进制数，但这里只需要使用低三位就可以。

![image-20230125142719674](..\计算机基础\images\image-20230125142719674.png)



贪吃蛇数据变化分析：

1. 创建一条蛇（在内存中写入蛇的像素坐标数据）
2. CPU根据移动方向，改变蛇的坐标值，把更新后的坐标值写回内存中覆盖原先的值
3. 重复上述动作，持续移动蛇的位置



将数据写入RAM：

1. CPU给RAM的地址线通上内存地址值（如：00000001），数据线通上蛇头所在的X坐标（比如：4），读写控制线通上高电平1，RAM此时为写模式
2. 准备好上述情况后，等待一个脉冲信号边沿到来，触发数据的写入到指定位置

![image-20230124114445661](..\计算机基础\images\image-20230124114445661.png)

![image-20230124114515961](..\计算机基础\images\image-20230124114515961.png)



3. 向RAM的2号位置写入蛇头的Y坐标值，也是类似过程。

![image-20230124114633380](..\计算机基础\images\image-20230124114633380.png)



假设蛇头向右移动，则是先将蛇头X的坐标是从ARM中读取到CPU中，在CPU中加一后，最后再写会RAM中：

1. CPU给RAM的地址线通上蛇头X左边所在的地址位置数据（00000001）

2. 读写控制线输入低电平0，此时RAM为读取状态，这样就读取出了蛇头所在的X坐标是数据

   ![image-20230124115015095](..\计算机基础\images\image-20230124115015095.png)

3. 此时RAM读取出的数据送入CPU中的寄存器组中的寄存器中

**时刻牢记，按照现在计算机的设计理念，CPU和RAM交互时，必须都先以CPU中的寄存器组作为中转站，从RAM中读取的数据先放入寄存器组，然后再交给CPU进行运算。而运算的后的结果也需要先交给寄存器组，然后再写入到RAM中。**

![image-20230124115511739](..\计算机基础\images\image-20230124115511739.png)

4. 此时CPU中的寄存器组的地址线上数据为000，选中寄存器组中的第一个寄存器（r0），寄存器组的读写控制线为1，寄存器组此时为写入状态，等待一个脉冲信号的边沿到来，RAM中的数据4写入寄存器中的第一个寄存器r0。
5. **通过上面的4个说明就完成了数据从RAM到CPU中数据的加载数据的操作**





### 运算器

前面，蛇头的数据（X坐标）已经从RAM中加载到CPU中的寄存器中，接下来就是进行数据加1的操作。这时就需要CPU中**运算器**的加入。

运算器用来做加减乘除、逻辑、移位运算这些最小颗粒度的基本运算。

进行这些运算都涉及两个操作数的输入和一个数的输出。

![image-20230124120627804](..\计算机基础\images\image-20230124120627804.png)



算数单元：加法和减法（取补码转为加法）

![image-20230125110805014](..\计算机基础\images\image-20230125110805014.png)

逻辑单元：

![image-20230125110929832](..\计算机基础\images\image-20230125110929832.png)

可以看到下图，这个运算器单元有两个8位二进制数作为输入，一个8位二进制数作为输出。3位二进制数分别控制三个多路选择器，选择最后输出的结果。

![image-20230125111017006](..\计算机基础\images\image-20230125111017006.png)

![image-20230125111244025](..\计算机基础\images\image-20230125111244025.png)



运算器因为支持多种运算，所以需要在多种运算方式中选中一种运算。

RAM中通过一位二进制数的两种状态，可以控制RAM进入不同的读写模式类似，运算器也有一个控制线，但是要支持加减乘除、逻辑、移位等不同运算，所以它的工作模式不止两种，这里使用4位的控制信号，也就是2^4，可以选则16中运算方式中的一种。 当运算器的控制信号在这里为0110时，选中加法运算，为0100的时候，选中减法模式。

**在数字电路中，这种思路非常常见，一个模块中有输入或者输出，如果对于输入有不同的输出方式，那就再通过控制线让他们产生不同的输出模式（多路输出中，选择一路进行输出）。**

![image-20230124170224076](..\计算机基础\images\image-20230124170224076.png)

运算器计算的结果不应该直接写入到存储器的00000001位置以完成对蛇头X坐标的更新。

<img src="..\计算机基础\images\image-20230124170538996.png" alt="image-20230124170538996"  />

运算器运算的结果也必须先写入CPU的寄存器组中，再由寄存器组写入RAM。

这里出现了第一个冲突，读取RAM的时候，RAM的输出已经接入寄存器组的输入，而运算器的结果也要接入，这时就要使用到数字电路中讲过的一个模块——**多路选择器**。它有多个输入一个输出，也有控制线路，通过控制线路上的不同数据选择输出哪一路输入，这里使用一个只需要一位二进制作为控制信号的两路选择器。

![image-20230124171437091](..\计算机基础\images\image-20230124171437091.png)

![image-20230124171501619](..\计算机基础\images\image-20230124171501619.png)



选择信号设置为0，则选择运算器而非RAM的输出作为寄存器组的输入，

![image-20230124171602446](..\计算机基础\images\image-20230124171602446.png)



选择信号设置为1，则选择RAM而非运算器的输出作为寄存器组的输入，

![image-20230124171729325](..\计算机基础\images\image-20230124171729325.png)



当运算器的结果写入寄存器组时，上图中的寄存器组的地址线输入值已经在读取ARM或者运算器运算结果时被确定占用。这时只能为寄存器组单独用一个写地址线，寄存器的读和写的地址数据线路分开。

![image-20230124182310679](..\计算机基础\images\image-20230124182310679.png)

读写完全分开后，读写控制线就不再需要了，改为写允许线。，为1时允许写，为0时不允许写，读则不受控制，这样寄存器组就可以同时读和写了。

![image-20230124182532585](..\计算机基础\images\image-20230124182532585.png)

基于上图这个设计，蛇头的x坐标在运算器中加1后，寄存器组的读地址线为000，选中r0，将r0寄存器上从RAM中读取的蛇头的X坐标值输出到运算器，同时寄存器组的写地址线为001，选中r1，寄存器组的写允许线通上1允许写。运算其中的两个输入进行运算，完成加1后输出，寄存器组等待一个脉冲信号边沿，运算器的输出被写入到寄存器组的r1中。

最后将r1寄存器中的值写入到RAM的00000001地址（蛇头坐标所在位置），覆盖原来的值。

![image-20230124183533462](..\计算机基础\images\image-20230124183533462.png)

把寄存器组的输出接入到RAM的输入，RAM的地址线上通上1，读写控制线也通上1，处于写模式，寄存器组的读地址线上通上001，选中r1并把寄存器组的写允许线设置为0，禁止写入数据到寄存器组（防止期间有数据进入寄存器组导致数据混乱）。这时r1中的数值5就输出到RAM的数据写入线路，等待一个脉冲边沿被写入到RAM的00000001位置处，步骤结束。

![image-20230124184953709](..\计算机基础\images\image-20230124184953709.png)



上面这些操作其实就对应一些语言中的一下代码

```c
int snakeHeadX = 4;
```

![image-20230124185305359](..\计算机基础\images\image-20230124185305359.png)



```c
int snakeHeadY = 4;
```

![image-20230124185343566](..\计算机基础\images\image-20230124185343566.png)



```c
snakeHeadX = snakeHeadX + 1
```

![image-20230125143528201](..\计算机基础\images\image-20230125143528201.png)



![image-20230125144155282](..\计算机基础\images\image-20230125144155282.png)



![image-20230125144607158](..\计算机基础\images\image-20230125144607158.png)





计算机各个组件中的通电情况总结：

1. ROM用于存储程序指令，如果存储器的空间是256个，那需要8个二进制数进行寻址操作，数据输出线输出的二进制数位数和每个存储空间中存储的二进制数位数对应。

   ![image-20230125100241329](..\计算机基础\images\image-20230125100241329.png)



2. **RAM中读写控制线输入低电平0，则RAM处于读模式；为1，则处于写模式，要写入数据的地址还是由地址线决定，但是要写入的数据则来自写数据线，然后配合一个脉冲信号线触发写动作。**

   ![image-20230125100905901](..\计算机基础\images\image-20230125100905901.png)

   

   ![image-20230125100750541](..\计算机基础\images\image-20230125100750541.png)



3. CPU寄存器组，本次课程的寄存器组中由8个寄存器组成（r0~r7），每个寄存器中能存一字节的数据。寄存器组也可以读写，结构和RAM类似。

   **写允许线通上1，表示允许写；通上0，则不允许写。**

   ![image-20230125105507072](..\计算机基础\images\image-20230125105507072.png)

   
   









4. 运算器，通过一个4位二进制数作为控制信号的输入，选中一中运算方式，**控制信号为0110时，选中加法运算；为0100时，选中减法运算。**

   ![image-20230125104902469](..\计算机基础\images\image-20230125104902469.png)

5. **多路选择器，选择信号为0，则选择运算器的输出结果；为1，则选择RAM输出结果**

   ![image-20230125105152388](..\计算机基础\images\image-20230125105152388.png)

   ![image-20230125105308349](..\计算机基础\images\image-20230125105308349.png)



### 指令集

地址线有寄存器组的读地址线和写地址线；RAM的写地址线

控制信号线有寄存器组的写允许控制线，RAM的读写控制信号线 和 选择RAM输出还是运算器输出的多路选择器控制信号线，运算器的4位二进制运算模式选择信号线。



![image-20230125162703785](..\计算机基础\images\image-20230125162703785.png)

将上面这些地址数据和控制信号数据汇集在一起，就形成了计算机指令。参考32位的MIPS指令集来设计本课程的指令结构，也就是每个指令的长度是32位二进制数组成。

![image-20230125175648502](..\计算机基础\images\image-20230125175648502.png)



CPU寄存器组读地址线路位于指令的 **21位到25位**，这5位可以选择32个寄存器所在地址，但本课程只有8个寄存器，所以只使用其中的最多3位即可。选择一个寄存器中的数据作为CPU运算器的第一个输入数据。把这5位所在的区域称之为——**源寄存器（register source），简称rs区**



寄存器组的写地址线路位于指令的 **16位到20位**，这5位可以选择32个寄存器所在地址，但本课程只有8个寄存器，所以只使用其中的最多3位即可。选择一个寄存器作为CPU运算器或者RAM的输出数据。把这5位所在的区域称之为——**目的寄存器（register target），简称rt区**



CPU运算器的控制信号由4位二进制数组成，在MIPS指令结构中的运算有更多的运算模式可以选，所以预留的是6位二进制数，而本课程中使用其中的低四位，位于指令的 **0位到5位**。把指令中这6位二进制数所在位置称为**运算器的功能funct 码区（OpCode）**



其中有一些只需要一位的控制信号，分别是**寄存器组的允许写控制线路**，  **多路选择器控制信号**，**RAM的读写控制信号**。在指令的 **26位到31位**，为这些独立的控制信号准备信号数据，这块区域称之为 **操作码区（OpCode）**



剩下的 **6位到15位**，这10位二进制数，他们作为运算器的第二个数据输入，称之为 **立即数**，直接给运算器的第二个输入提供数据。

![image-20230125194837430](..\计算机基础\images\image-20230125194837430.png)



上图中RAM的寻址（地址线）还没有确定数据来源，后面讲解。

包含立即数 **im**的指令，就是MIPS指令集中三大指令类型之一——**I型指令**  immediate

上面这种直接被CPU理解和执行的二进制数就是——**机器指令**



### 汇编

上一节讲的指令都是一些二进制数。但用他们编写程序过于复杂。为此科学家研发了汇编编译器和汇编语言，开发者使用汇编编写程序，交给汇编编译器翻译为机器语言，然后交给CPU执行。

例如：

```
addi r1, r0, 1
```

addi表示这是一个有立即数参与的加法。

r1表示加法运算结果要保存的位置。

r0表示运算器的第一个输入数据。

1表示运算器的第二个输入数据，是一个指令直接提供的立即数。

这种由简单字母组成的语言就叫——**汇编语言（汇编指令）**



**接下来，反向推演，设计一个计算机操作时，先设计汇编指令，再结合电路反推出二进制。**



#### 设计汇编指令

存数据（将数据存入RAM）的汇编指令：

```
sw 寄存器地址, RAM地址
```

![image-20230125200420065](..\计算机基础\images\image-20230125200420065.png)

假设蛇头初始位置是（4，4），一开始，寄存器组和RAM中都是没有数据的，而且RAM中的数据必须来自寄存器组中。这时，由于系统中没有初始数据，所以需要程序指令首先提供（运算器的第二个输入，**即立即数**）。

同时，寄存器中由8个寄存器，默认固定让r7存储0且不能被修改，只能被读取的特殊寄存器。

然后通过`addi r0, r7, 4`，向寄存器组中初始化一个数据4。

![image-20230125201113848](..\计算机基础\images\image-20230125201113848.png)

这其实就是给寄存器赋值的动作，配合一个永远存储0的特殊寄存器和立即数加法运算实现。

**这个寄存器赋值的操作本质上是一个立即数加法，但是为了更加直观理解它的功能，使用另一种汇编代码表示，movi r0, n 来代替 addi r0, r7, n**。

movi r0, n 在经过汇编编译器后，还是会转换为 addi r0, r7, n 形式。

**movi指令由于并不具有直接真实的意义，只是为了更加直观，所以也称之为——伪指令**



![image-20230125202140098](..\计算机基础\images\image-20230125202140098.png)



### RAM寻址

上节，已经通过movi指令将蛇头的X坐标4加载到寄存器组中的r0中，接下来就是将4再从寄存器组加载到RAM中的指定位置。

通过汇编指令`sw r0 1`实现r0寄存器数据加载到RAM的1号地址存储空间中。

**现在要确定RAM的地址数据从哪里来？**

`sw r0 1`中的 “1” 表示RAM的存储地址，但是不应该直接作为RAM的写地址线数据。

对于一个向RAM中指定地址写入寄存器组数据的指令，直接通过指令的立即数部分指定内存地址的值，这样并不合适。

![image-20230126103735716](..\计算机基础\images\image-20230126103735716.png)

假设由立即数给出内存地址，那么对于一个内存地址空间连续的数据，比如数组，依次向数组中的每一项所在地址写入来自寄存器组的数据，如下图所示：

![image-20230126134749683](..\计算机基础\images\image-20230126134749683.png)

每次操纵某个元素都需要先确定该元素所在的地址，但是实际上，寻址时是利用数据连续空间的首地址加上偏移量，而不是每次都需要计算元素所在的地址。



在MIPS指令结构中，关于内存寻址的方式：

1. 首先在一个寄存器组的寄存器中存入第一条指令所提供的某个RAM连续存储空间的首地址

2. 第二条指令，运算器的第二个输入是立即数（也就是连续空间的偏移量），运算器选中加法模式

3. 将运算器计算的首地址加上偏移量的输出传给RAM的写地址线，就实现了寻址

   对于单个变量可以看作长度是1的特殊数组，这样就将变量和数组的访问寻址问题解决。

![image-20230126140323131](..\计算机基础\images\image-20230126140323131.png)

上图中寄存器组的输出作为运算器的输入后，和第二个输入相加作为RAM的地址数据，并不应该再将该寄存器的输出作为RAM需要写入的数据。这时就需要更改寄存器组的输出线路，如下图：

![image-20230126143654016](..\计算机基础\images\image-20230126143654016.png)

第二个寄存器组的读地址线由指令中的rt区管，所以rt区有两种不同的作用，在写数据到寄存器组中的指令中，它表示被写入数据的寄存器地址。在读取数据到RAM中的指令中，它表示第二个输出的寄存器地址。

**这时，寄存器组的第一个输出用于选中RAM的内存地址，而第二个输出则是在对应内存位置需要写入的来自寄存器组的数据。**

![image-20230126144333739](..\计算机基础\images\image-20230126144333739.png)



![image-20230126144920424](..\计算机基础\images\image-20230126144920424.png)



在学习编程的时候，一般都会先接触变量赋值的概念，比如

```c
int a = 3;
```

这段代码本质就是在内存中某个地址放入3，在本课程的计算机上，这段代码被编译为类似下面的汇编指令：

```
movi r0, 3
sw r0, 58
```

![image-20230126090735790](..\计算机基础\images\image-20230126090735790.png)

上面的3只占用一个单独，不连续的存储空间就可以。但是程序中还有一些数据是一个存储空间存放不下的，必须占用一段连续的空间。比如对象、数组和指针，如下：

```c
int arr[5] = {0,1,2,3,4}
```

它们在底层对应的就是一块连续的内存空间。

![image-20230126091317354](..\计算机基础\images\image-20230126091317354.png)

指针本质是指向一块连续内存空间的**首地址**。



在RAM中初始化蛇头坐标数据的汇编代码如下： 

![image-20230126145423730](..\计算机基础\images\image-20230126145423730.png)



### 程序计数器



![image-20230126182625653](..\计算机基础\images\image-20230126182625653.png)





![image-20230126183258911](..\计算机基础\images\image-20230126183258911.png)



程序指令是放在ROM中的。当给ROM的读地址线通上0，表示读取地址0上存放的程序指令。

![image-20230126183648754](..\计算机基础\images\image-20230126183648754.png)

通上1的时候，ROM输出1号位置上的指令到CPU中进行执行。

![image-20230126183913857](..\计算机基础\images\image-20230126183913857.png)

这样的电路就能在每个时钟周期内，自动增加1。——**程序计数器（program counter） PC**



完整的计算机电路：

![image-20230126184244429](..\计算机基础\images\image-20230126184244429.png)

汇编程序：

![image-20230126184326107](..\计算机基础\images\image-20230126184326107.png)



汇编代码转为机器指令：

![image-20230126184617156](..\计算机基础\images\image-20230126184617156.png)

上面就程序和计算机结构已经实现了在内存中初始蛇，并让蛇头的X坐标加1了。但是缺少画面的输出。



### 画面IO

通过寄存器组的r4到r6中三个特殊的寄存器实现向外部的数据输出。

同过汇编指令`lw rn n`这类指令就能从RAM中读取数据后向外输出。

![image-20230126201250426](..\计算机基础\images\image-20230126201250426.png)



### 跳转

![image-20230126201714009](..\计算机基础\images\image-20230126201714009.png)

指令`jump 7`就是指跳转到第7条指令，控制指令位置的是程序计数器PC，jump 7就是让程序计数器的输出变为7，不论当前PC的值是多少，都强行变为7。现在需要改程序计数器的内部结构，如下图：

![image-20230126202101390](..\计算机基础\images\image-20230126202101390.png)



![image-20230126202114651](..\计算机基础\images\image-20230126202114651.png)

jump多路选择器的控制信号属于指令的高六位，而且跳转指令和RAM和CPU内部完全没有任何关系。所以对应机器指令中的后26位直接全部作为跳转指令的地址。**这就是MIPS指令集中的J类指令**。

![image-20230126202534313](..\计算机基础\images\image-20230126202534313.png)

![image-20230126202557616](..\计算机基础\images\image-20230126202557616.png)



## 计算机的三大特点

问题

1. 什么是硬件和软件？硬件和软件的区别？
2. 数据如何存储在计算机中？为什么不同的编码集下，汉字占用的字节数不同？
3. 什么是编码（code）?

### 三个特点

1.  计算机是执行输入、运算、输出的机器
2.  程序是指令和数据的集合
3.  计算机的处理方式与人们的思维习惯不同

计算机是由硬件和软件组成的。

### 硬件

计算机的硬件由大量的 **IC （Integrated Circuit，集成电路）**组成，每块 IC 上都带 有许多引脚。这些引脚有的用于输入，有的用于输出。IC 会在其内部 对外部输入的信息进行运算，并把运算结果输出到外部。

![image-20220902121244566](..\typora-user-images\image-20220902121244566.png)

但是无论是多么复杂的功能，都是通过组合一个又一个由输入、运算、输出构成的流程单位来实现的。如果打算用计算机做 点什么的话，就要考虑该**如何进行输入、如何获取输出以及进行怎样的运算**才能从输入得到想要的输出。

### 软件（程序）

软件是**指令和数据**的集合。

**所谓指令，就是控制计算机进行输入、运算、输出的命令**，把向计算机发出的指令一条条列出来，就得到了程序。向计算机发出的指令与计算机硬件上的行为一一对应。在程序设计中，会为一组指令赋予一个名字，可以称之为“函 数”“语句”“方法”“子例程”“子程序”等。

程序中的数据分为两类，一类是输入数据，它被提供给**指令执行对象**， 一类是输出数据，它从指令的执行结果中得到。在编程时程序员会为数据存放的地址命名，称其为“变量”。

### 编码

在用计算机替代手工作业的过程中， 要想顺应计算机的处理方法，有时就要违背人们的思维习惯。用数字表示所有信息，这就是一个很具有代表性的计算机式的处 理方法，这一点也正是和人类的思维习惯最不一样的地方。

计算机内部 会先把文字转换成相应的数字再做处理，这样的数字叫作“字符编码”。

计算机主要由集成电路元件组成。不同的 IC 功能不同，代表有：CPU（处理器）、内存以及 I/O

![image-20220916164232286](..\typora-user-images\image-20220916164232286.png)

## 组装微型计算机

### 计算机基本组成

1. CPU 是什么的缩写？
2. Hz 是表示什么的单位？
3. CPU 的比特

Central Processing Unit（中央处理器）

通常用 Hz 来表示驱动 CPU 运转的**时钟信号的频率**。1 秒发出 1 次时钟信号就是 1Hz，所以 100MHz（兆赫 兹）的话就是 100×100 万 = 1 亿次／秒。M（兆）代表 100 万。G 代表 1 亿。

**CPU 上数据总线的条数**或者**CPU 内部参与运算的寄存器的容量**，可以作为衡量 CPU 性能的比特数。Z80 CPU 中，无论是数据总线的条数还是寄存器的容 量都是 8 比特，现在的个人计算机一般是 64 位或者 32 位的 CPU。

**元件之间传输的信号的作用**

### 基础元件

基础元件只有 3 个，**CPU、内存和 I/O**，每种元件都是一块独立的 IC。

CPU 负责执行一条条的机器代码指令，对数据执行运算并控制内存和 I/O。

内存负责存储程序指令和产生的数据。

I/O 负责将计算机和外部设备（周边设备）连接在一起，实现数据的输入与输出。

使用到的微型计算机的元件：

1. Z80 CPU，8 比特
2. TC5517 内存，存储容量 2Kb (00000000000~11111111111)
3. Z80 PIO I/O，在微型计算机和外部设备之间单次并行地（**一排一排地**）输入输 出 8 比特的数据
4. 辅助元件
   1. 时钟发生器，用于输出时钟信号这种电信号，驱动 CPU 运转，每隔一定时间就变换一次电压的高低。时钟发生器中带有晶振，根据其自身的频率（振动的次数）产生时钟信 号。时钟信号的频率可以衡量 CPU 的运转速度。
   2. 输入指令（在这里一个指令 8bit）的设备——指拨开关，一种由 8 个开关并排连在一起构成的元件，输入一些列指令组成一个程序
   3. 输出结果的设备——8 个 LED（发光二极管）
   4. 74367 和 7404 IC——用于提高连接外部设备时的稳定性。
   5. 为了省去布线的麻烦，使用将 8 个电阻集成到 1 个元件中的集成电阻——阻碍电流流动、降低电压值
   6. 电容——避免电压的瞬间变化
   7. 要让微型计算机运转起来，5V（伏 特）的直流电源，使用一个叫作“开关式稳压 电源”的装置，将 220V 的交流电变成 5V 的直流电。

![image-20220901132331018](..\typora-user-images\image-20220901132331018.png)

![image-20220901132342491](..\typora-user-images\image-20220901132342491.png)

![image-20220901132404786](..\typora-user-images\image-20220901132404786.png)

![image-20220916184002534](..\typora-user-images\image-20220916184002534.png)

### 电路图基础

图中的一条条的线段连接着各种元件符号，线段就表示布线。线段交叉处是否连接通电用是否有小黑圆点确认。

![image-20220901180244802](..\typora-user-images\image-20220901180244802.png)

两种电路图符号分别表示电路连接到 +5V 和连接到 0V 的情况。

![image-20220901180252524](..\typora-user-images\image-20220901180252524.png)

IC 的引脚按照逆时针方向依次带有一个从 1 开始递增的序号。

![image-20220901181605122](..\typora-user-images\image-20220901181605122.png)

通常所绘制的电路图都不受引脚实际排布的限制（有时也会遵循引脚序号的顺序绘制电路图，这样的电路图叫作实物布线图）。**画图时，在引脚的旁边写上引脚的序号，在表示 IC 的矩形符号中写上表明该引脚作用的代号。**就像 RD（Read）表示执行 读取操作，WR（Write）表示执行写入操作，这样的代表了某种操作的符号。

![image-20220901182007205](..\typora-user-images\image-20220901182007205.png)

![image-20220901182747236](..\typora-user-images\image-20220901182747236.png)

写在引脚旁边的代号，其含义会写在 IC 生产厂商发布的资料中，为了保持文章的通俗易懂，改变了一部分代号的写法。例如，在厂商的资料中 TC5517 的第 20 个引脚的代号是 OE（Output Enable，输出使能），在这里则改为了含义相同的 RD（Read，读取）。

### 布线

IC（集成电路（integrated circuit））

首先连接电源，Z80 CPU、TC5517 和 Z80 PIO 上都分别带有 Vcc 引脚和 GND 引脚。 Vcc 和 GND 这一对儿引脚用于为 IC 供电。+5V 电源连接到各个 IC 的 Vcc 引脚上，然后将 0V 电源连接到各个 IC 的 GND 引脚 上。将 +5V 和 0V 连接到时钟发生器上。接通电源后就可以工作。

微型计算机所使用的 IC 属于数字 IC（数字 IC 上 1 个引脚能表示 0 或者 1）。在数字 IC 中，每个引脚上的电压要么是 0V、要么是 +5V，通过这两个电压与其他的 IC 进行电信号的收发。

8 比特微型计算机是以 8 比特为一个单位收发信息的。

**重点：**

CPU 可以和内存或 I/O 进行数据的输入输出，这时就**需要知道输入数据或者输出数据的目标地址**，即 CPU 从哪个位置的数据到 CPU 的寄存器中，同时又将处理好的结果输出到哪个地址。 **CPU 上可以通过“地址总线引脚”来得到前面说到的信息。**

Z80 CPU 的地址总线引脚共有 16 个，用代号 A0 ～ A15 表示，其中的 A 表示 Address（地址）。

后面的数字 0 ～ 15 组合在一起表示一个 16 位的二进制数中各个数字的位置，0 对应最后一位、15 对应 第一位。16 个地址总线引脚所能指定的地址共有 65536 个，用二进制 数表示的话就是 0000000000000000 ～ 1111111111111111。因此 Z80 CPU **可以指定 65536 个数据存取单元（内存存储单元或 I/O 地址），进行信息的输入输出。**

![image-20220901201730219](..\typora-user-images\image-20220901201730219.png)

**地址总线用于确定存取数据位置，数据总线用于往地址总线指定的位置写入或者读取数据。**

一旦通过“地址总线引脚”得到了存取数据的地址，接下来就可以使用**CPU 的数据总线引脚和内存或者 I/O 进行数据的输入输出**。（Z80 CPU 的数据总线引脚共有 8 个，用代号 D0 ～ D7 表示。其中的 D 表示 Data（数据），后面的数字 0 ～ 7 与地址总线引 脚代号的规则相同，也表示二进制数中各个数字的位置。）

Z80 CPU 可以一次性地输入输出 8 比特的数据，这就意味着如果想要输入输出位数（比特数）大于 8 比特的数据，就要以 8 比特为单位切分这个数据。

**内存 TC5517 上也有地址总线引脚（A0 ～ A10）和数据总线 引脚（D0 ～ D7）。**这些引脚需要同 Z80 CPU 上带有相同代号的引脚相连。地址总线引脚有十一个引脚，也就是 11 位二进制数，11 位二进制一共可以标识 2048 个内存地址。

一块 TC5517 上可以存储 2048 个 8 比特的数据，**可是由于用于输入程序的指拨开关是以 8 比特为一个单位 指定内存地址 ，所以只使用 TC5517 上的 A0 ～ A7 这 8 个引脚，**并把剩余的 A8 ～ A10 引脚连接到 0V 上（这些引脚上的值永远是 0）。虽然总共有 2048 个存储单元，最终却只能使用其中的 256 个。

![image-20220901204046956](..\typora-user-images\image-20220901204046956.png)

寄存器在 CPU 和 I/O 中都有，是存储数据用的数据存储器。**Z80 PIO 上共有 4 个寄存器。2 个用于 设定 PIO 本身的功能，2 个用于存储与外部设备进行输入输出的数据。**

![image-20220901204607150](..\typora-user-images\image-20220901204607150.png)

这 4 个寄存器分别叫作端口 A 控制、端口 A 数据、端口 B 控制和 端口 B 数据。**所谓端口就是 I/O 与外部设备之间输入输出数据的场所。**Z80 PIO 有 2 个端 口，端口 A 和端口 B，最多可以连接 2 个用于输入输出 8 比特数据的 外部设备。

![image-20220901204549956](..\typora-user-images\image-20220901204549956.png)

Z80 PIO 上也有 D0 ～ D7 的数据总线引脚，所以先把它们和 Z80 CPU 中带有同样代号的引脚连接起来。**这样 CPU 和 PIO 就能使用这 8 个引脚交换数据**。

把 Z80 PIO 的 B/A 和 C/D 引脚分别连接到 Z80 CPU 的地址总线引脚 A0 和 A1 上。通过 Z80 CPU 的 A0 ～ A7（00000000 ～ 11111111 共 256 个地址）地址总线引脚可以选择内存（TC5517）中的存储单元。同样地，使用 Z80 CPU 的 A0 ～ A1（00 ～ 11 共 4 个地址）地址总线引脚也可以选择 I/O （Z80 PIO）中的寄存器。

Z80 CPU 的 A8 ～ A15 地址总线引脚尚未使用，所以什么都不连接。在电路图中可以用代号 NC（No Connection，未连接）表示引脚什么 都不连接。IC 上的引脚有些只用于输出，有些只用于输入，还有些是输 入输出两用的。对于只用于输出的引脚，不需要使用时的处理方法是这个引脚什么都不连接；而对于只用于输入或输入输出两用的引脚，不需 要使用时的处理方法则是把这个引脚上的电压固定成是 +5V 或 0V。

**连接时钟信号**

Z80 CPU 和 Z80 PIO 的运转离不开时钟信号，为 了传输时钟信号，**就需要把时钟发生器的 8 号引脚和 Z80 CPU 的 CLK （CLK 即 Clock，时钟）引脚、Z80 PIO 的 CLK 引脚分别连接起来。**钟发生器的 8 号引脚与 +5V 之间的电阻用于清理时钟信号。

**连接用于区分读写对象是内存还是 I/O 的引脚**

把 Z80 CPU 连接到了 TC5517 和 Z80 PIO 上后， 这两次连接都使用了地址总线引脚 A0 和 A1。如果仅仅这样连接，就会导致一个问题，当地址的最后两位是 00、01、10 和 11 时，CPU 就无法 区分访问的是 TC5517 中的存储单元，还是 Z80 PIO 中的寄存器了。

Z80 CPU 上的 MREQ（即 Memory Request，内存请求）引脚和 IORQ （即 I/O Request，I/O 请求）引脚解决了这个问题。**当 Z80 CPU 和内存之间 有数据输入输出时，MREQ 引脚上的值是 0，反之则是 1。当 Z80 CPU 和 I/O 之间有数据输入输出时，IORQ 引脚上的值是 0，反之则是 1。**

若把 TC5517 的 CE（即 Chip Enable，选通芯片）引脚设成 0，则 TC5517 在 电 路 中 被 激 活， 若 设 成 1 则 从 电 路 中 隔 离， 因 为 此 时 TC5517 进入了高阻抗状态，所以即便它上面的引脚已经接入了电路也 不会接收任何电信号。在 Z80 PIO 中，则是通过将 CE 引脚和 IORQ 引 脚同时设为 0 或 1，来达到与 TC5517 的 CE 引脚相同的效果。若同时 设为 0，则 Z80 PIO 在电路中被激活，若同时设为 1 则从电路中隔离 （之所以使用两个引脚是因为这样更适合使用了多个 I/O 的情况）。

**连接外部设备，通过 DMA 输入程序**

计算机主机系统和 I/O 设备进行连接，I/O 设备有：2 个指拨开关和 1 个按键开关。

可以通过一个指拨开关设置向内存中写入数据的地址，然后在确定了写入内存地址后，可以通过另一个指拨开关向内存中的指定位置写入数据。（**向地址总线引脚和数据总 线引脚发送电信号，然后通过 DMA 将数据总线上的数据存储到内存。**）

**对内存和 I/O 而言，还必须要分清 CPU 是要输入数据还是输出数据。**

为此就要用到 Z80 CPU 的 RD 引脚（即 Read，表示输入，为 0 时 执行输入操作）和 WR 引脚（即 Write，表示输出，为 0 时执行输出操作）。

请把这两个引脚与 TC5517 上同名的引脚连接起来。Z80 PIO 虽然只有 RD 引脚，但由于数字 IC 引脚上的值要么是 0 要么是 1，所 以只用 1 个 RD 引脚也能区分是输入还是输出，0 的话是输入，1 的话 就是输出。

![image-20220917191134996](..\typora-user-images\image-20220917191134996.png)

**连接剩余的控制引脚**

除去地址总线引脚、数据总线引脚后的其他引脚——统称为“控制引脚”。之所以这样命名是因为 这些引脚上输入输出的电信号具有控制 IC 的功能。

Z80 CPU 的 M1 引脚（即 Machine Cycle 1，机器周期 1）和 INT 引脚（即 Interrupt，中断），与 Z80 PIO 上标有相同代号的引脚连接起来。

M1 是用于同步的引脚，INT 引脚是用于从 Z80 PIO 向 Z80 CPU 发出中断请求的引脚。所谓中断就是让 CPU 根据外部输入的数据执行 特定的程序。

**I/O 可以中断 CPU 对程序的处理流程**

**Z80 CPU 的 RESET 引脚**：一旦把 Z80 CPU 的 RESET 引脚（即 Reset，重置）上的值先设成 0 再还原成 1，CPU 就会被重置，重新从内存 0 号地址上的指令开始顺 序往下执行。重置 CPU 通过按键开关完成。

RESET 引脚上平时是 +5V（即 1）。当按下按键开关时，RESET 引脚就 变成了 0V（即 0），而放开按键开关后又会回到 +5V（即 1）。（电阻是为 了防止短路而加入的，否则一旦按下了按键开关，+5V 和 0V 就会直接 接到一起发生短路。）

![image-20220917191918574](..\typora-user-images\image-20220917191918574.png)

![image-20220917191655750](..\typora-user-images\image-20220917191655750.png)

电容：连接在 RESET 引脚上的电容，用于在电路接通电源时自动重置 CPU。电容就好像一个充电电池，具有储存电荷的功能。在通电后的 一刹那，由于电容正在充电，所以 RESET 引脚上的电压并不会立刻上 升到 +5V。而完成充电后，RESET 引脚的电压会变为 +5V，这样就相 当于 RESET 引脚上的值从 0 变成了 1，重置了一次 CPU。

#### BUSRQ 引脚

使用快动开关可以使 Z80 CPU 的 BUSRQ 引脚（即 Bus Request， 总线请求）上的值在 0 和 1 之间切换。若将 BUSRQ 引脚的值设为 0， 则 Z80 CPU 从电路中隔离。当处于这种隔离状态时，就可以不通过 CPU，手动地向内存写入程序了。像这样不经过 CPU 而直接从外部设 备读写内存的行为叫作 DMA（Direct Memory Access，直接存储器访 问）。在个人计算机里，硬盘等设备要读写内存时使用的就是 DMA。

#### BUSAK 引脚

当 Z80 CPU 从电路中隔离后，BUSAK 引脚（即 Bus Acknowledge， 响应总线请求）上的值就会变成 0。也就是说，把 BUSRQ 引脚上的值 设成 0 以后，还要确认 BUSAK 引脚上的值已经变成了 0，然后才能进 行 DMA。请把 BUSAK 引脚分别连接到 4 个 74367 的 G1 和 G2 引脚 上。

### 内存

#### PA0 ～ PA7

PA 表示 Port A，用于与外部设备进行输入，连接到 指拨开关上

#### PB0 ～ PB7

PB 表示 Port B，用于与外部设备进行输出，连接到 LED 上

IEI 引脚 上拉，IEO 引脚、ASTB 引脚、ARDY 引脚、BSTB 引脚和 BRDY 引脚 则什么都不连接。

### 汇总集成电路引脚作用表

计算机的工作原理：CPU 在时钟信号的控制下解释、执行内存中存储的程序，按照程序中的指 令从内存或 I/O 中把数据输入到 CPU 中，在 CPU 内部进行运算，再把 运算结果输出到内存或 I/O 中。

![image-20220917192737706](..\typora-user-images\image-20220917192737706.png)

![image-20220917192838031](..\typora-user-images\image-20220917192838031.png)

![image-20220917192846604](..\typora-user-images\image-20220917192846604.png)

**将计算机主机系统和外部设备连接起来**

3 个指拨开关和 1 个按键开关

在 CPU 的 DMA 条件下，

一个指拨开关向地址总线引脚发送电信号，设置数据的写入位置。

一个指拨开关向数据总线引脚发送电信号，设置在指定位置写入的指定数据。

一个指拨开关

## 手动汇编

什么是机器语言？

> 由数字 0 和 1 组成的指令，指令再组成程序，而 CPU 能识别的就是机器语言。

把标识内存或者 I/O 中存储单元的数字称作？

> 称作地址，CPU 是通过一组二进制数字进行访问该地址中的数据或者指令的。I/O 中的寄存器也可以用地址来标识。哪个寄存器对应 哪个地址，取决于 CPU 和 I/O 之间的布线方式。

CPU 中的标志寄存器（Flags Register）有什么作用？

> CPU 执行 了算术运算、逻辑运算、比较运算等指令后，标志寄 存器并不会存放运算结果的值，而是会把运算后的某 些状态存储起来，例如运算结果是否为 0、是否产生了 负数、是否有溢出（Overflow）等。

**基于上一章的微型计算机**

![image-20220914210152644](..\typora-user-images\image-20220914210152644.png)

程序的作用是驱动硬件工作，在编写程序之前必须要先了解计算机的硬件信息，其中重点了解的硬件信息有：

1. CPU 的种类

   > 机器语言就是处理器可以直接理解（与 生俱来就能理解）的编程语言，每种 CPU 都有自己的机器语言，同样一段机器语言，在不同的 CPU 架构中可能有不同的含义，有的 CPU 会把它解释成是执行加法运算，有的 CPU 会把它解释成是向 I/O 输出。
   >
   > 上一章的微型计算机使用的是 Z80 CPU，所以就要使用 Z80 CPU 能识别的机器语言。

2. 时钟信号的频率

   > 由时钟发生器发送给 CPU 的电信号的频率。**时钟信号是在 0 和 1 两个数之间反复变换的电信号**，通常把发出一次滴答的时间称作一个时钟周期。
   >
   > 微型计算机使用的是 2.5MHz 的时钟信号。(兆赫兹 = 100 万回／秒)

   在机器语言当中，**指令执行时所需要的时钟周期数取决于指令的类型。**可以通过累加时钟周期数估算程序执行的时间。

3. 内存地址空间内存中的每个数据存储单元都有唯一的内存地址，这些地址所构 成的范围就是内存的地址空间。

   > 在上一章的微型计算机中，地址空间为 0 ～ 255，每一个地址中可以存储 8 比特（1 字节）的指令或数据。

4. 每个地址中可以存储多少 bit 的信息

   > 在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。

5. I/O 的种类指的是连接着微型计算机和周边设备的 I/O 的种类。

   > 在微型计算机中，只安装了一个 I/O，即上面带有 4 个 8 比特寄存器的 Z80 PIO。只要用 CPU 控制 I/O 的寄存器，就可以设定 I/O 的功能，与周边设备进行数据的输入输出。

6. I/O 中的地址空间

   > 用于指定 I/O 寄存器的地址范围。在 Z80 PIO 上，地址空间为 0 ～ 3，每一个地址对应一个寄存器。
   >
   > 地址编号不同（即寄存器的类型不同），功能也就不同。
   >
   > Z80 PIO 上的寄存器，端口 A 数据寄存器和端口 B 数据寄存器存储的是与周边设备进行输入输 出时所需的数据。其中，端口 A 连接用于输入数据的指拨开关，端口 B 连接用于输出数据的 LED。而端口 A 控制寄存器和端口 B 控制寄存 器则存储的是用于设定 Z80 PIO 功能的参数。

7. 连接的 I/O 设备

点亮 LED 的机器语言程序，功能是把由指拨开关输入的数据输入 CPU，然后 CPU 再 把这些数据原封不动地输出到 LED：

```
地址         机器语言
00000000   00111110
00000001   11001111
00000010   11010011
00000011   00000010
00000100   00111110
00000101   11111111
00000110   11010011
00000111   00000010
00001000   00111110
00001001   11001111
00001010   11010011
00001011   00000011
00001100   00111110
00001101   00000000
00001110   11010011
00001111   00000011
00010000   11011011
00010001   00000000
00010010   11010011
00010011   00000001
00010100   11000011
00010101   00010000
00010110   00000000
```

上面机器代码的特点，一个指令占 8bit（即一个字节），总共 23 个字节。若把 这些字节一个接一个地依次写入内存中，所占据的内存空间就是 00000000 ～ 00010110。一旦重置了 CPU，CPU 就会从 00000000 号地址开始顺序执行这段程序。

机器语言写的程序中，每一段二进制组成的指令或者数据都有特定含义，但是对于人类来时二进制指令很难记忆。为此引入了汇编语言来编写程序。 每个指令代码都有一定的含义，通过借用一个类似含义的英文单词的缩写来标识该机器指令。这种单词缩写就是——“助记符”。

使用助记符的编程语言叫作“汇编语言”。

```
地址 机器语言
00000000 00111110
00000001 11001111
00000010 11010011
00000011 00000010
00000100 00111110
00000101 11111111
00000110 11010011
00000111 00000010
00001000 00111110
00001001 11001111
00001010 11010011
00001011 00000011
00001100 00111110
00001101 00000000
00001110 11010011
00001111 00000011
00010000 11011011
00010001 00000000
00010010 11010011
00010011 00000001
00010100 11000011
00010101 00010000
00010110 00000000
```

上面机器代码对应的 CPU 的汇编代码：

汇编语言的语法：**“标 签”“操作码（指令）”和“操作数（指令的对象）”并排写在一行。**

```
标签   操作码      操作数
        LD        A, 207
        OUT       (2), A
        LD        A, 255
        OUT       (2), A
        LD        A, 207
        OUT       (3), A
        LD        A, 0
        OUT       (3), A
LOOP:   IN        A, (0)
        OUT       (1), A
        JP        LOOP
```

**标签**：为该行代码对应的内存地址起一个名字。用汇编语言编程时可以在任何需要标 签的地方“贴上”名称任意的标签。在后续的指令中可以通过操作码加 标签名访问特定的内存地址。

**操作码**：表示“做什么”的指令。因为用助记符表示的指令是 英语单词的缩写，比如 LD 是 Load（加载）的缩写，有一定的表意性。**汇编语言中提供了多少种助记符，CPU 就有多少种功能。**

Z80 CPU 的指令全部加起来有 70 条左右。主要的指 令列看下图：

注意这 些指令的分类，按功能分，这些指令可以分成运算、与内存的输入输出和 与 I/O 的输入输出三类。

**num ：表示 1 个数值，(num) ：表示值为 num 的地址**

reg、reg1、reg2：名为 reg、reg1、reg2 的寄存器，(reg) ：存储在名为 reg 的寄存器中的地址

![image-20220917220505649](..\typora-user-images\image-20220917220505649.png)

**操作数**：表示的是指令执行的对象。**CPU 的寄存器、内存地址、I/O 地址或者直接给出的数字都可以作为操作数。**

如果某条指令需要多个操作数，那么它们之间就要用逗号分割。操作数的个数取决于指令的种类。也有不需要操作数的指令，比如用于停止 CPU 运转的 HALT 指令。

构成机器语言的是二进制数，而在汇编语言中，则使用十进制数 和十六进制数记录数据。若仅仅写出 123 这样的数字，表示的就是十进 制数；而像 123H 这样在数字末尾加上了一个 H（H 表示 Hexadecimal， 即十六进制数），表示的就是十六进制数。

在汇编语言 中，读写内存的指令不同于读写 I/O 的指令。一旦执行了读写内存的指 令，比如 LD 指令，MREQ 引脚上的值就会变为 0，于是内存被选为输 入输出的对象；而一旦执行了读写 I/O 的指令，比如 IN 或 OUT 指令， IORQ 引脚上的值就会变为 0，于是 I/O（这里用的是 Z80 PIO）被选为 输入输出的对象。

**数据的运算 是在 CPU 中进行的，那么在 CPU 内部就应该有存储数据的地方。这种 存储数据的地方叫作“寄存器”。**但是与 I/O 的寄存 器不同，CPU 的寄存器不仅能存储数据，还具备对数据进行运算的能 力。

**CPU 带有什么样的寄存器取决于 CPU 的种类。**Z80 CPU 所带有的 寄存器如图 3.2 所示。A、B、C、D 等字母是寄存器的名字。

**在汇编语言当中，可以将寄存器的名字指定为操作数。**

Z80 CPU 的寄存器如下图：

![image-20220917221337569](..\typora-user-images\image-20220917221337569.png)

IX、IY、SP、PC 这 4 个寄存器的大小是 16 比特，其余寄存器的 大小都是 8 比特。**寄存器的用途取决于它的类型。有的指令只能以特定的寄存器指定为操作数。**

A 寄存器也叫作“累加器”，是运算的核心。

F 寄存器也叫作“标志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的 比较结果等。

PC 寄存器也叫作“程序指针”，存储着指向 CPU 接下来要执行的指令的地址。

> PC 寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的 PC 寄存器的值运行起来的。

SP 寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临时数据存储区域。

#### 解读汇编代码

上面汇编代码的功能主要有：

1. 设定 Z80 PIO
2. 与 Z80 PIO 进行输入输出

Z80 PIO 带有两个端口（端口 A 和端 口 B），用于与周边设备输入输出数据。**首先必须为每个端口设定输入 输出模式。**Z80 PIO 的端口 A 用于接收由指拨开关输入的数据，为了实现这个功能，需要如下的代码：

```
标签   操作码      操作数
        LD        A, 207
        OUT       (2), A
        LD        A, 255
        OUT       (2), A
```

这里的 207 和 255 是连续向 Z80 PIO 的端口 A 控制寄存器（对应 该 I/O 的地址编号为 2）写入的两个数据。虽然使用 OUT 指令可以向 I/O 写入数据，但是汇编语言的规定是不能直接把数据作为 OUT 指令的操作数。

**OUT 指令的操作数必须是已存储在 CPU 寄存器中的数字，这是规定。**

LD A, 207：把数字 207 读入到寄存器 A 中，这行指令是标识准备设置端口 A 的输入输出模式

OUT (2), A：把寄存器 A 中的数据写入到 I/O 地址所对应的寄存器中，要把端口 A 设定为输入模式，已经开启设置输入输出模式。像“(2)”这样用括号括起来的数字，表示的是地址编号。 端口 A 控制寄存器的 I/O 地址是 2 号。

**一旦把 207 写入到端口 A 控制寄存器**

LD A, 255：把数字 255 读入到寄存器 A 中

OUT (2), A：把寄存器 A 中的数据（255）写入到 I/O 地址所对应的寄存器中，开启端口 A 设定为输入模式

通过下面的程序可以将端口 B 设定为输出模式:

```
标签   操作码      操作数
        LD        A, 207
        OUT       (3), A
        LD        A, 0
        OUT       (3), A
```

把 207 写入到端口 B 控制寄存器（对应的 I/O 地址为 3 号），然 后写入 0。这个 0 表示要把端口 B 设定为输出模式。

应该使用什么样的 数字设定端口，在 Z80 PIO 的资料上都有说明。

完成了 Z80 PIO 的设定后，就进入了一段死循环处理，用于把由指拨开关输入的数据输出到 LED。为了实现这个功能，需要如下的代码。

```
标签   操作码      操作数
LOOP:   IN        A, (0)
        OUT       (1), A
        JP        LOOP
```

IN A, (0)：是把数据由端口 A 数据寄存器（连接在指拨开关上，对应的 I/O 地址为 0 号）输入到 CPU 的寄存器 A。

OUT (1), A：把寄存器 A 的值输出到端口 B 数据寄存器上（连接在 LED 上，对应的 I/O 地址为 1 号）

JP LOOP：是使程序的流程跳转到 LOOP（笔者随意起的 一个标签名）标签所标识的指令上。

#### 机器代码的执行流程

**1 条汇编语言的指令所对应的机器语言由多个字节构成。**

1 条汇编语言的指令，有的指令对应着 1 个字节的机器语言，有的指令则对 应着多个字节的机器语言。

汇编语言中的 1 条指令能转换成多少条机 器语言取决于指令的种类以及操作数的个数。

![image-20220918122903259](..\typora-user-images\image-20220918122903259.png)

将上图中的机器代码依次加载到内存中，重置 CPU， 内存地址 00000000 中的机器指令被自动存储到 PC 寄存器中，CPU 从 00000000 号地址读出指令 00111110，判断出这是一条由 2 个字节构成 的指令，于是接下来会从下一个地址（00000001）读出数据 11001111，把这两个数据 汇集到一起解释、执行。执行的指令是把数值 207 写入到寄存器 A， 用汇编语言表示的话就是“LD A, 207”。

由于刚刚从内存读出了 一条 2 字节的指令，所以 PC 寄存器的值要增加 2，并接着从 00000010 号地址读出指令，解释并执行。

通过反复进行“读取指令”“解释、执行 指令”“更新 PC 寄存器的值”这 3 个操作，程序就能运行起来。

一 旦执行完最后一行的 JP LOOP 所对应的机器语言，PC 寄存器的值就会 被设为标签 LOOP 对应的地址 00010000，这样就可以循环执行同样的 操作。

#### 人工汇编

**在 CPU 的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言 编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。**

Z80 CPU 产品说明书中有指令的助记符、助记符所对应的机器语言，以及执行这些机器语言所需的时钟周期数。

![image-20220918124506279](..\typora-user-images\image-20220918124506279.png)

把 LD A, 207 转为二进制机器码 ： “LD A, 207”匹 配“LD A, num”这个模式，，所以可以先转换成“00111110 num”。然后 将十进制数的 207 转换成 8 比特的二进制数，用这个二进制数替换 num。207 就变成了二进制数的 11001111。至此，“LD A, 207”就转换成了机器语言 00111110 11001111。

OUT (2), A：指令“OUT (2), A”匹配“OUT (num), A”这个模式，所以 可以先转换成“11010011 num”。然后把 num 的部分替换成 00000010， 即用 8 比特的二进制数表示的十进制数 2，最终就得到了机器语言 “11010011 00000010”。

IN A, (0)：“IN A, (0)”匹配“IN A, (num)”这个模式，所以可以先转 换成“11011011 num”。然后把 num 替换成 00000000，即用 8 比特的二 进制数表示的十进制数 0，最终就得到了机器语言“11011011 00000000”。

JP LOOP：JP LOOP 匹配模式“JP num”，所以可以先转换成 “11000011 num”。请注意这里要用 16 比特的二进制数替代作为内存地 址的 num。在微型计算机中是以 8 比特为单位指定内存地址的，但在 Z80 CPU 中用于设定内存地址的引脚却有 16 个，所以在机器语言中也要用 16 比特的二进制数设定内存地址。JP 指令跳转的目的地为 00010000，即“LOOP:”标签所标示的语句“LD A, 0”对应的内存地 址。把这个地址扩充为 16 比特就是“00000000 00010000”。要扩充到 16 位，只需要把高 8 位全部设为 0 就可以了。

在将一个 2 字节的数据存储到内存时， 存储顺序是低 8 位在前、高 8 位在后（也就是逆序存储）。这样的存储 顺序叫作“小端序”（Little Endian），与此相反，将数据由高位到低位 顺序地存储到内存的存储顺序则叫作“大端序”（Big Endian）。根据 CPU 种类的不同，有的 CPU 使用大端序，有的 CPU 使用小端序。Z80 CPU 使用的是小端序，因此 JP LOOP 对应的机器语言为“11000011 00010000 00000000”。

#### 估算程序执行的时间

通过时钟周期数估算程序的执行时间。

找出执行每条汇编语言指令所需的时钟周期数，然后将代码中所用到的每条指令的时钟周期数累加起来。于是可以算出到 LOOP 标签为止的 8 条指令共需要 7 ＋ 11 ＋ 7 ＋ 11 ＋ 7 ＋ 11 ＋ 7 ＋ 11 = 72 个时钟周期；LOOP 标签之后的 3 条指令共需要 11 ＋ 11 ＋ 10 = 32 个时钟周期。因为微型计算机采用的是 2.5MHz 的晶振，也 就是 1 秒可以产生 250 万个时钟周期，所以每个时钟周期是 1 秒 ÷250 万 = 0.0000004 秒 = 0.4 微秒。72 个时钟周期就是 72×0.4 = 28.8 微秒；32 个时钟周期就是 12.8 微秒。这段程序是用 LED 的亮或灭来表示指 拨开关的开关状态，所以 LOOP 标签之后所执行的操作“输入、输出、 跳转”每 1 秒可以反复执行 1 秒 ÷12.8 微秒 / 次 = 78125 次



## 程序流程

CPU 中有一个被称为 PC （Program Counter，程序计数器）的寄存器，负责存储内存地址，该寄存器地址中存放着指向下一条即将执行的指令所在的内存地址。每解释执行完一条指令，PC 寄存器的 值就会自动被更新为下一条指令的地址。

假设 PC 寄存器正指向内存中一个从 10 号地址开始的 3 字节指令。CPU 解释执行完这条指令后，PC 寄存器中的值就变成 10 ＋ 3 = 13。

**程序基本 上是从内存中的低地址（编号较小的地址）开始，向着高地址（编号较 大的地址）执行下去 。**——顺序执行

![image-20220918150031094](..\typora-user-images\image-20220918150031094.png)

顺序执行是按照指令记录在内存中的先后顺序依 次执行的一种流程。

循环则是在程序的特定范围内反复执行若干次。

条件分支是根据若干个条件的成立与否，在程序的流程 中产生若干个分支的一种流程。

无条件分支类似就是函数调用





