# 计算机操作系



## 概述

- 为什么要学习操作系统？

- 什么是操作系统？

- 怎样学习操作系统？

- 学习操作系统需要的前导知识，历史和宏观概述







### 为什么要学习操作系统？



**自我要求**

- 发自内心的想要学好操作系统的欲望和要求
- 尽可能独立实现功能代码，让自己得到应用的训练
- 坚持下来就能变为很不一样的人



**为什么学一门学科知识？（motivation）**

传统教学缺失了历史背景知识的讲解，则直接就去学学科中内容，而缺失了为什么学习？很多东西学习之后，由于没有被用到或者一直没有遇到使用的场景，很快就忘记，这是课程组织不合理导致的。以学习微积分为例子，中国的微积分教学混淆了三件事，这三件事没有说清楚，微积分学起来就不会太容易理解：

- 牛顿时代的微积分是怎样的？他们想解决的问题是什么？他们面临的问题是什么？  （不知道什么能算，什么不能算，什么能算的好或者算不好，主要在于用而不一定对）

- 柯西时代的微积分，微积分的公理化和严格化，有了微积分的公理系统（中值定理等）
- 微积分的现代应用，微积分的运算和使用技巧
- 没有必要一上来以纯数学的角度学习各种定理和证明，可以先了解基本应用
- 其实以现代的视角来看，可以分为微积分的应用，微积分的公理化和微积分的运算技巧，三者完全是可以分开的，对于工科专业，在知道微积分中的基本概念（比如微积分是什么，导数是什么，积分是什么，微积分基本定理）后，可以一上来不关注微积分的运算技巧，直接使用已有的工具库函数解决微积分运算的需求，对于我们来说，可能那些计算技巧可能不太重要。在知道微积分中的基本概念基础上，先学习微积分的现代应用（优化，有限元，PID），然后透过现代应用中的微积分知识的使用，再深入学习和理解微积分。



- 花大量时间学习中值定理，分布积分的技巧，但是如果要理解微积分在现代工业中的应用的时候，自己需要理解各种定理和技巧  与 微积分的现代应用是两件差异很大的事情
- 先将微积分的现代应用，将一个现代应用的解决方法，再学习解一些数学题 
- 比如线性代数完全可以从图形学的视角来学习，学习后再去抽象到具体的线性代数知识
- 直接一上来就以抽象为纯数的方式学习数学（定理证明，定理证明，定理证明....），其实没有必要，有基础概念后先用在学

操作系统也是一个道理。

要有足够好的编程材料，编程才能很好的自学。编程是一件非常严肃的事。

**为什么要学习操作系统？**

- 有很多非常基础的问题，自己仍然不知道原因，即使自己每天都在使用
- 无法实现一些非常强大的功能，如编译器，浏览器，病毒与外挂等
- 这些课程最重要的作用就是让自己能摸到这些东西
- 理解操作系统后，知道操作系统给应用程序提供的api后，就能具备基本写编写一切程序的能力
- 操作系统课帮助自己理解一系列最小的，但是在原理上又是完全一样的东西的工作原理，当将来自己接触到巨型系统是也能映射到这些学过的最小的知识中，以理解巨型系统



如果每个人都能够在正确的时候接受正确的知识和训练，都能变得很强。



**什么是操作系统？**

操作系统：事实上是一个软件的主体，它使程序运行变得更加容易(甚至让你看起来可以同时运行多个程序) ，允许程序共享内存，允许程序与设备交互，以及其他类似的有趣的东西。

“管理软/硬件资源、为程序提供服务” 的程序。

想要更好的理解什么是操作系统，需要了解计算机和操作系统的发展演变历史。

- 计算机硬件的发展
- 计算机的软件发展
- 现代操作系统



**计算机演变历史**



**1940年代的计算机**

 那时的计算机并不是冯诺依曼结构计算机，而是一个用于运算的时序逻辑电路（状态机）。使用的逻辑门是真空电子管；使用的存储器是延迟线；输入输出设备是打孔纸带和指示灯。

其中存储器不适用真空管来实现的，而是延迟线内存（在一个一维空间（即时间）上存储数据），内部结构如下图

![image-20230702223250010](C:\Users\dukkha\Desktop\study-notes\计算机基础\images\image-20230702223250010.png)

**1940年代的程序**

ENIAC 计算机是用物理线路 “hard-wire” 的，重编程需要重新接线。所以在那时的计算机上并不需要操作系统，程序直接用指令操作硬件，只用于简单的数学计算。



**1940年代的操作系统**

没有操作系统，程序直接用指令操作硬件，不需要额外的程序来管理程序。



**1950年代的计算机**

更快更小的逻辑门 (晶体管)、更大的内存 (磁芯，二维网格)、丰富的 I/O 设备

特点：

- I/O 设备的速度已经严重低于处理器的速度，中断机制出现 (1953)



**1950年代的程序**

- 可以执行更复杂的任务，包括通用的计算任务
- 还是使用卡片机编程

不足:

- 计算机非常昂贵，但那时希望使用计算机的人越来越多（一个学校只有一台）
- 不同系提供的不同用处的程序都需要使用计算机来执行，当一个程序执行完后，需要工作人员去手动更换新的程序（打孔卡）去执行
- 写程序、跑程序都是非常费事的



**1950年代的操作系统**

为此产生了新的需求，产生了集中管理程序（集中管理打孔卡）的需求，多用户排队共享计算机。从那个年代开始产生了操作系统的概念，用一个程序来管理打孔卡片阅读器（操作 (operate) 任务 (jobs) 的系统 (system)）。这个程序会在一个打孔卡程序运行完毕后，将这组打孔卡移除，换上另一组的打孔卡，不用人为的更换。

- “批处理系统” = 程序的自动切换 (换卡) + 库函数 API
- Disk Operating Systems (DOS)
  - 操作系统中开始出现 “设备”、“文件（将程序的结果写到卡片上）”、“任务” 等对象和 API





**1960年代的计算机**

1950年代的计算机内存很小，计算机加载一个程序后，所有的内存和运算器都属于这个程序占有，该程序结束了再换下一个程序。而1960年代集成电路、总线出现，有更快、更大的内存，这时可以同时载入多个程序而不用 “换卡” 了，但是是单核CPU。

- 更丰富的 I/O 设备；完善的中断/异常机制
- 虚拟存储出现



**1960年代的程序**

- 更多的高级语言和编译器出现



**1960年代的操作系统**

要管理好内存中的多个程序，一个程序，除了CPU执行时间外，基本都涉及IO时间，当CPU处理时间很快，比如CPU执行程序30秒，然后将数据写入到内存中，接下来需要将数据通过输出设备输出需要5分钟，如果cpu要等待io结束后继续执行该程序，那这时就浪费了CPU。 但是内存中是有多个程序的，那这时就有了切换程序的需求了。

先让A程序在CPU上运行一段时间，然后A开始进行IO了，这时就可以稍微花一点时间，操作系统将A程序的执行过程中的临时数据保存到内存中，然后CPU加载并执行B程序，这样就让cpu被更好的共享了。  当之后重新恢复A程序的执行之前，CPU先做一些恢复工作，然后再继续执行A程序。



1960年代的操作系统能载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的 API。

- 有了进程 (process) 的概念
- 进程在执行 I/O 时，可以将 CPU 让给另一个进程
  - 引入了更多的硬件机制来实现多道程序这一功能
  - 在多个地址空间隔离的程序之间切换
  - 虚拟存储使一个程序出 bug 不会 crash 整个系统
- 操作系统中自然地增加进程管理 API

![image-20230703002221073](C:\Users\dukkha\Desktop\study-notes\计算机基础\images\image-20230703002221073.png)



既然操作系统已经可以在程序之间**切换**，为什么不让它们**定时切换**？

基于中断 (例如时钟) 机制

- 时钟中断：使程序在执行时，异步地插入函数调用
- 由操作系统 (调度策略) 决定是否要切换到另一个程序执行
- Multics (MIT, 1965)
  - 现代操作系统诞生

![image-20230703002149180](C:\Users\dukkha\Desktop\study-notes\计算机基础\images\image-20230703002149180.png)



**1970年代的计算机**

集成电路空前发展，个人电脑兴起，“计算机” 已与今日无大异。

- CISC 指令集；中断、I/O、异常、MMU、网络
- 个人计算机 (PC 机)、超级计算机



**1970年代的程序**

能办到今天的程序能办到的功能。



**1970年代的操作系统**

分时系统走向成熟，UNIX 诞生并走向完善，奠定了现代操作系统的形态。

- 1973: 信号 API、管道 (对象)、grep (应用程序)
- 1983: BSD socket (套接字)
- 1984: procfs (对象)
- UNIX 衍生出的大家族





**今天的操作系统**

通过 “虚拟化” 硬件资源为程序运行提供服务的软件。

空前复杂的系统之一

- 更复杂的处理器和内存
  - 非对称多处理器 (ARM big.LITTLE; Intel P/E-cores)
  - Non-uniform Memory Access (NUMA)
  - 更多的硬件机制 Intel-VT/AMD-V, TrustZone/~~SGX~~, TSX, ...
- 更多的设备和资源
  - 网卡、SSD、GPU、FPGA...
- 复杂的应用需求和应用环境
  - 服务器、个人电脑、智能手机、手表、手环、IoT/微控制器



在理解一个最小，最重要的操作系统内核，使得自己在学完操作系统后，如果真的对操作系统感兴趣，那么自己可以有能力自行深入去学习和研究它。





操作系统服务谁？

- 操作系统服务程序，而程序就是状态机，程序使用内存和寄存器，每执行一条指令，程序中用到的内存和寄存器都可能变化。

- 课程涉及：多线程 Linux 应用程序



(设计/应用视角)操作系统为程序提供什么服务？

- 操作系统 = 对象（文件对象，进程对象，管道对象等） + 操作这些对象的API
- 课程涉及：POSIX + 部分 Linux 特性



(实现/硬件视角) 如何实现操作系统提供的服务？

- 用简单的计算机硬件去实现操作系统中的对象和API
- 操作系统 = C 程序
  - 完成初始化后就成为 interrupt/trap/fault handler（中断处理程序）
- 课程涉及：xv6, 自制迷你操作系统



**怎样学习操作系统？**

- 在互联网上会找资料手动解决问题
- 使用命令行工具
- 写代码，会调试
- 独立完成编程作业即可理解操作系统



课件与阅读资料：http://jyywiki.cn/OS/2022/





## 程序

###  状态机和状态模式

状态机和状态模式都是用于去解决我们的一个状态的流转，它可以清晰地描绘出我们的一个当前状态要触发什么事件，转换到下一个状态后处理什么样的逻辑，我们的开发过程当中可能会经常遇到这种情况。
比如说去做一个商城的页面可能会面临到一些下单，从下单到发货，从发货到配件，那这些都是不同状态的一个流转。那通过状态机实际上是可以很清晰地去描绘出我们的一个整个的一个链路流程。


状态模式作为设计模式当中的一种，它的定义：一个对象内在状态改变时允许改变其行为，那这个对象看起来就像改变了原来的类的中的方法。

<img src="C:\Users\dukkha\Desktop\study-notes\计算机基础\images\image-20230703094812117.png" alt="image-20230703094812117" style="zoom:150%;" />



代码案例：

```java
package org.ming.v1.m1.n2;
import lombok.Data;

public enum State {
    RAIN,
    SUNNY,
    THURSDAY
}

interface IState {
    void handle();
}

class RainState  implements IState{
    @Override
    public void handle() {
        System.out.println("今天下雨， 坐公交车上班吧");
    }
}


@Data
class Worker {
    private String name;
    private State state;
    private IState iState;

    public void oneDay () {
        System.out.println("9：起床");
        if (state == State.RAIN) {
            System.out.println("今天下雨， 坐公交车上班吧");
        } else if (state == State.SUNNY) {
            System.out.println("晴天，骑车上班");
        } else  if (state == State.THURSDAY) {
            System.out.println("今天周四，吃顿肯德基");
        }
        System.out.println("21：下班");
    }

    public void oneDay4MachineModel () {
        System.out.println("9：起床");
        iState.handle();
        System.out.println("21：下班");
    }


    public static void main(String[] args) {
        // 下面是一般ifelse的代码
        Worker worker = new Worker();
        worker.setName("张三");
        worker.setState(State.SUNNY);
        worker.oneDay();
        
        // 下面是策略模式的代码
        System.out.println("===========");
        worker.setIState(new RainState());
        worker.oneDay4MachineModel();
    }

}
```



状态机（State Machine）是一种计算模型，它描述了系统或程序在运行时的各种状态及其之间的转换。它由一组状态、事件和转换组成，其中状态表示系统的某个特定状态，事件表示状态转换的触发条件，转换则表示状态之间的转换关系。

状态机可以用于模拟各种系统，例如计算机程序、自动化控制系统、通信协议等。在编程中，状态机可以被实现为一个状态表或状态图，并且常用于设计和实现有限状态机（Finite State Machine，FSM）或自动机（Automaton）等。

状态机的优点是可以清晰地描述系统的行为，使得代码更加可读、可维护和可扩展。此外，它还可以减少代码中的分支语句，使得代码的可读性更高，同时也可以降低程序出错的概率。



什么是程序？操作系统为程序提供怎样的服务？



**什么是程序？**

在



操作系统：

从功能来区分，有对上和对下之分。

对上的话是面向用户或者应用系统，并为他们提供服务。从用户的角度看，操作系统是一个控制程序，可以控制计算机上面的一些应用软件和程序如何运行，为不同应用程序分配系统资源。另一方面，操作系统还为应用程序提供 I/O，网卡访问等一系列的能力。

对下的话给它管理的应用程序分配硬件资源，管理外设。

![image-20210808155915531](..\typora-user-images\image-20210808155915531.png)

操作系统是一种特殊的软件， 系统软件，它直接面向硬件。一般的应用程序实现的功能其实是操作系统提供的，并不是直接去访问物理资源（各种外设）。而这些外设资源是由操作系统统一协调管理，为一般应用程序提供接口 API，一般应用程序方便的访问这些接口，而不用考虑底层的硬件细节。

操作系统层面的软件有两种不同的对外的接口，Shell 和 kernel 。

![image-20210808161028100](..\typora-user-images\image-20210808161028100.png)

操作系统内部细节：

- CPU
  - CPU 调度
  - 进程与线程管理
- 内存
  - 物理内存管理
  - 虚拟内存管理，它主要是给上层应用提供相对独立且尽可能充足的空间去管理
- 磁盘
  - 文件系统管理
- 中断处理和 I/O，设备驱动
- 网卡
- 声卡
- 显卡
- ......

操作系统的特征：

- 并发，计算机系统中同时存在多个运行的程序，需要 OS 管理和调度哪个程序占用 CPU 去运行。并发：**一段时间**内有多个程序可以运行。 并行：**一个时间点**上有多个程序可以运行

  能并行任务一般要求系统存在多个 CPU。

- 共享，‘同时’共享和互斥共享

- 虚拟

- 异步

## CPU

关于底层细节，适度打开。

计算机需要解决的的最根本的问题：如何表示数字。

CPU 最主要的运算单位：晶体管。

时钟发生器不断通过 CPU 的针脚给 CPU 芯片局部通电和断电。程序需要计算的信号内容通过针脚不断输入 CPU 中，以前手工输入，另一种是将数据提前写好，并存在内存中，让 CPU 自己去读取。

内存的本质是在内部存放一系列的电信号，而这些电信号通过总线和 CPU 连接，CPU 将内存中的 1 和 0 读取后，在自己内部进行计算，这个计算过程需要通过时钟发生器不断的驱动它的通断电来实现。

CPU 一次性能读取 64 位二进制数据的话就是 64 位 CPU 系统。32 位同理。

CPU 只认识高电频低电频（0 与 1），对计算机进行输入就是控制针脚的通断电。最早的计算输入是纸袋机输入。

![image-20210808140613210](..\typora-user-images\image-20210808140613210.png)

## 汇编语言

汇编的本质：机器语言的助记符，本质就是机器语言。

解释与编译：

开发者写了一个程序（C 语言编写），位于硬盘上，需要执行时放在内存中，编译完的代码（.ELE，.EXE 等）直接就是机器语言，CPU 可以直接获取并执行。这就叫编译执行。

对于 Java 程序，在内存中是字节码（ByteCode），它是不能被 CPU 直接执行的，在执行的过程中是读取一条指令，交给 jvm 翻译为机器语言再交给 CPU 去执行的。这就叫解释执行。JVM 就是解释器。

机器语言和 ByteCode 都是用 0101 之类的表示的， 在 java 中 ByteCode 相当于 java 的汇编语言，因为 Java 跨平台。java 的汇编并不和具体的某个操作系统相关，因为 Java 是跨平台的。所以 java 就设计了一种中间格式 ByteCode，同一个指令由不同操作系统下的 Jvm 翻译都是不同的机器语言。

## CPU 基本组成

![image-20210808143352892](..\typora-user-images\image-20210808143352892.png)

**PC（program counter）**：程序计数器，记录存放当前来自内存的指令在内存中的地址（这条指令位于内存中的什么位置）。CPU 要执行下一条指令时，肯定需要知道下一条指令在内存中的位置。CPU 执行完一条指令地址对应的指令后，会切换为下一条指令，下一条指令并不一定是指令地址数组索引加一，因为指令的长度是不固定的，得看当前指令占的字节数。

内存是一块特别大的字节数组。

**Registers**：暂时存储 CPU 计算需要用到的数据（寄存器数量非常多，每个寄存器都有各自的用途），将读进 CPU 的数据先存在寄存器中，不能放在内存中，因为太慢了，而选择放在 CPU 内部。

**ALU（Arithmetic & Logic Unit）**:运算单元

**CU（Control Unit）**：控制单元，对中断信号的控制

**MMU（Memory Management Unit）**：内存管理单元

**cache**

![image-20210808151322196](..\typora-user-images\image-20210808151322196.png)

一核多线程：即一个运算单元对应多组寄存器。平时有一个线程要运行时，该线程相关的数据放在寄存器中，指令存在程序计数器中。

如果 CPU 中只有一组寄存器和 PC（程序计数器），在 thread1 运行中，thread2 线程要运行，就必须将寄存器和 PC 中的 thread1 相关数据取出去放在缓存中，然后将 thread2 的数据放入并执行，当线程 thread2 的运行时间片够了，再将寄存器和 PC 中的 thread2 相关数据取出去放在缓存中，在同样的过程恢复对 thread1 的执行。上面的过程就叫线程切换（context switch）。

<img src="..\typora-user-images\image-20210808153332302.png" alt="image-20210808153332302" style="zoom:200%;" />

补充：

内存中的数据如何给显卡？

CPU 发出指令，控制内存中的数据通过内存直接写给显卡（DMA 机制），并不是说内存中的数据都需要先交给 CPU，再由 CPU 去分发。内存中的数据发送给显卡后，显卡中的缓存区中的数据对应显示器中的像素。显示器自身有一个刷新率（60Hz，120Hz 等），刷新率表述每秒从显卡中读取缓存区数据进行刷新的次数。

GPU 为什么比 CPU 更适合做机器学习？

GPU 比较纯粹，就是做一些计算然后输出到显卡，而 CPU 做的是通用计算，所以 CPU 内部的电路优化是针对通用计算和普通计算的。CPU 对于人工智能所需要的哪些特殊的，大量的，计算类型不一样的计算并没有做优化。GPU 正好更适合于 AI 的算法上的优化。

AI 芯片：指的是在电路底层在设计时就设计为更适合 AI 计算的。

为什么要有缓存？

因为从 CPU 到不同的部件的速度不同。

![image-20210808153455187](..\typora-user-images\image-20210808153455187.png)

缓存的原理：

![image-20210808153641239](..\typora-user-images\image-20210808153641239.png)

![image-20210808153620913](..\typora-user-images\image-20210808153620913.png)

CPU 的乱序执行：CPU 在进行读等待的同时执行指令，能提高效率。

## 前言

- 操作系统级别的项目才是真正巨型的项目
- 内存泄漏，服务进程问题
- 操作系统是所有软件的基础，所有上层软件都要依赖于操作系统提供的各种机制来运行
- 内存、进程、线程、I/O 知识在工作中常用
- 性能调优
- 操作系统内核
- 数据结构与算法
- 架构视野、技术成长
- 理解操作系统内核的本质
- 每个内核组件实现

操作系统的难点：

- 需要有大量的知识储备，大多的课程、学习资料，往往都是根据目前已有的一些操作系统，做局部解读。所以，我们学的时候，前后的知识是无法串联在一起的。结果就会越看越迷惑，不去查吧，看不懂，再去搜索又加重了学习负担。

安排：

1. 计算机组成，如 CPU、MMU、内存和 Cache 等
2. 基本法，即各种同步机制，如信号量与自旋锁
3. 初始化，其中包含初始化 CPU、内存、中断、显示等
4. 建立中间层，内存管理部门、进程管理部门、I/O 管理部门、文件管理部门、通信管理部门
5. 组合中间层为操作系统

![img](https://static001.geekbang.org/resource/image/d6/d9/d68f8a262c1582f04377476f9ed9yyd9.jpg?wh=3145*2404)

![img](https://static001.geekbang.org/resource/image/5f/cf/5fbeyy963478d11db45da0dd3e8effcf.jpg?wh=3245*2265)

1. 写出一个操作系统
2. 深入理解 Linux 操作系统
3. 操作系统架构设计能力
4. 软件编程技巧
5. 辅助职业发展

![img](https://static001.geekbang.org/resource/image/2c/bd/2c6abcd035e5c83cdd7d356eca26b9bd.jpg?wh=6120*6599)

**对于工程师来说，树高叶茂，系于根深，只有不断升级自己的认知，才能让技术之路行稳致远。**

## 程序的运行过程

从高级语言到机器代码再到程序运行。

**程序是如何运行的？**

注重编程基本功和程序开发经验。

对于一段 c 语言写的程序：

HelloWorld.c：

```c
#include "stdio.h"
int main(int argc, char const *argv[])
{
  printf("Hello World!\n");
  return 0;
}
```

计算机硬件是无法直接运行这个 C 语言代码程序的，需要 **C 语言编译器**，把这个代码编译成**具体硬件平台**的二进制代码。再由**具体操作系统建立进程**，把编译生成的二进制文件装进其进程的内存空间中，才能运行。

### 编译过程

使用命令：gcc HelloWorld.c -o HelloWorld 或者 gcc ./HelloWorld.c -o ./HelloWorld，编译上面的代码。

GCC 是完成编译工作的**驱动程序**，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作。

![img](https://static001.geekbang.org/resource/image/f2/4a/f2b10135ed52436888a793327e4d5a4a.jpg?wh=3015*2410)

手动控制以上这个编译流程，从而留下中间文件：

- gcc HelloWorld.c -E -o HelloWorld.i 预处理：加入头文件，替换宏。
- gcc HelloWorld.c -S -c -o HelloWorld.s 编译：包含预处理，将 C 程序转换成汇编程序。
- gcc HelloWorld.c -c -o HelloWorld.o 汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。
- gcc HelloWorld.c -o HelloWorld 链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。

上面准备好了 CPU 将要执行的二进制机器码。

### 硬件执行程序过程

开始程序的装载执行。

#### 图灵机

图灵机：是一个抽象的模型，它是这样的：有一条无限长的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个读头，读头能根据纸带小格子里的信息做相关的操作并能来回移动。

![image-20220826164254509](..\typora-user-images\image-20220826164254509.png)

用图灵机执行一下“1+1=2”的计算，定义读头读到“+”之后，就依次移动读头两次并读取格子中的数据，最后读头计算把结果写入第二个数据的下一个格子里，整个过程如下图：

![image-20220826164408197](..\typora-user-images\image-20220826164408197.png)

#### 冯诺依曼体系结构

实现图灵机。**电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行。**

根据冯诺依曼体系结构构成的计算机，必须具有如下功能：

1. 把程序和数据装入到计算机中；
2. 必须具有长期记住程序、数据的中间结果及最终运算结果的能力；
3. 能完成各种算术、逻辑运算和数据传送等数据加工处理；
4. 根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；
5. 能够按照要求将处理的数据结果显示给用户。

为了完成上述的功能，计算机必须具备五大基本组成部件：

1. 承载数据和程序的输入设备；
2. 记录与存放程序和数据的存储器；
3. 进行数据加工处理的运算器；
4. 控制程序执行的控制器；
5. 显示处理结果的输出设备。

根据冯诺依曼的理论，只要把图灵机的几个部件换成电子设备，就可以变成一个最小核心的电子计算机，如下图：

![image-20220826165744096](..\typora-user-images\image-20220826165744096.png)

读头不再来回移动了，而是靠地址总线寻找对应的“纸带格子”。读取写入数据由数据总线完成，而动作的控制就是控制总线的职责。

#### HelloWorld 程序中有什么

通过 gcc -c -S HelloWorld 得到汇编代码（只能得到其汇编代码）。用 objdump -d HelloWorld 程序，得到 /lesson01/HelloWorld.dump，其中有很多库代码（只需关注 main 函数相关的代码），如下图：

![image-20220826170608042](..\typora-user-images\image-20220826170608042.png)

以上图中，分成四列：第一列为地址；第二列为十六进制，表示真正装入机器中的代码数据；第三列是对应的汇编代码；第四列是相关代码的注释。这是 x86_64 体系的代码，由此可以看出 x86 CPU 是变长指令集。

把这段代码数据装入最小电子计算机，状态如下图：

![image-20220826170947946](..\typora-user-images\image-20220826170947946.png)

现代电子计算机正是通过内存中的信息（指令和数据）做出相应的操作，并通过内存地址的变化，达到程序读取数据，控制程序流程（顺序、跳转对应该图灵机的读头来回移动）的功能。

这和图灵机的核心思想相比，没有根本性的变化。只要配合一些 I/O 设备，让用户输入并显示计算结果给用户，就是一台现代意义的电子计算机。

提问：

**为了实现 C 语言中函数的调用和返回功能，CPU 实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令**，思考一下：call 和 ret 指令在逻辑上执行的操作是怎样的呢？

> 思考题:
>
> 首先假设 CPU 执行指令是按照顺序执行的，那么程序的指令的调用需要考虑几个问题:
>
> 1，call 指令要执行的代码在哪？也就是被调用函数的第一条指令所在的内存地址
>
> 2，被调用函数执行完之后，返回哪个位置继续执行？
>
> 只要解决上面这两个问题，那么函数调用时指令间的跳转就迎刃而解了。
>
> 针对第一个问题，在 gcc 编译完成之后，函数对应的指令序列所在的位置就已经确定了，因此这是编译阶段需要考虑的问题
>
> 第二个问题，在执行完 call 指令的同时，需要将 call 指令下面一条指令的地址保存到栈内存中，同时更新%rsp 寄存器指向的位置，然后就可以开始执行被调函数的指令序列，执行完毕后，由 ret 指令从 rsp 中获取栈顶的 return adress 地址，然后跳转到 call 的下一条指令继续执行。

> call 和 ret 其实是一对相反指令，调用 call 时会将当前 IP 入栈，即 push IP，然后执行跳转即 jmp，而 ret 也是将栈中的 IP 推出写入 IP 寄存器，即 pop IP。
>
> call 指令会把当前的 PC(CS:IP) 寄存器里的下一条指令的地址压栈，然后进行 JMP 跳转指令； ret 指令则把 call 调用时压入的 PC 寄存器里的下一条指令出栈，更新到 PC 寄存器中

王爽的《汇编语言》
