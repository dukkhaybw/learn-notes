# 设计模式

经典的设计模式有 23 种，常用的可能都不到一半。



## 创建型模式

### 单例模式

懒加载的双重检测

饿汉式的双重检测

网上讲解单例模式的文章，但大部分都侧重讲解：**如何来实现一个线程安全的单例**。 各种单例的实现方法，重点搞清楚下面这样几个问题：

1. 为什么要使用单例？

2. 单例存在哪些问题？

3. 单例与静态类的区别？

4. 有何替代的解决方案？

   

#### 为什么使用单例？

单例设计模式（Singleton Design Pattern）：一个类只允许创建一个对象（或者实例），那这个类就是一个单例类。 

为什么需要单例这种设计模式？它能解决哪些问题？

##### 代码示例一：处理资源访问冲突

在这个例子中，自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：

```java
public class Logger {
  private FileWriter writer;
  public Logger() {
    File file = new File("/Users/test/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  public void log(String message) {
    writer.write(mesasge);
  }
}

// Logger类的应用示例：
public class UserController {
  private Logger logger = new Logger();
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    logger.log(username + " logined!");
  }
}

public class OrderController {
  private Logger logger = new Logger();
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    logger.log("Created an order: " + order.toString());
  }
}
```

这段代码存在什么问题？

在上面的代码中，所有的日志都写入到同一个文件 /Users/test/log.txt 中。在 UserController 和 OrderController 中，分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。

为什么会出现互相覆盖？可以这么类比理解。在多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 2，而是只加了 1。同理，这里的 log.txt 文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况。

<img src="D:\learn-notes\计算机基础\设计模式\images\image-20240520212844340.png" alt="image-20240520212844340" style="zoom:200%;" />

解决办法：最先想到的就是通过加锁的方式：给 log() 函数加互斥锁 （Java 中可以通过 synchronized 的关键字），同一时刻只允许一个线程调用执行 log() 函数。具体的代码实现如下所示：

```java
public class Logger {
  private FileWriter writer;
  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  public void log(String message) {
    synchronized(this) {
      writer.write(mesasge);
    }
  }
}
```

但这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。

![image-20240520213143800](D:\learn-notes\计算机基础\设计模式\images\image-20240520213143800.png)

在刚刚的讲解和给出的代码中，故意“隐瞒”了一个事实：给 log() 函数加不加对象级别的锁，其实都没有关系。因为 FileWriter 本身就是线程安全的， 它的内部实现中本身就加了对象级别的锁，因此，在在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。因为不同的 Logger 对象不共享 FileWriter 对象，所以，FileWriter 对象级别的锁也解决不了数据写入互相覆盖的问题。

那该怎么解决这个问题？实际上，要想解决这个问题也不难，只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。具体的代码实现如下所示：

```java
public class Logger {
  private FileWriter writer;
  public Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  public void log(String message) {
    synchronized(Logger.class) { // 类级别的锁
      writer.write(mesasge);
    }
  }
}

```

除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如 Java 中的 BlockingQueue）也可以解决这个问题： 多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。

相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。

将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。

```java
public class Logger {
  private FileWriter writer;
  private static final Logger instance = new Logger();
  private Logger() {
    File file = new File("/Users/wangzheng/log.txt");
    writer = new FileWriter(file, true); //true表示追加写入
  }
  public static Logger getInstance() {
    return instance;
  }
  public void log(String message) {
    writer.write(mesasge);
  }
}

// Logger类的应用示例：
public class UserController {
  public void login(String username, String password) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log(username + " logined!");
  }
}

public class OrderController {
  private Logger logger = new Logger();
  public void create(OrderVo order) {
    // ...省略业务逻辑代码...
    Logger.getInstance().log("Created a order: " + order.toString());
  }
}
```



##### 代码示例二：表示全局唯一类

从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。

比如，配置信息类。在系统中，只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。

再比如，唯一递增 ID 号码生成器，如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以， 应该将 ID 生成器类设计为单例。

```java
import java.util.concurrent.atomic.AtomicLong;

public class IdGenerator {
  // AtomicLong是一个Java并发库中提供的一个原子变量类型,
  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，
  // 比如下面会用到的incrementAndGet().
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance = new IdGenerator();
  
  private IdGenerator() {}
  
  public static IdGenerator getInstance() {
    return instance;
  }
  
  public long getId() {
    return id.incrementAndGet();
  }
}

// IdGenerator使用举例
long id = IdGenerator.getInstance().getId();
```

上面讲到的两个代码实例（Logger、IdGenerator），设计的都并不优雅，还存在一些问题。至于有什么问题以及如何改造，下节详细讲解。



##### 如何实现一个单例？

要实现一个单例，我们需要关注的点无外乎下面几个：

1. 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
2. 考虑对象创建时的线程安全问题；
3. 考虑是否支持延迟加载；
4. 考虑 getInstance() 性能是否高（是否加锁）。

下面的几种单例实现方式是针对 Java 语言语法的，如果你熟悉的是其他语言，不妨对比 Java 的这几种实现方式，自己试着总结一下，利用你熟悉的语言，该如何实现。

几种经典实现方式：

1. **饿汉式**

   在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加 载（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。 具体的代码实现如下所示：

   ```java
   public class IdGenerator {
     private AtomicLong id = new AtomicLong(0);
     private static final IdGenerator instance = new IdGenerator();
     
     private IdGenerator() {}
     
     public static IdGenerator getInstance() {
       return instance;
     }
     
     public long getId() {
       return id.incrementAndGet();
     }
   }
   
   ```

   这种实现方式不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。

   如果初始化耗时长，那最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作， 会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作， 提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。

   如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如 Java 中的 PermGen Space OOM），可以立即去修复。这样也能避免在程序运行一 段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。

   

2. **懒汉式**

   懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码 实现如下所示：

   ```java
   public class IdGenerator {
     private AtomicLong id = new AtomicLong(0);
     private static IdGenerator instance;
     
     private IdGenerator() {}
     
     public static synchronized IdGenerator getInstance() {
       if (instance == null) {
         instance = new IdGenerator();
       }
       return instance;
     }
     
     public long getId() {
       return id.incrementAndGet();
     }
   }
   ```

   不过懒汉式的缺点也很明显，给 getInstance() 这个方法加了一把大锁 （synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用 到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。

   

3. **双重检测**

   饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。

   在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：

   ```java
   public class IdGenerator {
     private AtomicLong id = new AtomicLong(0);
     private static IdGenerator instance;
     
     private IdGenerator() {}
     
     public static IdGenerator getInstance() {
       if (instance == null) {
         synchronized(IdGenerator.class) { // 此处为类级别的锁
           if (instance == null) {
             instance = new IdGenerator();
           }
         }
       }
       return instance;
     }
     
     public long getId() {
       return id.incrementAndGet();
     }
   }
   ```

   网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻 辑），就被另一个线程使用了。

   要解决这个问题，需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才行。实际上，只有很低版本的 Java 才会有这个问题。现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。

   

4. **静态内部类**

   再来看一种比双重检测更加简单的实现方法，那就是利用 Java 的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的？先来看它的代码实现。

   ```java
   public class IdGenerator {
     private AtomicLong id = new AtomicLong(0);
     private IdGenerator() {}
     private static class SingletonHolder{
       private static final IdGenerator instance = new IdGenerator();
     }
     public static IdGenerator getInstance() {
       return SingletonHolder.instance;
     }
     public long getId() {
       return id.incrementAndGet();
     }
   }
   ```

   SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。

   

5. **枚举**

   一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：

   ```java
   public enum IdGenerator {
     INSTANCE;
     private AtomicLong id = new AtomicLong(0);
     public long getId() {
       return id.incrementAndGet();
     }
   }
   
   ```

   

问题：

1. 在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类？ 
2. 在第一个实战案例中，除了讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，是什么？



#### 为什么不推荐使用单例模式？

- 单例这种设计模式存在哪些问题？
- 为什么会被称为反模式？
- 如果不用单例，该如何表示全局唯一类？有何替代的解决方案？



**单例存在哪些问题**

大部分情况下，在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息类、连接池类、ID 生成器类。在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。

1. **单例对 OOP 特性的支持不友好**

   单例这种设计模式对于其中的抽 象、继承、多态都支持得不好。

   ```java
   public class Order {
     public void create(...) {
       //...
       long id = IdGenerator.getInstance().getId();
       //...
     }
   }
   
   public class User {
     public void create(...) {
       // ...
       long id = IdGenerator.getInstance().getId();
       //...
     }
   }
   ```

   IdGenerator 的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，需要修改所有用到 IdGenerator 类的地方，这样代码的改动就会比较大。

   ```java
   public class Order {
     public void create(...) {
       //...
       long id = IdGenerator.getInstance().getId();
       // 需要将上面一行代码，替换为下面一行代码
       long id = OrderIdGenerator.getIntance().getId();
       //...
     }
   }
   public class User {
     public void create(...) {
       // ...
       long id = IdGenerator.getInstance().getId();
       // 需要将上面一行代码，替换为下面一行代码
       long id = UserIdGenerator.getIntance().getId();
     }
   }
   ```

   单例对继承、多态的支持也不友好但支持。从理论上来讲，单例类也可以被继承、也可以实现多态，只是实现起来会非常奇怪，会导致代码的可读性变差。不明白设计意图的人，看到这样的设计， 会觉得莫名其妙。所以，一旦选择将某个类设计成到单例类，也就意味着放弃了继承和多态特性，也就相当于损失了可以应对未来需求变化的扩展性。

   

2. **单例会隐藏类之间的依赖关系**

   代码的可读性非常重要。在阅读代码的时候，希望一眼就能看出类与类之间 的依赖关系，搞清楚这个类依赖了哪些外部类。

   通过构造函数、参数传递等方式声明的类之间的依赖关系，通过查看函数的定义，就能很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。

   

3. **单例对代码的扩展性不友好**

   单例类只能有一个对象实例。如果未来某一天，需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。你可能会说，会有这样的需求吗？既然单例类大部分情况下都用来表示全局类，怎么会需要两个或者多个实例？

   实际上，这样的需求并不少见。拿数据库连接池来举例解释一下。

   在系统设计初期，觉得系统中只应该有一个数据库连接池，这样能方便控制对数据库连接资源的消耗。所以，把数据库连接池类设计成了单例类。但之后发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。

   如果将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，数据库连接池、线程池这类的资源 池，最好还是不要设计成单例类。实际上，一些开源的数据库连接池、线程池也确实没有设 计成单例类。

   

4. **单例对代码的可测试性不友好**

   如果单例类依赖比较重的外部资源，比如 DB， 在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式的使用方式，导致无法实现 mock 替换。

   如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种全局变量，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那在编写单元测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题。

5. **单例不支持有参数的构造函数**

   比如我们创建一个连接池的单例对象，没法通过参数来 指定连接池的大小。针对这个问题，来看下都有哪些解决方案。

   第一种解决思路是：创建完实例之后，再调用 init() 函数传递参数。需要注意的是，在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常。具体的代码实现如下所示：

   ```java
   public class Singleton {
     private static Singleton instance = null;
     private final int paramA;
     private final int paramB;
     private Singleton(int paramA, int paramB) {
       this.paramA = paramA;
       this.paramB = paramB;
     }
     public static Singleton getInstance() {
       if (instance == null) {
         throw new RuntimeException("Run init() first.");
       }
       return instance;
     }
     public synchronized static Singleton init(int paramA, int paramB) {
       if (instance != null){
         throw new RuntimeException("Singleton has been created!");
       }
       instance = new Singleton(paramA, paramB);
       return instance;
     }
   }
   Singleton.init(10, 50); // 先init，再使用
   Singleton singleton = Singleton.getInstance()
   ```

   第二种解决思路是：将参数放到 getIntance() 方法中。具体的代码实现如下所示：

   ```java
   public class Singleton {
     private static Singleton instance = null;
     private final int paramA;
     private final int paramB;
     
     private Singleton(int paramA, int paramB) {
       this.paramA = paramA;
       this.paramB = paramB;
     }
     
     public synchronized static Singleton getInstance(int paramA, int paramB) {
       if (instance == null) {
         instance = new Singleton(paramA, paramB);
       }
       return instance;
     }
   }
   
   Singleton singleton = Singleton.getInstance(10, 50);
   ```

   上面的代码，如果如下两次执行 getInstance() 方法，那获取到的 singleton1 和 signleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户。这个问题如何解决？

   ```java
   Singleton singleton1 = Singleton.getInstance(10, 50);
   Singleton singleton2 = Singleton.getInstance(20, 30);
   ```

   第三种解决思路是：将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一 个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。实际上，这种方式是最值得推荐的。

   ```java
   public class Config {
     public static final int PARAM_A = 123;
     public static fianl int PARAM_B = 245;
   }
   
   public class Singleton {
     private static Singleton instance = null;
     private final int paramA;
     private final int paramB;
     private Singleton() {
       this.paramA = Config.PARAM_A;
       this.paramB = Config.PARAM_B;
     }
     
     public synchronized static Singleton getInstance() {
       if (instance == null) {
         instance = new Singleton();
       }
       return instance;
     }
   }
   ```

   

#### 有何替代解决方案？

业务上有表示全局唯一类的需求，如果不用单例，怎么才能保证这个类的对象全局唯一 呢？

为了保证全局唯一，除了使用单例，还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路。比如，上一节课中讲的 ID 唯一递增生成器的例子，用静态方法实现 一下，就是下面这个样子：

```java
// 静态方法实现方式
public class IdGenerator {
  private static AtomicLong id = new AtomicLong(0);
  public static long getId() {
    return id.incrementAndGet();
  }
}

// 使用举例
long id = IdGenerator.getId();
```

不过，静态方法这种实现思路，并不能解决之前提到的问题。实际上，它比单例更加不灵活，比如，它无法支持延迟加载。再来看看有没有其他办法。实际上，单例除了之前讲到的使用方法之外，还有另外一个种使用方法。具体的代码如下所示：

```java
// 1. 老的使用方式
public demofunction() {
  //...
  long id = IdGenerator.getInstance().getId();
  //...
}
// 2. 新的使用方式：依赖注入
public demofunction(IdGenerator idGenerator) {
  long id = idGenerator.getId();
}

// 外部调用demofunction()的时候，传入idGenerator
IdGenerator idGenerator = IdGenerator.getInsance();
demofunction(idGenerator);
```

基于新的使用方式，将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。

所以，如果要完全解决这些问题，可能要从根上，寻找其他方式来实现全局唯一类。实际上，类对象的全局唯一性可以通过多种不同的方式来保证。既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责，道理是一样的。



问题：

1. 如果项目中已经用了很多单例模式，比如下面这段代码，该如何在尽量减少代码改 动的情况下，通过重构代码来提高代码的可测试性？

   ```java
   public class Demo {
     private UserRepo userRepo; // 通过构造哈函数或IOC容器依赖注入
     public boolean validateCachedUser(long userId) {
       User cachedUser = CacheManager.getInstance().getUser(userId);
       User actualUser = userRepo.getUser(userId);
       // 省略核心逻辑：对比cachedUser和actualUser...
     }
   }
   ```

   

2. 在单例支持参数传递的第二种解决方案中，如果我们两次执行 getInstance(paramA, paramB) 方法，第二次传递进去的参数是不生效的，而构建的过程也没有给与提示，这样 就会误导用户。这个问题如何解决？
   ```java
   Singleton singleton1 = Singleton.getInstance(10, 50);
   Singleton singleton2 = Singleton.getInstance(20, 30);
   ```








### 工厂模式

不建议随意使用工厂模式来创建对象。Factory Design Pattern

工厂模式细分：

1. 简单工厂
2. 工厂方法
3. 抽象工厂

**什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处？**



#### 简单工厂（Simple Factory）

例子，在下面这段代码中，根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。

```java
public class RuleConfigSource {
    
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parser = new PropertiesRuleConfigParser();
    } else {
      throw new InvalidRuleConfigException(
        "Rule config file format is not supported: " + ruleConfigFilePath
      );
    }
    
    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }
    
  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

```

上面代码的特点：

- 有很多if else分支情况
- 每种分支下需要创建不同的类的实例对象
- 创建解析对象的代码逻辑 和 加载配置文件的代码逻辑耦合

为了让代码逻辑更加清晰，可读性更好，要善于将功能独立的代码块封装成函数。按照这个设计思路，可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数。

```java
public RuleConfig load(String ruleConfigFilePath) {
  String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
  
  IRuleConfigParser parser = createParser(ruleConfigFileExtension);
  
  if (parser == null) {
    throw new InvalidRuleConfigException(
      "Rule config file format is not supported: " + ruleConfigFilePath);
  }
  
  String configText = "";
  //从ruleConfigFilePath文件中读取配置文本到configText中
  RuleConfig ruleConfig = parser.parse(configText);
  return ruleConfig;
}

private String getFileExtension(String filePath) {
  //...解析文件名获取扩展名，比如rule.json，返回json
  return "json";
}

private IRuleConfigParser createParser(String configFormat) {
  IRuleConfigParser parser = null;
  if ("json".equalsIgnoreCase(configFormat)) {
    parser = new JsonRuleConfigParser();
  } else if ("xml".equalsIgnoreCase(configFormat)) {
    parser = new XmlRuleConfigParser();
  } else if ("yaml".equalsIgnoreCase(configFormat)) {
    parser = new YamlRuleConfigParser();
  } else if ("properties".equalsIgnoreCase(configFormat)) {
    parser = new PropertiesRuleConfigParser();
  }
  return parser;
}
```

为了让类的职责更加单一、代码更加清晰，还可以进一步将 createParser() 函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是简单工厂模式类。具体的代码如下所示：

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
      
    IRuleConfigParser parser =      RuleConfigParserFactory.createParser(ruleConfigFileExtension);
      
    if (parser == null) {
      throw new InvalidRuleConfigException(
        "Rule config file format is not supported: " + ruleConfigFilePath);
    }
      
    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }
    
  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

public class RuleConfigParserFactory {
  public static IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(configFormat)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(configFormat)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(configFormat)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(configFormat)) {
      parser = new PropertiesRuleConfigParser();
    }
    return parser;
  }
}
```

工厂模式中有关命名上的实践：

- 工厂类一般常用Factory作为结尾
- 工厂类创建对象的方法一般以create开头，还有别的叫法：getInstance，createInstance，newInstance



实际上，如果 if 分支并不是很多也不用考虑后续扩展性的问题时，代码中有 if 分支也是完全可以接受的。应用多态或设计模式来替代 if 分支判断逻辑，也是有成本的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。



在上面的代码实现中，每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，为了节省内存和对象创建的时间，可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，从缓存中取出 parser 对象直接使用。

```java
public class RuleConfigParserFactory {
  private static final Map<String, RuleConfigParser> cachedParsers = new  HashMap<>();
    
  static {
    cachedParsers.put("json", new JsonRuleConfigParser());
    cachedParsers.put("xml", new XmlRuleConfigParser());
    cachedParsers.put("yaml", new YamlRuleConfigParser());
    cachedParsers.put("properties", new PropertiesRuleConfigParser());
  }
    
  public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
      return null;//返回null还是IllegalArgumentException全凭你自己说了算
    }
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
  }
    
}
```

上面的简单工厂方法的实现方式，如果后续要新增新的parser，那就需要改动到RuleConfigParserFactory的代码，不能很好的做到开闭原则。但如果需求功能稳定，那偶尔改一下RuleConfigParserFactory是可以接受的。



#### 工厂方法（Factory Method）

如果非得要将 if 分支逻辑去掉，比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：

```java
// 接口类
public interface IRuleConfigParserFactory {
  IRuleConfigParser createParser();
}

// 具体实现类
public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new JsonRuleConfigParser();
  }
}
public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new XmlRuleConfigParser();
  }
}
public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new YamlRuleConfigParser();
  }
}

public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory{
  @Override
  public IRuleConfigParser createParser() {
    return new PropertiesRuleConfigParser();
  }
}
```

这就是工厂方法模式的典型代码实现。当新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模式比起简单工厂模式更加符合开闭原则。

但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。如何用这些工厂类来实现 RuleConfigSource 的 load() 函数。具体的代码如下所示：

```java
public class RuleConfigSource {
    
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
      
      // 根据不同的条件创建不同的工厂类的实例对象
    IRuleConfigParserFactory parserFactory = null;
    if ("json".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new JsonRuleConfigParserFactory();
    } else if ("xml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new XmlRuleConfigParserFactory();
    } else if ("yaml".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new YamlRuleConfigParserFactory();
    } else if ("properties".equalsIgnoreCase(ruleConfigFileExtension)) {
      parserFactory = new PropertiesRuleConfigParserFactory();
    } else {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
      // 根据工厂类的实例对象的方法创建具体的解析对象
    IRuleConfigParser parser = parserFactory.createParser();
      
    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }
    
  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}
```

上面的代码实现，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题？

可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

```java
public class RuleConfigSource {
    
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
      
    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
      
    if (parserFactory == null) {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
      
    IRuleConfigParser parser = parserFactory.createParser();
      
    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }
    
  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();
    
  static {
    cachedFactories.put("json", new JsonRuleConfigParserFactory());
    cachedFactories.put("xml", new XmlRuleConfigParserFactory());
    cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
    cachedFactories.put("properties", new PropertiesRuleConfigParserFactory())
  }
    
  public static IRuleConfigParserFactory getParserFactory(String type) {
    if (type == null || type.isEmpty()) {
      return null;
    }
    IRuleConfigParserFactory parserFactory = cachedFactories.get(type..toLowerCase());
    return parserFactory;
  }
}
```

当需要添加新的规则配置解析器的时候，只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。

实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，每个 Factory 类只是做简单的 new 操作，功能非常单 薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式 简单好用，比工方法厂模式更加合适。



**那什么时候该用工厂方法模式，而非简单工厂模式呢？**

之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，完全没必要将它拆分成单独的函数或者类。

**基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候**，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。

除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果还想避免烦人的 if-else 分支逻辑，这个时候，就推荐使用工厂方法模式。



#### 抽象工厂（Abstract Factory）

该模式的应用场景较为特殊，不常用。

在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析 器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方 式，比如，既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类。

```text
针对规则配置的解析器：基于接口IRuleConfigParser
JsonRuleConfigParser
XmlRuleConfigParser
YamlRuleConfigParser
PropertiesRuleConfigParser

针对系统配置的解析器：基于接口ISystemConfigParser
JsonSystemConfigParser
XmlSystemConfigParser
YamlSystemConfigParser
PropertiesSystemConfigParser
```

针对这种特殊的场景，如果还是继续用工厂方法来实现的话，要针对每个 parser 都编写一个工厂类，也就是要编写 8 个工厂类。如果未来还需要增加针对业务配置的解析器（比如 IBizConfigParser），那就要再对应地增加 4 个工厂类。而过多的类也会让系统难维护。这个问题该怎么解决？

抽象工厂就是针对这种非常特殊的场景而诞生的。可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：

```java
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();
    ISystemConfigParser createSystemParser();
    //此处可以扩展新的parser类型，比如IBizConfigParser
}

public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new JsonRuleConfigParser();
    }
    @Override
    public ISystemConfigParser createSystemParser() {
        return new JsonSystemConfigParser();
    }
}
public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new XmlRuleConfigParser();

    }
    @Override
    public ISystemConfigParser createSystemParser() {
        return new XmlSystemConfigParser();
    }
}

// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码
```



**总结**

当创建对象的逻辑比较复杂，就可以考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。创建逻辑比较复杂的情况：

1. 类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中
2. 尽管不需要根据不同的类型创建不同的对象，但是，**单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作**。在这种情况下，也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中



对于第一种情况，当每个对象的创建逻辑都比较简单的时候，推荐使用简单工厂模式，将 多个对象的创建逻辑放到一个工厂类中。

当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。

同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，建议使用工厂方法模式。

除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过 new 来创建对象就可以了，不需要使用工厂模式。

工厂模式的作用无外乎下面这四个，这也是判断要不要使用工厂模式的最本质的参考标准：

- 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
- 代码复用：创建代码抽离到独立的工厂类之后可以复用
- 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
- 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁



**问题**

前面的简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。 之所以叫静态工厂方法模式，是因为前面的代码中创建对象的方法是静态的。那为什么要设置成 静态的？设置成静态的，在使用的时候，是否会影响到代码的可测试性？





### 基于工厂模式实现依赖注入框架

当创建对象是有繁琐的逻辑时，一般会选择使用工厂模式，来封装对象复杂的创建过程，将对象的创建和使用分离，让代码更加清晰。

**那创建一个对象常见的繁琐逻辑有：**

1. 创建对象的过程涉及复杂的 if-else 分支判断
2. 对象创建需要组装多个其他类对象或者需要复杂的初始化过程
3. 创建对象时需要进行依赖注入

第三种情况常见于依赖注入框架，或者叫依赖注入容器 （Dependency Injection Container），简称 DI 容器。

问题：

- DI 容器跟工厂模式又有何区别和联系？
- DI 容器的核心功能有哪些，以及如何实现一个简单的 DI 容器？



#### 工厂模式和 DI 容器有何区别？

DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责**在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪 些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。**正是因为它持有一堆对象，所以这个框架才被称为“容器”。

DI 容器相对于工厂模式的例子来说，它处理的是更大的对象创建工程。工厂模式中，一个工厂类只负责某个类的对象或者某一组相关类的对象（继承自同一抽象类或者接口的子类，抽象工厂模式）的创建，而 DI 容器负责的是整个应用中所有类的对象的创建。

此外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。



#### DI 容器的核心功能

- 配置解析
- 对象创建
- 对象生命周期管理



**配置解析**

工厂模式中，工厂类要创建哪个类的对象是事先确定好的，是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。所以，需要通过配置形式，让应用告知 DI 容器要创建哪些对象。

将需要由 DI 容器来创建的类的对象和创建类的对象的必要信息（使用哪个构造函数以及对 应的构造函数参数都是什么等），放到配置文件中。容器读取配置文件，根据配置文件提 供的信息来创建对象。

示例：一个典型的 Spring 容器的配置文件。Spring 容器读取配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：rateLimiter 依 赖 redisCounter。

```java
public class RateLimiter {
    private RedisCounter redisCounter;
    public RateLimiter(RedisCounter redisCounter) {
        this.redisCounter = redisCounter;
    }
    public void test() {
        System.out.println("Hello World!");
    }
    //...
}
public class RedisCounter {
    private String ipAddress;
    private int port;
    public RedisCounter(String ipAddress, int port) {
        this.ipAddress = ipAddress;
        this.port = port;
    }
    //...
}
```

配置文件beans.xml：
```xml
<beans>
    <bean id="rateLimiter" class="com.xzg.RateLimiter">
    	<constructor-arg ref="redisCounter"/>
    </bean>
    <bean id="redisCounter" class="com.xzg.redisCounter">
        <constructor-arg type="String" value="127.0.0.1">
        <constructor-arg type="int" value=1234>
    </bean>
</beans>
```



**对象创建**

在 DI 容器中，如果给每个类都对应编写一个工厂类，那项目中类的个数会成倍增加， 这会增加代码的维护成本。解决这个问题只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 BeansFactory。

如果要创建的类对象非常多，BeansFactory 中的代码会不会线性膨胀（代码量跟创建对象的个数成正比）？实际上并不会，在 DI 容器的具体实现时，通过“反射”机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。所以，不管是创建一个对象还是十个对象， BeansFactory 工厂类代码都是一样的。



**生命周期管理**

简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。

在 Spring 框架中，可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。

还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazyinit=false，对象在应用启动的时候就事先创建好。

还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对 象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之 前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数 据库连接池、关闭文件。



#### 实现 DI 容器

用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：

- 配置文件解析
- 根据配置文件通过“反射”语法来创建对象



##### 最小原型设计

只实现一个 DI 容器的最小原型。像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了简化代码实现，重点讲解原理，在最小原型中，只支持下面配置文件中涉及的配置语法。

配置文件beans.xml:

```xml
<beans>
     <bean id="rateLimiter" class="com.xzg.RateLimiter">
     	<constructor-arg ref="redisCounter"/>
     </bean>
     <bean id="redisCounter" class="com.xzg.redisCounter" scope="singleton" lazy-init="true">
         <constructor-arg type="String" value="127.0.0.1">
         <constructor-arg type="int" value=1234>
     </bean>
</bean
```



最小原型的使用方式跟 Spring 框架类似，示例代码如下所示：

```java
public class Demo {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new  ClassPathXmlApplicationContext( "beans.xml");
        RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean("rateLimiter");
        rateLimiter.test();
        //...
    }
}
```



##### 提供执行入口

面向对象设计的最后一步是：组装类并提供执行入口。在这里，执行入口就是一组暴露给外部使用的接口和类。

通过最小原型使用示例代码，可以看出，执行入口主要包含两部分： ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类。两个类具体实现如下所示：

```java
// 接口
public interface ApplicationContext {
  Object getBean(String beanId);
}

public class ClassPathXmlApplicationContext implements ApplicationContext {
  private BeansFactory beansFactory;
  private BeanConfigParser beanConfigParser;

  public ClassPathXmlApplicationContext(String configLocation) {
    this.beansFactory = new BeansFactory();
    this.beanConfigParser = new XmlBeanConfigParser();
    loadBeanDefinitions(configLocation);
  }
  
  private void loadBeanDefinitions(String configLocation) {
    InputStream in = null;
    try {
      in = this.getClass().getResourceAsStream("/" + configLocation);
      if (in == null) {
        throw new RuntimeException("Can not find config file: " + configLocation);
      }
      List<BeanDefinition> beanDefinitions = beanConfigParser.parse(in);
      beansFactory.addBeanDefinitions(beanDefinitions);
    } finally {
      if (in != null) {
        try {
          in.close();
        } catch (IOException e) {
          // TODO: log error
        }
      }
    }
  }
  @Override
  public Object getBean(String beanId) {
    return beansFactory.getBean(beanId);
  }
}
```



从上面的代码中，可以看出，ClassPathXmlApplicationContext 负责组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程：从 classpath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后， BeansFactory 根据 BeanDefinition 来创建对象。



##### 配置文件解析

配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责 将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象。

配置文件的解析比较繁琐，不是重点，所以这里只给出两个类的大致设计思路，并未给出具体的实现代码。

```java
public interface BeanConfigParser {
  List<BeanDefinition> parse(InputStream inputStream);
  List<BeanDefinition> parse(String configContent);
}

public class XmlBeanConfigParser implements BeanConfigParser {
  @Override
  public List<BeanDefinition> parse(InputStream inputStream) {
    String content = null;
    // TODO:...
    return parse(content);
  }
  @Override
  public List<BeanDefinition> parse(String configContent) {
    List<BeanDefinition> beanDefinitions = new ArrayList<>();
    // TODO:...
    return beanDefinitions;
  }
}

public class BeanDefinition {
  private String id;
  private String className;
  private List<ConstructorArg> constructorArgs = new ArrayList<>();
  private Scope scope = Scope.SINGLETON;
  private boolean lazyInit = false;
  // 省略必要的getter/setter/constructors
  public boolean isSingleton() {
    return scope.equals(Scope.SINGLETON);
  }
  public static enum Scope {
    SINGLETON,
    PROTOTYPE
  }
  public static class ConstructorArg {
    private boolean isRef;
    private Class type;
    private Object arg;
    // 省略必要的getter/setter/constructors
  }
}
```



##### 核心工厂类设计

BeansFactory 是如何设计和实现的。这也是这个 DI 容器最核心的 一个类了。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。

如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。

实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的反射语法：一种动态加 载类和创建对象的机制。JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。 但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那这部分工作就没法让 JVM 自动完成了，需要利用 Java 提供的反射语法自己去编写代码。

```java
public class BeansFactory {
  private ConcurrentHashMap<String, Object> singletonObjects = new ConcurrentHashMap<>();
  
  private ConcurrentHashMap<String, BeanDefinition> beanDefinitions = new ConcurrentHashMap<>();
  
  public void addBeanDefinitions(List<BeanDefinition> beanDefinitionList) {
    for (BeanDefinition beanDefinition : beanDefinitionList) {
      this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition)
    }
    for (BeanDefinition beanDefinition : beanDefinitionList) {
      if (beanDefinition.isLazyInit() == false && beanDefinition.isSingleton()){
        createBean(beanDefinition);
      }
    }
  }

  public Object getBean(String beanId) {
    BeanDefinition beanDefinition = beanDefinitions.get(beanId);
    if (beanDefinition == null) {
      throw new NoSuchBeanDefinitionException("Bean is not defined: " + beanId);
    }
    return createBean(beanDefinition);
  }

  @VisibleForTesting
  protected Object createBean(BeanDefinition beanDefinition) {
    if (beanDefinition.isSingleton() && singletonObjects.contains(beanDefinition.getId())){
      return singletonObjects.get(beanDefinition.getId());
    }
    Object bean = null;
    try {
      Class beanClass = Class.forName(beanDefinition.getClassName());
      List<BeanDefinition.ConstructorArg> args = beanDefinition.getConstructorArgs();
      if (args.isEmpty()) {
        bean = beanClass.newInstance();
      } else {
        Class[] argClasses = new Class[args.size()];
        Object[] argObjects = new Object[args.size()];
        for (int i = 0; i < args.size(); ++i) {
          BeanDefinition.ConstructorArg arg = args.get(i);
          if (!arg.getIsRef()) {
            argClasses[i] = arg.getType();
            argObjects[i] = arg.getArg();
          } else {
            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());
            if (refBeanDefinition == null) {
              throw new NoSuchBeanDefinitionException("Bean is not defined: " + arg.getArg());
            }
            argClasses[i] = Class.forName(refBeanDefinition.getClassName());
            argObjects[i] = createBean(refBeanDefinition);
          }
        }
        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);
      }
    } catch (ClassNotFoundException | IllegalAccessException
             | InstantiationException | NoSuchMethodException | InvocationTargetException e){
      throw new BeanCreationFailureException("", e);
    }
    if (bean != null && beanDefinition.isSingleton()) {
      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);
      return singletonObjects.get(beanDefinition.getId());
    }
    return bean;
  }
}
```



问题：BeansFactory 类中的 createBean() 函数是一个递归函数。当构造函数的参数是 ref 类型 时，会递归地创建 ref 属性指向的对象。如果在配置文件中错误地配置了对象之间的依 赖关系，导致存在循环依赖，那 BeansFactory 的 createBean() 函数是否会出现堆栈溢出？又该如何解决这个问题？



React源码中使用了工厂模式来创建对象。工厂模式是一种创建对象的设计模式，它定义了一个创建对象的接口，但让子类决定实例化哪个类。React使用工厂模式来抽象和创建不同类型的对象，尤其是在组件和元素的创建过程中。

以下是一些常见的使用工厂模式的例子：

1. **React.createElement**

在React中，`React.createElement` 函数就是一种工厂方法，它用来创建React元素（React Element）。该函数接收组件类型、props和子元素等参数，返回一个新的React元素对象。这个过程本质上是工厂模式的一种应用：

```js
function createElement(type, props, ...children) {
  // 返回一个React元素
  return {
    type,
    props: { ...props, children },
    key: null,
    ref: null,
    _owner: null
  };
}
```

在这里，`createElement` 函数根据传入的参数返回一个新的React元素对象，类似于一个工厂方法，动态创建不同类型的元素。

2. **React Fiber架构中的工厂方法**

React的Fiber架构中，也有许多地方使用工厂方法来创建不同类型的“fiber”对象（React内部用来表示组件和节点的单元），这些工厂方法帮助React高效地管理渲染过程。不同类型的fiber对象（例如函数组件、类组件、DOM节点等）通过工厂方法来创建。

例如，在Fiber中，对于不同类型的组件会使用不同的创建工厂方法：

```js
function createFiberFromTypeAndProps(type, props, key, ref) {
  if (typeof type === 'function') {
    return createFiberFromFunctionComponent(type, props, key, ref);
  } else if (typeof type === 'string') {
    return createFiberFromHostComponent(type, props, key, ref);
  }
  // 其他类型处理
}
```

这种模式使得React能够根据不同的组件类型灵活地创建相应的fiber对象，确保渲染过程的高效和一致。

3. **React组件的内部实现**

在React的内部实现中，对于每个组件实例（例如类组件或函数组件），都会使用工厂方法来创建该组件的实例或状态对象。特别是在使用`React.createContext`、`useState`、`useReducer`等钩子时，React会根据需要创建相应的状态管理对象或上下文对象。

**总结**

React源码中确实使用了工厂模式，特别是在元素、组件实例、fiber对象等的创建过程中。工厂模式帮助React灵活且高效地创建不同类型的对象，从而实现了组件的高性能渲染和状态管理。



### 建造者模式

创建型设计模式，Builder 模式，翻译为建造者模式或者构建者模式。

问题：

- 直接使用构造函数或者配合 set 方法就能创建对象，为什么还需要建造者模式来创建？

- 建造者模式和工厂模式都可以创建对象，那它们两个的区别在哪里？

  

#### **为什么需要建造者模式？**

最常见的创建一个对象的方式：使用 new 关键字调用类的构造函数。

什么情况下这种方式就不适用了，就需要采用建造者模式来创建对象？

设计面试题：需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，可以简单理解为线程池、连接池、对象池等。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请编写代码实现这个 ResourcePoolConfig 类。

配置类的需求：

![image-20250103232416903](D:\learn-notes\计算机基础\设计模式\images\image-20250103232416903.png)

最常见、最容易想到的实现思路如下代码所示。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值。

```java
public class ResourcePoolConfig {
  private static final int DEFAULT_MAX_TOTAL = 8;
  private static final int DEFAULT_MAX_IDLE = 8;
  private static final int DEFAULT_MIN_IDLE = 0;

  private String name;
  private int maxTotal = DEFAULT_MAX_TOTAL;
  private int maxIdle = DEFAULT_MAX_IDLE;
  private int minIdle = DEFAULT_MIN_IDLE;

  public ResourcePoolConfig(String name, Integer maxTotal, Integer maxIdle, Integer minIdle){
    if (StringUtils.isBlank(name)) {
      throw new IllegalArgumentException("name should not be empty.");
    }
    
    this.name = name;
    if (maxTotal != null) {
      if (maxTotal <= 0) {
        throw new IllegalArgumentException("maxTotal should be positive.");
      }
      this.maxTotal = maxTotal;
    }
    
    if (maxIdle != null) {
      if (maxIdle < 0) {
        throw new IllegalArgumentException("maxIdle should not be negative.");
      }
      this.maxIdle = maxIdle;
    }
    
    if (minIdle != null) {
      if (minIdle < 0) {
        throw new IllegalArgumentException("minIdle should not be negative.");
      }
      this.minIdle = minIdle;
    }
  }
  //...省略getter方法...
}

```

上面的代码中，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数， 参数的个数不多。但是，**如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续 沿用现在的设计思路，构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差。**在使用构造函数的时候，就容易搞错各参数的顺序，传递进错误的参数值，导致非常隐蔽的 bug。

```java
// 参数太多，导致可读性差、参数可能传递错误
ResourcePoolConfig config = new ResourcePoolConfig("dbconnectionpool", 16, null,8,null,false,true,10,20,false,true);
```

解决这个问题的办法：就是用 set() 函数来给成员变量赋值，以替代冗长的构造函数。代码具体如下所示。其中，配置项 name 是必填的，所以把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以通过 set() 函数来设置，让使用者自主选择填写或者不填写。

```java
public class ResourcePoolConfig {
  private static final int DEFAULT_MAX_TOTAL = 8;
  private static final int DEFAULT_MAX_IDLE = 8;
  private static final int DEFAULT_MIN_IDLE = 0;
  
  private String name;
  private int maxTotal = DEFAULT_MAX_TOTAL;
  private int maxIdle = DEFAULT_MAX_IDLE;
  private int minIdle = DEFAULT_MIN_IDLE;
  
  public ResourcePoolConfig(String name) {
    if (StringUtils.isBlank(name)) {
      throw new IllegalArgumentException("name should not be empty.");
    }
    this.name = name;
  }
  
  public void setMaxTotal(int maxTotal) {
    if (maxTotal <= 0) {
      throw new IllegalArgumentException("maxTotal should be positive.");
    }
    this.maxTotal = maxTotal;
  }
  
  public void setMaxIdle(int maxIdle) {
    if (maxIdle < 0) {
      throw new IllegalArgumentException("maxIdle should not be negative.");
    }
    this.maxIdle = maxIdle;
  }
  
  public void setMinIdle(int minIdle) {
    if (minIdle < 0) {
      throw new IllegalArgumentException("minIdle should not be negative.");
    }
    this.minIdle = minIdle;
  }
  //...省略getter方法...
}
```

上面新的 ResourcePoolConfig 类的使用。没有了冗长的函数调用和参数列表，代码在可读性和易用性上提高了很多。

```java
// ResourcePoolConfig使用举例
ResourcePoolConfig config = new ResourcePoolConfig("dbconnectionpool");
config.setMaxTotal(16);
config.setMaxIdle(8);
```

至此，仍然没有用到建造者模式，通过构造函数设置必填项，通过 set() 方法设置可选配置项，就能实现设计需求。如果把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了。

1. 如果必填的配置项有很多，把这些必填配置项都放到构造函数中设置，那构 造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了。
2. 假设配置项之间有一定的依赖关系，比如，如果用户设置了 maxTotal、 maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约 束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了。
3. 如果希望 ResourcePoolConfig 类对象是不可变对象，也就是说，对象在创建好之 后，就不能再修改内部的属性值。要实现这个功能，就不能在ResourcePoolConfig 类中暴露 set() 方法。

而建造者模式就能解决上述问题。



#### 建造者模式代码

可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，把 ResourcePoolConfig 的构造函数改为 private 私有权限。 这样就只能通过建造者来创建 ResourcePoolConfig 类对象。并且， ResourcePoolConfig 没有提供任何 set() 方法，这样创建出来的对象就是不可变对象了。

用**建造者模式**重新实现了上面的需求，具体的代码如下所示：

```java
public class ResourcePoolConfig {
  private String name;
  private int maxTotal;
  private int maxIdle;
  private int minIdle;
  
  private ResourcePoolConfig(Builder builder) {
    this.name = builder.name;
    this.maxTotal = builder.maxTotal;
    this.maxIdle = builder.maxIdle;
    this.minIdle = builder.minIdle;
  }
  
  //...省略getter方法...
  //将Builder类设计成了ResourcePoolConfig的内部类。
  //也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
  public static class Builder {
    private static final int DEFAULT_MAX_TOTAL = 8;
    private static final int DEFAULT_MAX_IDLE = 8;
    private static final int DEFAULT_MIN_IDLE = 0;
    
    private String name;
    private int maxTotal = DEFAULT_MAX_TOTAL;
    private int maxIdle = DEFAULT_MAX_IDLE;
    private int minIdle = DEFAULT_MIN_IDLE;
    
    public ResourcePoolConfig build() {
      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
      if (StringUtils.isBlank(name)) {
        throw new IllegalArgumentException("...");
      }
      if (maxIdle > maxTotal) {
        throw new IllegalArgumentException("...");
      }
      if (minIdle > maxTotal || minIdle > maxIdle) {
        throw new IllegalArgumentException("...");
      }
      return new ResourcePoolConfig(this);
    }
    
    public Builder setName(String name) {
      if (StringUtils.isBlank(name)) {
        throw new IllegalArgumentException("...");
      }
      this.name = name;
      return this;
    }
    public Builder setMaxTotal(int maxTotal) {

      if (maxTotal <= 0) {
        throw new IllegalArgumentException("...");
      }
      this.maxTotal = maxTotal;
      return this;
    }
    public Builder setMaxIdle(int maxIdle) {
      if (maxIdle < 0) {
        throw new IllegalArgumentException("...");
      }
      this.maxIdle = maxIdle;
      return this;
    }
    public Builder setMinIdle(int minIdle) {
      if (minIdle < 0) {
        throw new IllegalArgumentException("...");
      }
      this.minIdle = minIdle;
      return this;
    }
  }
}

// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
ResourcePoolConfig config = new ResourcePoolConfig.Builder()
  .setName("dbconnectionpool")
  .setMaxTotal(16)
  .setMaxIdle(10)
  .setMinIdle(12)
  .build()
```

实际上，使用建造者模式创建对象，还能避免对象存在无效状态。再举个例子解释一下。 比如定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态。具体代码如下所示

```java
Rectangle r = new Rectange(); // r is invalid
r.setWidth(2); // r is invalid
r.setHeight(3); // r is vali
```

假设 `Rectangle` 类是一个长方形类，它有 `setWidth(int)` 和 `setHeight(int)` 方法。这些方法是用来设置长方形的宽度和高度的。但问题在于对象 `r` 是通过无参数构造方法（`new Rectangle()`）创建的，且此时没有提供任何参数来初始化对象的状态。也就是说，`Rectangle` 对象 `r` 会被创建，但它的 `width` 和 `height` 都可能没有被正确初始化。

**无效状态： ** 是指对象在某一时刻处于一个不一致或者**不完整**的状态，这通常会导致该对象不能正常使用。在这个例子中，`Rectangle` 对象的状态并没有完全确定，特别是在通过 setter 方法 `setWidth()` 和 `setHeight()` 设置属性之前。具体来说：

- 如果 `Rectangle` 类的 `width` 和 `height` 在构造时没有被初始化，那么在调用 `setWidth(2)` 后，`width` 会被设置为 2，但 `height` 仍然是一个未初始化的值（可能是 `0` 或 `null`，具体取决于类的实现）。此时，`r` 对象的状态可能是不一致的，因为一个维度已被设置，另一个维度没有。
- 如果 `Rectangle` 类有某些业务逻辑或约束（比如 `width` 和 `height` 必须在同一时间设置，才能形成一个有效的长方形），那么在单独调用 `setWidth(2)` 后，`r` 可能处于一个不合理的状态（例如一个只有宽度而没有高度的长方形）。



为了避免这种无效状态的存在，就需要使用构造函数一次性初始化好所有的成员变量。 如果构造函数参数过多，就需要考虑使用建造者模式，先设置建造者的变量，然后再一次性地创建对象，让对象一直处于有效状态。

实际上，如果并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变 的。比如，对象只是用来映射数据库读出来的数据，那直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。





#### 与工厂模式区别

建造者模式是让建造者类来负责对象的创建工作。

工厂模式是由工厂类来负责对象创建的工作。



工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象。

类比：顾客走进一家餐馆点餐，利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。 

实际上，也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，需要知道的是，每个模式为什么这么设计，能解决什么问题。只有了解了这些最本质的东西，才能不生搬硬套，才能灵活应用。



问题：在下面的 ConstructorArg 类中，当 isRef 为 true 的时候，arg 表示 String 类型的 refBeanId，type 不需要设置；当 isRef 为 false 的时候，arg、type 都需要设置。请根据 这个需求，完善 ConstructorArg 类。

```java
public class ConstructorArg {
  private boolean isRef;
  private Class type;
  private Object arg;
  // TODO: 待完善...
}
```

最死板的写法：

```java
public class ConstructorArg {

  private Object arg;   // 用于存放参数的值
  private Class<?> type; // 用于存放参数类型
  private boolean isRef; // 用于指示是否为引用

  // 构造器1：用于引用类型参数
  public ConstructorArg(String refBeanId) {
    this.arg = refBeanId;  // 赋值 refBeanId
    this.type = null;      // 不需要设置 type
    this.isRef = true;     // 标记为引用类型
  }

  // 构造器2：用于实际值参数
  public ConstructorArg(Object arg, Class<?> type) {
    if (arg == null || type == null) {
      throw new IllegalArgumentException("Both arg and type must be provided when isRef is false.");
    }
    this.arg = arg;        // 赋值实际的参数值
    this.type = type;      // 赋值参数类型
    this.isRef = false;    // 标记为非引用类型
  }

  // Getter 和 Setter 方法

  public Object getArg() {
    return arg;
  }

  public void setArg(Object arg) {
    if (!isRef && type == null) {
      throw new IllegalArgumentException("Type must be set when isRef is false.");
    }
    this.arg = arg;
  }

  public Class<?> getType() {
    return type;
  }

  public void setType(Class<?> type) {
    if (!isRef && arg == null) {
      throw new IllegalArgumentException("Argument must be set when isRef is false.");
    }
    this.type = type;
  }

  public boolean isRef() {
    return isRef;
  }

  public void setRef(boolean isRef) {
    this.isRef = isRef;
  }
}

```

使用：

```java
public class Main {
  public static void main(String[] args) {
    // 1. 当是引用类型时，使用 refBeanId
    ConstructorArg refArg = new ConstructorArg("someBeanId");
    System.out.println(refArg);  // ConstructorArg{arg=someBeanId, type=null, isRef=true}

    // 2. 当是实际值时，使用 arg 和 type
    ConstructorArg valueArg = new ConstructorArg(42, Integer.class);
    System.out.println(valueArg);  // ConstructorArg{arg=42, type=class java.lang.Integer, isRef=false}
  }
}
```





### 原型模式

如何最快速地clone一个HashMap散列表？

有别于 Java、C++ 等基于类的面向对象编程语言，JavaScript 是一种基于原型的面 向对象编程语言。

通过一个 clone 散列表的例子带你搞清 楚：原型模式的应用场景，以及它的两种实现方式：深拷贝和浅拷贝。



#### 原型模式的原理与应用

如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，可以利用对已有对象（作为原型）进行复制（或者叫拷贝）的方式来创建新 对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。



**如何理解对象的创建成本比较大**

实际上，创建对象包含的申请内存、给成员变量赋值这一过程，本身并不会花费太多时间， 或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得 到一点点的性能提升，这就是所谓的过度设计，得不偿失。

但是，如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。

通过一个例子来解释一下刚刚这段话。

假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜 索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用 于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，给关键词建立一个散列表索引。

如果熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中， HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。只需要 将数据从数据库中读取出来，放入 HashMap 就可以了。

不过，还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，对 v2 版本的数据进行更新，得到 v3 版本的数据。这里假设只有更新和新添关键词，没有删除关键词的行为。

![image-20250104003006308](D:\learn-notes\计算机基础\设计模式\images\image-20250104003006308.png)

为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定 期根据数据库中的数据，更新内存中的索引和数据。

该如何实现这个需求？

实际上只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta， 从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是找出 Va 版本与最新版本数据 的“差集”，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中。

按照这个设计思路，给出的示例代码如下所示：

```java
public class Demo {
  private ConcurrentHashMap<String, SearchWord> currentKeywords = new  ConcurrentHashMap<>();

  private long lastUpdateTime = -1;

  public void refresh() {
    // 从数据库中取出更新时间>lastUpdateTime的数据，放入到currentKeywords中
    List<SearchWord> toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);
    long maxNewUpdatedTime = lastUpdateTime;
    for (SearchWord searchWord : toBeUpdatedSearchWords) {
      if (searchWord.getLastUpdateTime() > maxNewUpdatedTime) {
        maxNewUpdatedTime = searchWord.getLastUpdateTime();
      }
      if (currentKeywords.containsKey(searchWord.getKeyword())) {
        currentKeywords.replace(searchWord.getKeyword(), searchWord);
      } else {
        currentKeywords.put(searchWord.getKeyword(), searchWord);
      }
    }
    lastUpdateTime = maxNewUpdatedTime;
  }

  private List<SearchWord> getSearchWords(long lastUpdateTime) {
    // TODO: 从数据库中取出更新时间>lastUpdateTime的数据
    return null;
  }
}
```



现在，有一个特殊的要求：任何时刻，系统 A 中的所有数据都必须是同一个版本的，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了。除此之外，还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是不能停机更新数据。

那该如何实现现在这个需求？

实际上，把正在使用的数据的版本定义为“服务版本”，当要更新内存中的数据的时候，并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版 本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。












### 策略模式

回调函数和模板模式的主要作用都是代码复用和代码扩展，但是回调函数使用起来更加灵活。而他们之间的主要区别在于代码实现，**模板模式基于继承**，**回调基于组合**。

**策略模式**（ Strategy Design Pattern）

策略模式常见的应用场景是能避免冗长的if-else/switch分支判断代码，也可以像模板模式那样，提供框架的扩展点等。

本节：**策略模式的原理和实现，以及如何用它来避免分支判断逻辑。**

策略模式的定义：定义一族算法类，将每个算法分别封装在类中，让它们可以互相替换（实现了同一个接口）。策略模式可以使算法的变化独立于使用它们的算法的代码。

工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式也能起到解耦的作用，不过，它解耦的是**策略的定义、创建、使用**这三部分。



**策略的定义**

策略类的定义包含**一个策略接口**和**一组实现这个接口的策略类**。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：

```java
public interface Strategy {
  void algorithmInterface();
}

public class ConcreteStrategyA implements Strategy {
  @Override
  public void algorithmInterface() {
    //具体的算法...
  }
}
public class ConcreteStrategyB implements Strategy {
  @Override
  public void algorithmInterface() {
    //具体的算法...
  }
}
```



**策略的创建**

策略模式包含一组策略类，在使用它们的时候，一般会**通过类型（type）来判断创建哪个策略类的实例并使用**。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略类实例的逻辑抽离出来，放到**工厂类**中。示例代码如下所示：

```java
// 定义了一个名为StrategyFactory的公共类。
public class StrategyFactory {
  // 声明一个私有的静态成员变量strategies，类型为Map<String, Strategy>，用于存储不同类型对应的策略对象。
  private static final Map<String, Strategy> strategies = new HashMap<>();
  
  // 静态代码块，在类加载时执行。将具体的策略对象实例化并放入strategies映射中，键为"A"和"B"，值分别为ConcreteStrategyA的实例和ConcreteStrategyB的实例。
  static {
    strategies.put("A", new ConcreteStrategyA());
    strategies.put("B", new ConcreteStrategyB());
  }
  
  // 定义了一个公共静态方法getStrategy，接受一个字符串参数type。根据传入的type从strategies映射中获取相应的策略对象，并返回该策略对象。如果type为空或者为空字符串，抛出IllegalArgumentException异常。
  public static Strategy getStrategy(String type) {
    if (type == null || type.isEmpty()) {
      throw new IllegalArgumentException("type should not be empty.");
    }
    return strategies.get(type);
  }
}
```

整体上，这段代码实现了一个策略工厂（StrategyFactory），通过getStrategy方法根据传入的type获取相应的策略对象。通过静态代码块在类加载时初始化策略对象，并存储在strategies映射中。这样，客户端代码可以通过StrategyFactory.getStrategy("A")的形式获取具体的策略对象，实现了策略模式的灵活切换和解耦。

> 在Java中，`final`是一个关键字，可以应用于不同的上下文，如变量、方法和类。它的含义取决于它所修饰的上下文。
>
> 在这个代码片段中，`final`关键字被用于修饰一个变量：
>
> ```java
> private static final Map<String, Strategy> strategies = new HashMap<>();
> ```
>
> 在这里，`final`修饰的是`strategies`变量。在这个上下文中，`final`表示这个变量是一个常量，一旦初始化后，就不能再被赋值为其他对象。它的值是不可变的。
>
> 对于一个`final`修饰的引用类型变量（如这里的`Map<String, Strategy>`），虽然变量本身不能再引用其他对象，但是该对象本身仍然是可变的。也就是说，可以对`strategies`对象进行修改（如添加、删除映射关系），但是不能将`strategies`变量指向其他不同的`Map`对象。
>
> 在这个代码片段中，使用`final`修饰`strategies`变量是为了确保工厂类的策略映射在初始化后不会被修改。这样可以保证`strategies`映射在整个运行时期间保持不变，从而提供了更好的安全性和可靠性。

一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。针对这种情况，可以使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中，用的时候直接返回。

相反，如果策略类是有状态的，根据业务场景的需要，希望每次从工厂方法中，获得的都是新创建的策略对象，而不是缓存好可共享的策略对象，那就需要按照如下方式来实现策略工厂类。

```java
public class StrategyFactory {
  public static Strategy getStrategy(String type) {
    if (type == null || type.isEmpty()) {
      throw new IllegalArgumentException("type should not be empty.");
    }
    if (type.equals("A")) {
      return new ConcreteStrategyA();
    } else if (type.equals("B")) {
      return new ConcreteStrategyB();
    }
    return null;
  }
}
```



**策略的使用**

策略模式包含一组可选策略类，客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。
这里的“运行时动态”指的是，事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。通过一个例子来解释一下。

```java
// 策略接口：EvictionStrategy
// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...
// 策略工厂：EvictionStrategyFactory

public class UserCache {
  private Map<String, User> cacheData = new HashMap<>();
  private EvictionStrategy eviction;
  public UserCache(EvictionStrategy eviction) {
    this.eviction = eviction;
  }
  //...
}

// 运行时动态确定，根据配置文件的配置决定使用哪种策略
public class Application {
  public static void main(String[] args) throws Exception {
    EvictionStrategy evictionStrategy = null;
    Properties props = new Properties();
    props.load(new FileInputStream("./config.properties"));
    String type = props.getProperty("eviction_type");
    evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);
    UserCache userCache = new UserCache(evictionStrategy);
    //...
  }
}

// 非运行时动态确定，在代码中指定使用哪种策略
public class Application {
  public static void main(String[] args) {
    //...
    EvictionStrategy evictionStrategy = new LruEvictionStrategy();
    UserCache userCache = new UserCache(evictionStrategy);
    //...
  }
}
```

从上面的代码中，可以看出，“非运行时动态确定”，也就是第二个 Application 中的使用方式，并不能发挥策略模式的优势。在这种应用场景下，策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”。



**利用策略模式避免分支判断**

实际上，能够移除分支判断逻辑的模式不仅有策略模式，状态模式也可以。对于使用哪种模式，具体还要看应用场景来定。 策略模式适用于根据不同类型，动态决定使用哪种策略这样一种应用场景。
if-else 或 switch-case 分支判断逻辑是如何产生的。具体的代码如下所示。在这个例子中，没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。

```java
public class OrderService {
  public double discount(Order order) {
    double discount = 0.0;
    OrderType type = order.getType();
    if (type.equals(OrderType.NORMAL)) { // 普通订单
      //...省略折扣计算算法代码
    } else if (type.equals(OrderType.GROUPON)) { // 团购订单
      //...省略折扣计算算法代码
    } else if (type.equals(OrderType.PROMOTION)) { // 促销订单
      //...省略折扣计算算法代码
    }
    return discount;
  }
}
```

如何来移除掉分支判断逻辑呢？使用策略模式对上面的代码重构，将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象。具体的代码如下所示：

```java
// 策略的定义
public interface DiscountStrategy {
  double calDiscount(Order order);
}
// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy

// 策略的创建
public class DiscountStrategyFactory {
  private static final Map<OrderType, DiscountStrategy> strategies = new HashMa
    static {
    strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());
    strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());
    strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());
  }
  public static DiscountStrategy getDiscountStrategy(OrderType type) {
    return strategies.get(type);
  }
}
// 策略的使用
public class OrderService {
  public double discount(Order order) {
    OrderType type = order.getType();
    DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);
    return discountStrategy.calDiscount(order);
  }
}
```

重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，用 Map 来**缓存了策略对应的实例**，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。使用状态模式来避免分支判断逻辑是同样的套路。本质上都是借助“查表法”，根据 type 查表（代码中的strategies 就是表）替代根据 type 分支判断。
但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了。具体的代码如下所示：

```java
public class DiscountStrategyFactory {
  public static DiscountStrategy getDiscountStrategy(OrderType type) {
    if (type == null) {
      throw new IllegalArgumentException("Type should not be null.");
    }
    if (type.equals(OrderType.NORMAL)) {
      return new NormalDiscountStrategy();
    } else if (type.equals(OrderType.GROUPON)) {
      return new GrouponDiscountStrategy();
    } else if (type.equals(OrderType.PROMOTION)) {
      return new PromotionDiscountStrategy();
    }
    return null;
  }
}
```

这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类中，实际上并没有真正将它移除。

总结：

- 策略模式定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的算法的代码。

- 策略模式用来解耦策略的定义、创建、使用。一个完整的策略模式就是由这三个部分组成的。

- 策略类的定义包含一个策略接口和一组实现这个接口的策略类。

- 策略的创建由工厂类来完成，封装策略创建的细节。
  可以通过策略模式来移除 if-else 分支判断。这得益于策略工厂类，更本质上点讲，是借助“查表法”，根据 type 查表替代根据 type 分支判断。

- 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，**“运行时动态确定”才是策略模式最典型的应用场景**。

  

思考：在策略工厂类中，如果每次都要返回新的策略对象，还是需要在工厂类中编写 if-else 分支判断逻辑，那这个问题该如何解决呢？





**以案例（给文件排序）讲解策略模式的应用场景以及真正的设计意图。**

**设计原则和思想比设计模式更加普适和重要，掌握了代码的设计原则和思想，就甚至可以自己创造出来新的设计模式。**

需求：写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。

1. 一般的回答是，将文件中的内容读取出来，并且通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件。

2. 如果文件很大，比如有 10GB 大小，因为内存有限（比如只有 8GB 大小），没办法一次性加载文件中的所有数据到内存中，这个时候，就要利用外部排序算法

3. 如果文件更大，比如有 100GB 大小，为了利用 CPU 多核的优势，可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的MapReduce。

4. 如果文件非常大，比如有 1TB 大小，即便是单机多线程排序，这也算很慢了。这个时候，可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率。

可以看出上面的处理方式随着文件的大小不同，有多种处理方式。

现在来看代码实现：

1. 最简单直接的方式：

   ```java
   public class Sorter {
       private static final long GB = 1000 * 1000 * 1000;
       public void sortFile(String filePath) {
           // 省略校验逻辑
           File file = new File(filePath);
           long fileSize = file.length();
           if (fileSize < 6 * GB) { // [0, 6GB)
               quickSort(filePath);
           } else if (fileSize < 10 * GB) { // [6GB, 10GB)
               externalSort(filePath);
           } else if (fileSize < 100 * GB) { // [10GB, 100GB)
               concurrentExternalSort(filePath);
           } else { // [100GB, ~)
               mapreduceSort(filePath);
           }
       }
       
       // 每种排序算法的实现逻辑都比较复杂，代码行数都比较多
       
       private void quickSort(String filePath) {
           // 快速排序 
       }
       
       private void externalSort(String filePath) {
           // 外部排序
       }
       
       private void concurrentExternalSort(String filePath) {
           // 多线程外部排序
       }
       
       private void mapreduceSort(String filePath) {
           // 利用MapReduce多机排序
       }
   }
   
   public class SortingTool {
       public static void main(String[] args) {
           Sorter sorter = new Sorter();
           sorter.sortFile(args[0]);
       }
   }
   ```

   

按照编码规范，函数的行数不能过多，最好不要超过一屏的大小，所以，为了避免 sortFile() 函数过长，把每种排序算法从 sortFile() 函数中抽离出来，拆分成 4 个独立的排序函数。

如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果是在开发一个大型项目，排序文件只是其中的一个功能模块，那就要在代码设计、代码质量上下点儿功夫。只有每个小的功能模块都写好，整个项目的代码才能不差。

上面的代码中，所有排序算法的代码实现都堆在 Sorter 一个类中，这就会导致这个类的代码很多。一个类的代码太多也会影响到可读性、可维护性。同时，上面的代码中，所有的排序算法都设计成 Sorter 的私有函数，也会影响代码的可复用性。



**优化上述代码**

基于学习过的设计原则和思想，针对上面的问题，即便想不到该用什么设计模式来重构，也应该能知道该如何解决，那就是将 Sorter 类中的某些代码拆分出来，独立成**职责更加单一**的小类。实际上，拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段。按照这个解决思路，对代码进行重构：

```java
// 接口
public interface ISortAlg {
    void sort(String filePath);
}

public class QuickSort implements ISortAlg {
    @Override
    public void sort(String filePath) {
        //...
    }
}

public class ExternalSort implements ISortAlg {
    @Override
    public void sort(String filePath) {
        //...
    }
}

public class ConcurrentExternalSort implements ISortAlg {
    @Override
    public void sort(String filePath) {
        //...
    }
}

public class MapReduceSort implements ISortAlg {
    @Override
    public void sort(String filePath) {
        //...
    }
}

public class Sorter {
    private static final long GB = 1000 * 1000 * 1000;
    public void sortFile(String filePath) {
        // 省略校验逻辑
        File file = new File(filePath);
        long fileSize = file.length();
        ISortAlg sortAlg;
        if (fileSize < 6 * GB) { // [0, 6GB)
            sortAlg = new QuickSort();
        } else if (fileSize < 10 * GB) { // [6GB, 10GB)
            sortAlg = new ExternalSort();
        } else if (fileSize < 100 * GB) { // [10GB, 100GB)
            sortAlg = new ConcurrentExternalSort();
        } else { // [100GB, ~)
            sortAlg = new MapReduceSort();
        }
        sortAlg.sort(filePath);
    }
}
```



经过拆分之后，每个类的代码都不会太多，每个类的逻辑都不会太复杂，代码的可读性、可维护性提高了。除此之外，将排序算法设计成独立的类，跟具体的业务逻辑（代码中的if-else 那部分逻辑）解耦，也让排序算法能够复用。这一步实际上就是策略模式的第一步，也就是将**策略的定义**分离出来。

上面的代码还可以继续优化。每种排序类都是无状态的，没必要在每次使用的时候，都重新创建一个新的对象。所以，我们可以使用工厂模式对对象的创建进行封装（实现缓存）。按照这个思路，对代码进行重构。重构之后的代码如下所示：

````java
public class SortAlgFactory {
    private static final Map<String, ISortAlg> algs = new HashMap<>();
    static {
        algs.put("QuickSort", new QuickSort());
        algs.put("ExternalSort", new ExternalSort());
        algs.put("ConcurrentExternalSort", new ConcurrentExternalSort());
        algs.put("MapReduceSort", new MapReduceSort());
    }
    public static ISortAlg getSortAlg(String type) {
        if (type == null || type.isEmpty()) {
            throw new IllegalArgumentException("type should not be empty.");
        }
        return algs.get(type);
    }
}

public class Sorter {
    private static final long GB = 1000 * 1000 * 1000;
    public void sortFile(String filePath) {
        // 省略校验逻辑
        File file = new File(filePath);
        long fileSize = file.length();
        ISortAlg sortAlg;
        if (fileSize < 6 * GB) { // [0, 6GB)
            sortAlg = SortAlgFactory.getSortAlg("QuickSort");
        } else if (fileSize < 10 * GB) { // [6GB, 10GB)
            sortAlg = SortAlgFactory.getSortAlg("ExternalSort");
        } else if (fileSize < 100 * GB) { // [10GB, 100GB)
            sortAlg = SortAlgFactory.getSortAlg("ConcurrentExternalSort");
        } else { // [100GB, ~)
            sortAlg = SortAlgFactory.getSortAlg("MapReduceSort");
        }
        sortAlg.sort(filePath);
    }
}
````



经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂。不过，Sorter 类中的sortFile() 函数还是有一堆 if-else 逻辑。这里的 if-else 逻辑分支不多、也不复杂，这样写完全没问题。但如果特别想将 if-else 分支判断移除掉，那也是有办法的。

实际上，这是基于查表法来解决的，其中的“algs”就是“表”。

```java
public class Sorter {
    private static final long GB = 1000 * 1000 * 1000;
    private static final List<AlgRange> algs = new ArrayList<>();
    static {
        algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg("QuickSort")));
        algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg("ExternalSort")));
        algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg("ConcurrentExternalSort")));
        algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg("MapReduceSort")));
    }
    public void sortFile(String filePath) {
        // 省略校验逻辑
        File file = new File(filePath);
        long fileSize = file.length();
        ISortAlg sortAlg = null;
        for (AlgRange algRange : algs) {
            if (algRange.inRange(fileSize)) {
                sortAlg = algRange.getAlg();
                break;
            }
        }
        sortAlg.sort(filePath);
    }
    
    private static class AlgRange {
        private long start;
        private long end;
        private ISortAlg alg;
        public AlgRange(long start, long end, ISortAlg alg) {
            this.start = start;
            this.end = end;
            this.alg = alg;
        }
        public ISortAlg getAlg() {
            return alg;
        }
        public boolean inRange(long size) {
            return size >= start && size < end;
        }
    }
}
```

> Java中可以在一个类中定义另一个类，这被称为嵌套类（Nested Class）。在你提供的代码中，`Sorter`类中定义了一个私有静态嵌套类`AlgRange`。
>
> 嵌套类可以是静态的，也可以是非静态的。在你的例子中，`AlgRange`是一个静态嵌套类，因为它被声明为`private static class AlgRange`。
>
> 静态嵌套类与外部类之间的关系紧密，它们可以访问外部类的静态成员（包括私有静态成员）而无需创建外部类的实例。在你的代码中，`AlgRange`可以访问`Sorter`类中的私有静态成员`GB`和`algs`。
>
> 需要注意的是，嵌套类可以有不同的访问修饰符（public、protected、private或默认），并且可以在外部类的方法中实例化和使用。

