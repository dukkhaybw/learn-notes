# 文件上传



功能点：

- 整体上传
- 分片上传
- 进度条
- 秒传
- 断点续传(支持单个分片续传和刷新浏览器续传)
- 暂停和恢复

文件上传原理：

- 根据 http 协议

## FileReader 构造函数

该构造函数的实例对象可以将文件内容读取到内存中，同时实例对象上有一些列的异步方法，用于访问读取结果。

使用 FileReader 对象，web 应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用 File 对象或者 Blob 对象来指定所要处理的文件或数据。

创建实例

```js
var reader = new FileReader();
```

实例方法

- abort( ) ：终止文件读取操作
- readAsArrayBuffer(file)：异步按字节读取文件内容，结果用 ArrayBuffer 对象表示
- readAsBinaryString(file)： 异步按字节读取文件内容，结果为文件的二进制串
- readAsDataURL(file)： 异步读取文件内容，结果用 data:url 的字符串形式表示
- readAsText(file,encoding)： 异步按字符读取文件内容，结果用字符串形式表示

事件

- onabort：当读取操作被中止时调用
- onerror：当读取操作发生错误时调用
- onload：当读取操作成功完成时调用
- onloadend： 当读取操作完成时调用,不管是成功还是失败
- onloadstart：当读取操作将要开始之前调用
- onprogress：在读取数据过程中周期性调用

使用

FileReader 通过异步的方式读取文件内容，结果均是通过事件回调获取，下面是一个读取本地 txt 文件内容的例子：

```js
var input = document.getElementById('file'); //input file
input.onchange = function () {
  var file = this.files[0];
  if (!!file) {
    //读取本地文件，以gbk编码方式输出
    var reader = new FileReader();
    reader.readAsText(file, 'gbk');
    reader.onload = function () {
      //读取完毕后输出结果
      console.log(this.result);
    };
  }
};
```

读取方式

- readAsArrayBuffer(file)：异步按字节读取文件内容，结果用 ArrayBuffer 对象表示
- readAsBinaryString(file)： 异步按字节读取文件内容，结果为文件的二进制串
- readAsDataURL(file)： 异步读取文件内容，结果用 data:url 的字符串形式表示
- readAsText(file,encoding)： 异步按字符读取文件内容，结果用字符串形式表示

测试读取文件，一张图片（6764 字节）和一个 txt 文本（51 字节）作为测试文件：

![image-20220529204603554](D:\learn-notes\珠峰架构\images\image-20220529204603554.png)

### readAsDataURL

readAsDataURL 会将文件内容进行 base64 编码后输出

```js
var file = this.files[0];
var reader = new FileReader();
reader.readAsDataURL(file);
reader.onload = function () {
  //读取完毕后输出结果
  console.log(this.result);
  //查看文件内容字节大小
  console.log(new Blob([this.result]));
};
```

图片输出结果：

![image-20220529204805480](D:\learn-notes\珠峰架构\images\image-20220529204805480.png)

txt 输出结果：

![image-20220529204818584](D:\learn-notes\珠峰架构\images\image-20220529204818584.png)

### readAsText

readAsText 可以通过不同的编码方式读取字符，默认使用`utf-8`读取

```js
var file = this.files[0];
var reader = new FileReader();
reader.readAsText(file, 'uft-8');
reader.onload = function () {
  //读取完毕后输出结果
  console.log(this.result);
  //查看文件内容字节大小
  console.log(new Blob([this.result]));
};
```

图片输出结果：

![image-20220529205041943](D:\learn-notes\珠峰架构\images\image-20220529205041943.png)

txt 输出结果：

![image-20220529205109365](D:\learn-notes\珠峰架构\images\image-20220529205109365.png)

readAsText 读取文件的单位是字符，故对于文本文件，只要按规定的编码方式读取即可；而对于媒体文件（图片、音频、视频），其内部组成并不是按字符排列，故采用 readAsText 读取，会产生乱码，同时也不是最理想的读取文件的方式。

### readAsBinaryString

与 readAsText 不同的是，readAsBinaryString 函数会按字节读取文件内容。然而诸如 0101 的二进制数据只能被机器识别，若想对外可见，还是需要进行一次编码，而 readAsBinaryString 的结果就是读取二进制并编码后的内容。尽管 readAsBinaryString 方法可以按字节读取文件，但由于读取后的内容被编码为字符，大小会受到影响，故不适合直接传输，也不推荐使用。

```js
var file = this.files[0];
var reader = new FileReader();
reader.readAsBinaryString(file);
reader.onload = function () {
  //读取完毕后输出结果
  console.log(this.result);
  //查看文件内容字节大小
  console.log(new Blob([this.result]));
};
```

图片输出结果：

![image-20220529205243535](D:\learn-notes\珠峰架构\images\image-20220529205243535.png)

txt 输出结果：

![image-20220529205250231](D:\learn-notes\珠峰架构\images\image-20220529205250231.png)

### readAsArrayBuffer

与 readAsBinaryString 类似，readAsArrayBuffer 方法会按字节读取文件内容，并转换为 ArrayBuffer 对象。文件读取后大小与原文件大小一致。这也就是 readAsArrayBuffer 与 readAsBinaryString 方法的区别，readAsArrayBuffer 读取文件后，会在内存中创建一个 ArrayBuffer 对象（二进制缓冲区），将二进制数据存放在其中。通过此方式，可以直接在网络中传输二进制内容。

简单理解为存放了一段二进制数据的内存空间。

图片输出结果：

![image-20220529205511740](D:\learn-notes\珠峰架构\images\image-20220529205511740.png)

txt 输出结果：

![image-20220529205517955](D:\learn-notes\珠峰架构\images\image-20220529205517955.png)

ArrayBuffer 中的内容对外是不可见的，若要查看其中的内容，就要引入另一个概念：类型化数组我们可以尝试查看下刚刚通过 readAsArrayBuffer 方法读取的图片文件内容：

![image-20220529205802442](D:\learn-notes\珠峰架构\images\image-20220529205802442.png)

可以看到，整个图片文件的 6764 个字节，被分别存储在长度为 6764 的数组中，而数组中每一个元素的值，为当前字节的十进制数值。

### 应用场景

img 的 src 属性或 background 的 url 属性，可以通过被赋值为图片网络地址或 base64 的方式显示图片。

一般上传文件的处理方式：一般会先将本地文件上传到服务器，上传成功后，由后台返回图片的网络地址再在前端显示。

#### 本地图片预览

前端本地图片上传前的预览，通过 FileReader 的 readAsDataURL 方法，可以不经过后台，直接将本地图片显示在页面上。这样做可以减少前后端频繁的交互过程，减少服务器端无用的图片资源，代码如下：

```js
var input = document.getElementById('file'); // input file
input.onchange = function () {
  var file = this.files[0];
  if (!!file) {
    var reader = new FileReader();
    // 图片文件转换为base64
    reader.readAsDataURL(file);
    reader.onload = function () {
      // 显示图片
      document.getElementById('file_img').src = this.result;
    };
  }
};
```

对于图片上传，我们也可以先将图片转换为 base64 进行传输，此时由于传输的图片内容就是一段字符串，故上传接口可以当做普通 post 接口处理，当图片传输到后台后，可以在转换为文件实体存储。当然，考虑到 base64 转换效率及其本身的大小，本方法还是适合于上传内容简单或所占内存较小的文件。

## 上传图片的类型限制

### 方式一

通过 `input` 元素的 `accept` 属性来限制上传的文件类型

```html
.png格式:
<input type="file" id="inputFile" accept="image/png" />

.xls格式:
<input text="file" accept="application/vnd.ms-excel" />

.xslx格式:
<input text="fiel" accept="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />

图片:
<input type="file" accept="image/*" />
```

不足：如果用户把 JPEG 格式的图片后缀名更改为 `.png` 的话，就可以突破这个限制。

### 方式二

读取文件的二进制数据来识别正确的文件类型。**计算机并不是通过图片的后缀名来区分不同的图片类型，而是通过 “魔数”（Magic Number）来区分。**对于某一些类型的文件，起始的几个字节内容都是固定的，根据这几个字节的内容就可以判断文件的类型。

常见图片类型对应的魔数如下表所示：

| 文件类型 | 文件后缀 | 魔数                      |
| :------- | :------- | :------------------------ |
| JPEG     | jpg/jpeg | 0xFF D8 FF                |
| PNG      | png      | 0x89 50 4E 47 0D 0A 1A 0A |
| GIF      | gif      | 0x47 49 46 38（GIF8）     |
| BMP      | bmp      | 0x42 4D                   |

- 通过 input type="file" 标签获取到文件对象
- 通过 FileReader API 来读取文件的二进制内容（不需要读取文件的完整信息，读取开头特定的长度可以）

读取文件中指定范围的二进制数据方法：

```js
function readBuffer(file, start = 0, end = 2) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file.slice(start, end));
  });
}
```

- 逐一判断每个字节的内容是否一致

```js
function check(headers) {
  return (buffers, options = { offset: 0 }) =>
    headers.every((header, index) => header === buffers[options.offset + index]);
}
```

- 检测 PNG 图片类型

```html
<div>
  选择文件：<input type="file" id="inputFile" accept="image/*" onchange="handleChange(event)" />
  <p id="realFileType"></p>
</div>
```

```js
const isPNG = check([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]); // PNG图片对应的魔数
const realFileElement = document.querySelector('#realFileType');

async function handleChange(event) {
  const file = event.target.files[0];
  const buffers = await readBuffer(file, 0, 8);
  const uint8Array = new Uint8Array(buffers);
  realFileElement.innerText = `${file.name}文件的类型是：${
    isPNG(uint8Array) ? 'image/png' : file.type
  }`;
}
```

## 二进制数据上传

基于 XHR2 可以直接上传或下载二进制内容，无需像以往一样通过 form 标签由后端拉取二进制内容。

简单整理下上传逻辑： 1、通过 input[type="file"]标签获取本地文件 File 对象 2、通过 FileReader 的 readAsArrayBuffer 方法将 File 对象转换为 ArrayBuffer 3、创建 xhr 对象，配置请求信息 4、通过 xhr.sendAsBinary 直接将文件的 ArrayBuffer 内容装填至 post body 后发送

代码实现如下：

```js
var input = document.getElementById('file'); // input file
input.onchange = function () {
  var file = this.files[0];
  if (!!file) {
    var reader = new FileReader();
    reader.readAsArrayBuffer(file);
    reader.onload = function () {
      var binary = this.result;
      upload(binary);
    };
  }
};

//文件上传
function upload(binary) {
  var xhr = new XMLHttpRequest();
  xhr.open('POST', 'http://xxxx/opload');
  xhr.overrideMimeType('application/octet-stream');
  //直接发送二进制数据
  if (xhr.sendAsBinary) {
    xhr.sendAsBinary(binary);
  } else {
    xhr.send(binary);
  }

  // 监听变化
  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        // 响应成功
      }
    }
  };
}
```

## 扩展

xhr.overrideMimeTyp 与 xhr.responseType

一般情况下服务器在处理完请求后，响应给浏览器的响应头中含有 content-type，用于告诉浏览器服务器返回的数据的类型，浏览器就可以根据该请求头的值自动识别并进行响应的处理。

overrideMimeType 方法的作用是用来重写`response`的`content-type`。

**注意:** xhr.overrideMimeType()方法在 send()之前调用

## Blob 对象

Blob 允许我们可以通过 JS 直接操作二进制数据。Blob 对象可以看做是存放二进制数据的容器，此外还可以通过 Blob 设置二进制数据的 MIME 类型。

一个 Blob 对象就是一个包含有只读原始数据的类文件对象。Blob 对象中的数据并不一定都是 JavaScript 中的原生形式。File 接口基于 Blob，继承了 Blob 的功能,并且扩展支持了用户计算机上的本地文件。

创建实例

```js
var blob = new Blob(dataArr:Array<any>, opt:{type:string});
```

- dataArray：数组，包含了要添加到 Blob 对象中的数据，数据可以是任意多个 ArrayBuffer，ArrayBufferView， Blob，或者 DOMString 对象。

- opt：对象，用于设置 Blob 对象的属性（如：MIME 类型）

1、创建一个装填 DOMString 对象的 Blob 对象

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214157975-1381640633.png)

2、创建一个装填 ArrayBuffer 对象的 Blob 对象

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214204991-1533610697.png)

3、创建一个装填 ArrayBufferView 对象的 Blob 对象（ArrayBufferView 可基于 ArrayBuffer 创建，返回值是一个类数组。如下：创建一个 8 字节的 ArrayBuffer，在其上创建一个每个数组元素为 2 字节的“视图”）

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214211507-2138861162.png)

通过 Blob.slice()

此方法返回一个新的 Blob 对象，包含了原 Blob 对象中指定范围内的数据

```less
Blob.slice(start:number, end:number, contentType:string)
```

- start：开始索引，默认为 0
- end：截取结束索引（不包括 end）
- contentType：新 Blob 的 MIME 类型，默认为空字符串

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214220586-1491607027.png)

通过 canvas.toBlob()

```javascript
var canvas = document.getElementById('canvas');
canvas.toBlob(function (blob) {
  console.log(blob);
});
```

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214233650-666441369.png)

### 应用

#### 分片上传

通过 Blob.slice 方法，可以将大文件分片，轮循向后台提交各文件片段，即可实现文件的分片上传。分片上传逻辑如下：

- 获取要上传文件的 File 对象，根据 chunk（每片大小）对文件进行分片
- 通过 post 方法轮循上传每片文件，其中 url 中拼接 querystring 用于描述当前上传的文件信息；post body 中存放本次要上传的二进制数据片段
- 接口每次返回 offset，用于执行下次上传

下面是分片上传的简单实现：

```js
initUpload();

//初始化上传
function initUpload() {
  var chunk = 100 * 1024; //每片大小
  var input = document.getElementById('file'); //input file
  input.onchange = function (e) {
    var file = this.files[0];
    var query = {};
    var chunks = [];
    if (!!file) {
      var start = 0;
      //文件分片
      for (var i = 0; i < Math.ceil(file.size / chunk); i++) {
        var end = start + chunk;
        chunks[i] = file.slice(start, end);
        start = end;
      }

      // 采用post方法上传文件
      // url query上拼接以下参数，用于记录上传偏移
      // post body中存放本次要上传的二进制数据
      query = {
        fileSize: file.size,
        dataSize: chunk,
        nextOffset: 0
      };

      upload(chunks, query, successPerUpload);
    }
  };
}

// 执行上传
function upload(chunks, query, cb) {
  var queryStr = Object.getOwnPropertyNames(query)
    .map((key) => {
      return key + '=' + query[key];
    })
    .join('&');
  var xhr = new XMLHttpRequest();
  xhr.open('POST', 'http://xxxx/opload?' + queryStr);
  xhr.overrideMimeType('application/octet-stream');

  //获取post body中二进制数据
  var index = Math.floor(query.nextOffset / query.dataSize);
  getFileBinary(chunks[index], function (binary) {
    if (xhr.sendAsBinary) {
      xhr.sendAsBinary(binary);
    } else {
      xhr.send(binary);
    }
  });

  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var resp = JSON.parse(xhr.responseText);
        // 接口返回nextoffset
        // resp = {
        //     isFinish:false,
        //     offset:100*1024
        // }
        if (typeof cb === 'function') {
          cb.call(this, resp, chunks, query);
        }
      }
    }
  };
}

// 每片上传成功后执行
function successPerUpload(resp, chunks, query) {
  if (resp.isFinish === true) {
    alert('上传成功');
  } else {
    //未上传完毕
    query.offset = resp.offset;
    upload(chunks, query, successPerUpload);
  }
}

// 获取文件二进制数据
function getFileBinary(file, cb) {
  var reader = new FileReader();
  reader.readAsArrayBuffer(file);
  reader.onload = function (e) {
    if (typeof cb === 'function') {
      cb.call(this, this.result);
    }
  };
}
```

以上是文件分片上传前端的简单实现，当然，此功能还可以更加完善，如后台需要对合并后的文件大小进行校验；或者前端加密文件，全部上传完毕后后端解密校验等。

#### 通过 url 下载文件

window.URL 对象可以为 Blob 对象生成一个网络地址，结合 a 标签的 download 属性，可以实现点击 url 下载文件实现如下：

```js
createDownload('download.txt', 'download file');

function createDownload(fileName, content) {
  var blob = new Blob([content]);
  var link = document.createElement('a');
  link.innerHTML = fileName;
  link.download = fileName;
  link.href = URL.createObjectURL(blob);
  document.getElementsByTagName('body')[0].appendChild(link);
}
```

执行后页面上会生成此 Blob 对象的地址，点击后可下载：

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214307058-499657467.png)

查看下载结果：

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214312934-1343358624.png)

#### 通过 url 显示图片

img 的 src 属性及 background 的 url 属性，都可以通过接收图片的网络地址或 base64 来显示图片，同样的，我们也可以把图片转化为 Blob 对象，生成 URL（URL.createObjectURL(blob)），来显示图片。

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214320606-2044023964.png)











## 课程部分

基于js管理文件上传，大文件上传和断点续传



内容大纲：

- axios基础封装
- 前端后端通信的数据格式
- 基于FileReader读取文件和处理
- 基于spark-md5生成唯一文件名
- 上传文件的大小和类型限制
- 上传图片的缩略图展示
- 典型的文件上传方案：FormData和Base64
- 上传的进度条展示和控制
- 文件拖拽上传
- 大文件的切片上传和优化
- 多文件上传和进度管控
- 断点续传及其原理
- 服务器端nodejs的实现原理



项目依赖：

- axios：发送网络请求
- qs：基于对象数据类型生成key=value&key=value这样的字符串
- spark-md5：基于文件内容生成唯一的名字







前端部分代码和界面展示，后端部分代码展示。

![image-20231112101807106](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231112101807106.png)

后台程序将上传的文件存放到项目根目录下的upload目录中。



### Content-Type

在前后端通信中，常用的 `Content-Type` 类型有几种主要的类型，主要用于指定发送到服务器的数据的媒体类型。这些类型包括：



1. **`application/json`**:

   - 用于发送 JSON 格式的数据。

   - 常用于 REST API。

     

2. **`application/x-www-form-urlencoded`**:

   - 用于发送 HTML 表单格式的数据。

   - 数据以键值对的形式发送，键和值都进行了 URL 编码。

   - 每个键和值都被编码为等号 (`=`) 分隔的形式，而不同的键值对之间则用 `&` 符号连接（格式类似于 URL 查询字符串的格式）。

   - **单个键值对**:

     - 假设你有一个名为 name 的字段，其值为 Alice，那么编码后的数据将是：

       ```
       name=Alice
       ```

   - **多个键值对**:

     - 假设你有两个字段，name 值为 Alice

        和 age 值为 30，则编码后的数据将是：

       ```
       name=Alice&age=30
       ```

   - **包含空格和特殊字符**:

     - 如果值包含空格或特殊字符，这些字符将被 URL 编码。例如，name 为 Alice Smith 和 city 为 New York 的数据将编码为：

       ```
       name=Alice%20Smith&city=New%20York
       ```

     - 在这个例子中，空格被编码为 `%20`。

   - **包含数组或复杂结构**:

     - 对于简单的键值对，这种格式非常有效，但对于包含数组或更复杂结构的数据，这种格式可能不太适用。例如，尝试表示数组（如 colors=["red", "green", "blue"]）时，可能需要将其转换为多个键值对：

       ```
       colors=red&colors=green&colors=blue
       ```

     - 或者使用某种约定来表示数组，如：

       ```
       colors[]=red&colors[]=green&colors[]=blue
       ```

   在实际应用中，浏览器的 HTML 表单和大多数前端框架都会自动处理这种编码。当使用 `application/x-www-form-urlencoded` 作为 `Content-Type` 时，这种数据格式被广泛用于发送简单的文本数据。

   

   在 `application/x-www-form-urlencoded` 格式中，参数通常**不是**拼接在 URL 中传给后端的，而是作为请求体（request body）的一部分发送。这与 URL 参数（通常用于 GET 请求）是不同的。

   以下是这两种情况的对比：

   1. **URL 参数（Query Strings）**:
      - 主要用于 GET 请求。
      - 参数拼接在 URL 的末尾，如 `http://example.com/api?name=Alice&age=30`。
      - 适用于发送少量数据。
   2. **请求体（Request Body）**:
      - 在 `application/x-www-form-urlencoded` 格式下，数据作为 HTTP 请求的体部分发送。
      - 主要用于 POST 请求。
      - URL 保持不变，如 `http://example.com/api`，而数据（如 `name=Alice&age=30`）包含在请求体中。

   这种编码格式常见于 HTML 表单提交，其中表单数据编码为键值对，并在 POST 请求的请求体中发送到服务器。这使得它适合发送大量或复杂的数据，**与 URL 参数不同，它不受 URL 长度限制**。

   

3. **`multipart/form-data`**:

   - 用于发送包含文件上传的表单数据。

   - 除了文件，还可以用来发送文本字段。

   - 是一种用于 HTTP 请求的编码类型，主要用于在表单中上传文件。这种格式允许将表单数据分成多个部分（或 "part"），每个部分包含一段数据。这种格式特别适合于文件上传，因为它允许在单个请求中发送二进制数据（如文件内容）和非二进制字段。

     在 `multipart/form-data` 格式中，数据通常按以下方式组织：

     1. **多部分格式**:
        - 每个表单元素（如文本字段、文件等）都作为消息的一个部分发送。
        - 部分之间由特殊的分隔符分隔，这个分隔符在请求的 `Content-Type` 头中定义。
     2. **文本字段和文件**:
        - 文本字段以普通文本形式发送。
        - 文件以它们的原始二进制格式发送。
     3. **头信息**:
        - 每个部分通常包含一些头信息，如 `Content-Disposition`，其中包含字段名和文件名（对于文件字段）。

     例如，假设你有一个表单，其中包含一个名为 `name` 的文本字段和一个用于上传文件的字段 `file`。在 `multipart/form-data` 格式中，请求体可能看起来像这样：

     ```
     --boundary12345
     Content-Disposition: form-data; name="name"
     
     Alice
     --boundary12345
     Content-Disposition: form-data; name="file"; filename="example.txt"
     Content-Type: text/plain
     
     [文件内容]
     --boundary12345--
     ```

     在这个例子中，`boundary12345` 是部分之间的分隔符。每个部分首先包含描述其内容的头信息，然后是实际的数据。

     由于其多部分和二进制友好的特性，`multipart/form-data` 是处理表单上传，特别是文件上传的理想选择。它比 `application/x-www-form-urlencoded` 更复杂，但它允许更灵活和高效的数据传输。

     

4. **`text/plain`**:

   - 纯文本数据。

   - 较少使用，因为它不提供额外的结构信息。

   - 不含任何特殊的结构或编码，它就是纯粹的文本内容，没有像 JSON 或 XML 那样的键值对、标签或特殊符号来表示数据结构。

   - **单纯文本**:

     - 只包含普通的文本字符。
     - 例如：`Hello, world!`

   - **没有特定结构**:

     - 不支持复杂的数据结构，如对象、数组或键值对。
     - 所有内容都是连续的文本，没有用于数据分隔或组织的特殊字符。

   - **不支持特殊编码**:

     - 与 `application/json` 或 `application/xml` 不同，`text/plain` 不支持内部结构化或特殊编码。
     - 换行符和空格在文本中原样表示。

     

5. **`application/xml` 或 `text/xml`**:

   - 用于发送 XML 数据。

   - 像 `application/json`，但使用 XML 格式。

   - 用于在 HTTP 请求和响应中发送 XML (eXtensible Markup Language) 数据。XML 是一种标记语言，用于描述和传输结构化数据。它使用自定义标签来定义数据结构，使得数据既易于阅读，又易于机器处理。

     在 `application/xml` 格式中，数据通常按以下方式组织：

     1. **标签和元素**:

        - XML 数据由一系列嵌套的标签组成，每个标签代表数据的一个元素。

        - 例如：

          ```
          xmlCopy code<person>
            <name>Alice</name>
            <age>30</age>
          </person>
          ```

        - 这个例子中有一个根元素 `<person>`，包含两个子元素：`<name>` 和 `<age>`。

     2. **属性**:

        - XML 元素可以有属性，这些属性提供关于元素的附加信息。

        - 例如：

          ```
          xmlCopy code<person role="user">
            <name>Alice</name>
            <age>30</age>
          </person>
          ```

        - 这里，`person` 元素有一个 `role` 属性，其值为 `"user"`。

     3. **层次结构和嵌套**:

     4. XML 支持复杂的层次结构和嵌套元素，允许表示复杂的数据结构。

        - 例如：

          ```
          xmlCopy code<person role="user">
            <name>Alice</name>
            <age>30</age>
            <address>
              <street>Main Street</street>
              <city>Wonderland</city>
            </address>
          </person>
          ```

        - 在这个例子中，`address` 是一个嵌套元素，包含 `street` 和 `city` 元素。

     5. **声明和字符编码**:

        - XML 文档通常以 XML 声明开始，指明版本和字符编码。

        - 例如：

          ```
          xmlCopy code<?xml version="1.0" encoding="UTF-8"?>
          <person>...</person>
          ```

        `application/xml` 格式的使用在某些领域，如企业系统集成、配置文件和网络协议（如 SOAP），仍然非常流行。它提供了一种灵活而强大的方式来表示和传输结构化数据。然而，由于其冗长和复杂性，JSON 在许多现代 Web 应用程序中已经取代了 XML 作为首选的数据交换格式。

        

6. **`text/html`**:

   - 主要用于返回 HTML 格式的响应数据。

   - 是一种用于发送 HTML (HyperText Markup Language) 格式数据的 MIME 类型。当使用 `text/html` 作为 `Content-Type` 时，它指示传输的数据是 HTML 格式的文档或片段。HTML 是构建网页和网页应用的标准标记语言，它定义了网页的结构和内容。

     在 `text/html` 格式中，数据组织如下：

     1. **HTML 标签**:

        - HTML 文档由一系列标签构成，这些标签描述了页面的不同部分和内容。

        - 例如，一个简单的 HTML 文档可能看起来像这样：

          ```
          htmlCopy code<!DOCTYPE html>
          <html>
          <head>
            <title>Example Page</title>
          </head>
          <body>
            <h1>Hello, world!</h1>
            <p>This is a simple HTML example.</p>
          </body>
          </html>
          ```

        - 这里，`<html>`, `<head>`, `<title>`, `<body>`, `<h1>`, 和 `<p>` 都是 HTML 标签。

     2. **属性**:

        - HTML 标签可以有属性，这些属性提供了关于标签的额外信息。

        - 例如，在一个链接 (`<a>`) 标签中，href 属性指定链接的目标地址：

          ```
          <a href="https://www.example.com">Visit Example.com</a>
          ```

     3. **结构和布局**:

        - HTML 定义了网页的结构和布局，例如段落、标题、列表、表格等。
        - 还可以通过 CSS (Cascading Style Sheets) 来增强这些元素的视觉样式。

     4. **嵌入内容**:

        - HTML 还允许嵌入图片、视频、音频和其他媒体类型，以及通过 `<script>` 标签嵌入或引用 JavaScript 代码。

     `text/html` 是网页和网络应用最基本的组成部分，它使得文本能够以丰富的格式显示在网页浏览器中。当浏览器接收到 `text/html` 格式的响应时，它会解析 HTML 文档，并根据其内容渲染页面。

     

7. **`application/octet-stream`**

   在前端需要以二进制形式传递数据给后端时，通常使用的是 `application/octet-stream`。这种 `Content-Type` 用于传输原始的二进制数据。它不假定任何特定的数据结构，格式，或编码，因此是传输未加工的二进制数据的理想选择。

   使用场景包括：

   1. **文件上传**:
      - 当上传未知类型或不需要特别处理的文件时，可以使用 `application/octet-stream`。这适用于后端仅需要存储或转发文件数据而不需要处理其内容的情况。
   2. **下载和上传大型二进制数据**:
      - 对于大型的二进制数据，如图像、视频、音频文件或其他媒体类型，`application/octet-stream` 可以作为一种高效的传输方式。
   3. **自定义二进制格式的数据**:
      - 如果前端和后端之间有自定义的二进制数据格式（如特定于应用程序的协议），那么使用 `application/octet-stream` 会很合适。

   在使用 `application/octet-stream` 时，前端通常需要以 `Blob` 或 `ArrayBuffer` 的形式处理数据。后端则需要能够接收并正确处理原始二进制流。这种方式的一个关键考虑是确保前端和后端对数据的处理和解释保持一致。

   

   在前端获取文件并将其以有效的二进制形式传给后端，通常涉及以下几个步骤：

   1. **获取文件**:

      - 通常通过 HTML `<input>` 元素的 `type="file"` 获取用户选择的文件。

      - 例如：

        ```
        <input type="file" id="fileInput">
        ```

   2. **读取文件内容**:

      - 使用 JavaScript 的 `FileReader` API 来读取文件内容。
      - 可以选择读取为 `ArrayBuffer`（适用于任何二进制数据）或者 `Blob` 对象。

   3. **构建表单数据或直接发送**:

      - 如果是通过表单上传，使用 `FormData` 对象添加文件。
      - 也可以直接将读取到的 `Blob` 或 `ArrayBuffer` 数据通过 `fetch` 或 `XMLHttpRequest` 发送。

   4. **发送请求**:

      - 使用 `fetch` API 或 `XMLHttpRequest` 向后端发送请求。
      - 在请求中设置正确的 `Content-Type`（如果直接发送二进制数据，通常是 `application/octet-stream`）。

   具体的 JavaScript 示例代码如下：

   **通过 `FormData` 发送文件**

   ```
   // 获取文件输入元素
   const input = document.getElementById('fileInput');
   
   // 添加 'change' 事件监听器
   input.addEventListener('change', function(event) {
     const file = event.target.files[0];
     const formData = new FormData();
   
     // 将文件添加到 FormData 对象
     formData.append('file', file);
   
     // 发送 FormData 对象到后端
     fetch('/upload', {
       method: 'POST',
       body: formData
     })
     .then(response => response.json())
     .then(data => console.log(data))
     .catch(error => console.error('Error:', error));
   });
   ```

   **直接发送二进制数据**

   ```
   javascriptCopy codeinput.addEventListener('change', function(event) {
     const file = event.target.files[0];
     const reader = new FileReader();
   
     reader.onload = function(event) {
       // 获取 ArrayBuffer
       const arrayBuffer = event.target.result;
   
       // 发送二进制数据到后端
       fetch('/upload', {
         method: 'POST',
         body: arrayBuffer,
         headers: {
           'Content-Type': 'application/octet-stream'
         }
       })
       .then(response => response.json())
       .then(data => console.log(data))
       .catch(error => console.error('Error:', error));
     };
   
     // 以 ArrayBuffer 的形式读取文件
     reader.readAsArrayBuffer(file);
   });
   ```

   在这两种方法中，重要的是确保后端能够正确处理接收到的数据格式。如果你使用 `FormData`，后端通常会解析表单数据并将文件作为文件对象处理。如果直接发送二进制数据，后端需要能够解析原始的二进制流。

   

这些 `Content-Type` 类型是用于指定 HTTP 请求和响应中内容的数据格式，帮助服务器解析接收到的数据以及告诉客户端如何解析响应数据。不同的后端框架和前端库可能在处理这些类型时有所不同，但这些是最通用的类型。





### 上传FormData格式的数据

一般通过js原生提供的FormData构造函数创建实例，然后在实例上设置文件名和起对应的文件对象，然后再将这个FormData实例对象通过Ajax传递给后端即可，注意设置请求头信息中的content-type字段的值为`multipart/form-data`。

```js
const fm = new FormData()

fm.append(key,value)   // 这些key和value需要和后端商量，使用什么字段和值；文件对象又用什么key
fm.append('filename',file)

axios.psot('http://xxx.com/xxx',fm, {
  headers:{
    'Content-Type':'multipart/form-data'
  }
})
```



axios封装点：

1. default.baseURL

2. default.headers

3. default.transformRequest，用于在发送请求之前对请求的数据进行转换。这个功能允许你在请求被发送到服务器之前对请求体（request body）进行自定义处理。

   以下是 `default.transformRequest` 的一些关键点：

   1. **默认行为**:
      - 在不配置 `transformRequest` 的情况下，`axios` 默认会将 JavaScript 对象转换为 JSON 字符串，如果 `Content-Type` 是 `application/json` 的话。
      - 对于 `FormData`、`Blob`、`ArrayBuffer` 和 `URLSearchParams` 类型的数据，`axios` 默认不会进行转换。
   2. **自定义转换**:
      - 通过提供一个函数或函数数组，你可以自定义如何转换请求数据。
      - 这在你需要修改请求数据，或者在发送之前将数据格式化为特定格式时非常有用。
   3. **使用方式**:
      - `transformRequest` 函数接收请求的数据和请求头作为参数。
      - 你应该返回一个字符串、`Buffer`、`ArrayBuffer`、`FormData`、`Stream`、`URLSearchParams` 或者简单保留原样。

对于 `axios` 中的 GET 请求，`transformRequest` 也是有效的，但其应用场景可能与 POST 或其他请求方法略有不同。在 GET 请求中，通常不会发送请求体（request body），因此 `transformRequest` 主要用于修改请求头或进行其他不涉及请求体的转换。

由于 GET 请求没有请求体，所以如果你尝试在 `transformRequest` 中修改请求体，它可能不会有任何实际效果。然而，这个功能可以用于以下目的：

1. **修改请求头**:
   - 对于某些场景，你可能需要根据请求的特定条件动态地修改请求头。
2. **日志记录或监控**:
   - 可以使用 `transformRequest` 来记录请求信息，例如记录请求发送前的时间戳。
3. **预处理请求数据**:
   - 尽管 GET 请求通常不包含请求体，但在某些情况下，你可能需要对即将发送的查询参数（URL 中的参数）进行预处理或序列化，尽管这通常更适合在请求发起之前或通过其他方式进行。

下面是一个简单的例子，演示了如何在 GET 请求中使用 `transformRequest` 来修改请求头：

```
javascriptCopy codeaxios.get('/your-endpoint', {
  transformRequest: [(data, headers) => {
    // 修改请求头
    headers['Custom-Header'] = 'CustomValue';
    return data;
  }]
});
```

在这个例子中，`transformRequest` 用于向请求添加一个自定义的请求头。需要注意的是，由于 GET 请求没有请求体，所以 `data` 参数在这种情况下是没有意义的。





**默认情况下，axios将 JavaScript 对象序列化为 `JSON` 。** 要以`application/x-www-form-urlencoded`格式发送数据，您可以使用以下选项之一。

在浏览器中，可以使用[`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) API，如下所示：

```js
const params = new URLSearchParams();
params.append('param1', 'value1');
params.append('param2', 'value2');
axios.post('/foo', params);
```

> 请注意，不是所有的浏览器(参见 [caniuse.com](http://www.caniuse.com/#feat=urlsearchparams))都支持 `URLSearchParams` ，但是可以使用[polyfill](https://github.com/WebReflection/url-search-params) (确保 polyfill 全局环境)

或者, 可以使用[`qs`](https://github.com/ljharb/qs) 库编码数据:

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```

或者用另一种方式 (ES6),

```js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
```



当前端要以base64格式传文件给后端时，可以使用x-www-form-urlencoded的格式进行传递，但是在传递文件时，需要想将文件转为base64格式，然后再通过，如qs库，将需要传递给后端的数据转为xxx=xxx&xxx=xxx。 







### 基于FormData上传文件

单一文件的上传

```html
<div class="container">
  <div class="item">
    <h3>单一文件上传TFORM-DATAJ</h3>
    <section class="upload_box">
      <input type="file" class="upload_inp">  
      <div class="upload button box">
        <button class="upload button select">选择文件</button>
        <button class="upload button upload">上传到服务器</button>
    </div>
      <div class="upload tp">只能上传 PNG/JPG/JPEG 格式图片，且大小不能超过2MB</div>
      <ul class="upload_list">
    		<!-- <li>
				<span>文件:...</span><span><em>移除</em></span></li> -->
    </ul>
    </section>
</div>
```

input type='file'文件默认通过css隐藏，因为样式差。通过自己写的按钮事件来触发input框的change事件。

对于按钮是否可以正常点击会进行判断，同时不可点击时，会通过css改变按钮的样式。

重点：

- 点击按钮，通过js代码触发input框的点击事件， inputEle.click()

- 当用户选择文件，获取用户选择的文件

  ```js
  inputEle.addEventListener('change',function (event){
    // 获取用户选中的文件对象， 该文件在inputEle对象的files上，该files属性是一个类数组对象
    const file = this.files[0]
    if(!file) return 
    
    // 限制文件上传格式   这是方式一    
    if(!/(png|jpg|jpeg|gif)/i.test(file.type)){
      alert('请上传正确格式的文件')
      return 
    }
    
    // 限制文件类型的方式二，  <input type='file' accept='.png,.jpeg,.jpg'>
    
    
    // 限制文件上传大小
    if(file.size >2*1024*1024){
      alert('上传文件不能超过2mb')
      return 
    }
    
    
  })
  ```

  文件对象的格式：

  - size表示选中的文件的大小，单位是字节
  - type表示文件的类型
  - name表示文件名字

  ![image-20231113190922831](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231113190922831.png)



将文件对象上传到服务器：

服务器接口说明：

- post请求
- 请求头content-type：'multipart/form-data'
- 服务器一般会规定该Fom实例对象需要添加的字段和值，比如file字段存文件对象，filename字段存文件名
- 上传成功后，后端给到上传成功的状态码和一些信息，其中一般会包含上传文件在服务器中地址信息字段等

```js
const formData = new FormData()
formData.append('file',fileObj)
formData.append('filename',fileObj.name)

axios.post('xxxxx/xxxx',formData,{
  'Content-Type':'multipart/form-data'
}).then(response=>{
  // ...
},reason=>{
  // ...
})
```



**后端部分代码**

服务器端上传文件的处理借助了一个库——multiparty来实现。

```js

/*-API-*/
// 延迟函数
const delay = function delay(interval) {
    typeof interval !== "number" ? interval = 1000 : null;
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, interval);
    });
};

// 基于multiparty插件实现文件上传处理 & form-data解析
// auto表示是否使用插件自动处理文件的上传
const uploadDir = `${__dirname}/upload`;
const multiparty_upload = function multiparty_upload(req, auto=false) {
    let config = {
        maxFieldsSize: 200 * 1024 * 1024,
    };
    if (auto) config.uploadDir = uploadDir;
    return new Promise(async (resolve, reject) => {
        await delay();
      
      	// Form方法就是根据config配置对象，将客户端传递的FormData格式的数据进行处理
        new multiparty.Form(config)
            .parse(req, (err, fields, files) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({
                    fields,
                    files
                });
            });
    });
};

// 单文件上传处理「FORM-DATA」
app.post('/upload_single', async (req, res) => {
    try {
        let {
            files
        } = await multiparty_upload(req, true);
        let file = (files.file && files.file[0]) || {};
        res.send({
            code: 0,
            codeText: 'upload success',
            originalFilename: file.originalFilename,
            servicePath: file.path.replace(__dirname, HOSTNAME)
        });
    } catch (err) {
        res.send({
            code: 1,
            codeText: err
        });
    }
},{
  headers:{
    'Content-Type':'multipart/form-data'
  }
});
```





### 基于base64上传图片文件

base64一般只适合上传图片类文件。基于原生JS的FileReader类将文件对象转为base64等格式。前端将base64格式的图片文件传给后端，后端解析base64文件为图片并存下来。

重点是：

1. 基于原生js提供的FileReader构造函数将文件对象通过readAsDataURL方法转为base64

```js
const fileReader = new FileReader()
fileReader.readAsDataURL(fileObj)
fileReader.onload = (event)=>{
  const base64 = event.target.result
  axios.post('xxxx/xxx',Qs.stringify({
    file:encodeURIComponent(base64),  // 服务端进行解码后处理
    filename:fileObj.name
  }),{
    headers:{
      'Content-Type':'application/x-www-form-urlencoded'
    }
  })
}
```





后端代码逻辑：

文件名是后端根据文件内容生成的唯一值，但有些情况下，后端可能要求前端来生成唯一文件名并传给后端直接使用。

```js
// 创建文件并写入到指定的目录 & 返回客户端结果
const writeFile = function writeFile(res, path, file, filename, stream) {
  return new Promise((resolve, reject) => {
    if (stream) {
      try {
        let readStream = fs.createReadStream(file.path),
            writeStream = fs.createWriteStream(path);
        readStream.pipe(writeStream);
        readStream.on('end', () => {
          resolve();
          fs.unlinkSync(file.path);
          res.send({
            code: 0,
            codeText: 'upload success',
            originalFilename: filename,
            servicePath: path.replace(__dirname, HOSTNAME)
          });
        });
      } catch (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
      }
      return;
    }
    fs.writeFile(path, file, err => {
      if (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
        return;
      }
      resolve();
      res.send({
        code: 0,
        codeText: 'upload success',
        originalFilename: filename,
        servicePath: path.replace(__dirname, HOSTNAME)
      });
    });
  });
};

// 检测文件是否存在
const exists = function exists(path) {
  return new Promise(resolve => {
    fs.access(path, fs.constants.F_OK, err => {
      if (err) {
        resolve(false);
        return;
      }
      resolve(true);
    });
  });
};


// 单文件上传处理「BASE64」
app.post('/upload_single_base64', async (req, res) => {
  let file = req.body.file,
      filename = req.body.filename,
      spark = new SparkMD5.ArrayBuffer(),  // 用SparkMD5根据文件二进制内容生成唯一的文件名
      suffix = /\.([0-9a-zA-Z]+)$/.exec(filename)[1],
      isExists = false,
      path;
  file = decodeURIComponent(file);
  file = file.replace(/^data:image\/\w+;base64,/, "");
  file = Buffer.from(file, 'base64');
  spark.append(file);
  path = `${uploadDir}/${spark.end()}.${suffix}`;
  await delay();
  // 检测是否存在
  isExists = await exists(path);
  if (isExists) {
    res.send({
      code: 0,
      codeText: 'file is exists',
      originalFilename: filename,
      servicePath: path.replace(__dirname, HOSTNAME)
    });
    return;
  }
  writeFile(res, path, file, filename, false);
});
```



### 前端缩略图展示和命名

- 前端生成文件唯一文件名
- 缩略图展示，基于base64，然后赋值给img标签的src属性即可
- 如果前后端都不做文件名唯一化处理，那么不同用户上传相同的文件名的不同文件时，一定会存在冲突，要么是后上传的覆盖新上传的，要么是判断有同名文件的情况下，不再存储后来的文件
- 客户端用spark-md5库来实现，spark-md5需要接收的是文件对象二进制buffer数据进行处理

```js
 const fileReader = new FileReader()
fileReader.readAsArrayBuffer(fileObj)
fileReader.onload = (event)=>{
  const buf = event.target.result
  const spark = new SparkMD5.ArrayBuffer()  // 用SparkMD5根据文件二进制内容生成唯一的文件名
  let HASH;
  spark.append(file);
  HASH = spark.end();   // 这就是文件的唯一hash名，但是没有后缀
  const suffix = /\.([0-9a-zA-Z]+)$/.exec(fileObj.name)[1]; // 文件名后缀
  
  const formData = new FormData()
  formData.append('file',fileObj)
  formData.append('filename',`${HASH}.${suffix}`)

  axios.post('xxxxx/xxxx',formData,{
    'Content-Type':'multipart/form-data'
  }).then(response=>{
    // ...
  },reason=>{
    // ...
  })
  
}
```

后端代码：

```js

// 创建文件并写入到指定的目录 & 返回客户端结果
const writeFile = function writeFile(res, path, file, filename, stream) {
  return new Promise((resolve, reject) => {
    if (stream) {
      try {
        let readStream = fs.createReadStream(file.path),
            writeStream = fs.createWriteStream(path);
        readStream.pipe(writeStream);
        readStream.on('end', () => {
          resolve();
          fs.unlinkSync(file.path);
          res.send({
            code: 0,
            codeText: 'upload success',
            originalFilename: filename,
            servicePath: path.replace(__dirname, HOSTNAME)
          });
        });
      } catch (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
      }
      return;
    }
    fs.writeFile(path, file, err => {
      if (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
        return;
      }
      resolve();
      res.send({
        code: 0,
        codeText: 'upload success',
        originalFilename: filename,
        servicePath: path.replace(__dirname, HOSTNAME)
      });
    });
  });
};


// 检测文件是否存在
const exists = function exists(path) {
  return new Promise(resolve => {
    fs.access(path, fs.constants.F_OK, err => {
      if (err) {
        resolve(false);
        return;
      }
      resolve(true);
    });
  });
};


// 基于multiparty插件实现文件上传处理 & form-data解析
const uploadDir = `${__dirname}/upload`;
const multiparty_upload = function multiparty_upload(req, auto=false) {
  let config = {
    maxFieldsSize: 200 * 1024 * 1024,
  };
  if (auto) config.uploadDir = uploadDir;
  return new Promise(async (resolve, reject) => {
    new multiparty.Form(config)
      .parse(req, (err, fields, files) => {
      if (err) {
        reject(err);
        return;
      }
      resolve({
        fields,
        files
      });
    });
  });
};

app.post('/upload_single_name', async (req, res) => {
  try {
    let {
      fields,
      files
    } = await multiparty_upload(req);
    let file = (files.file && files.file[0]) || {},
        filename = (fields.filename && fields.filename[0]) || "",
        path = `${uploadDir}/${filename}`,
        isExists = false;
    // 检测是否存在
    isExists = await exists(path);
    if (isExists) {
      res.send({
        code: 0,
        codeText: 'file is exists',
        originalFilename: filename,
        servicePath: path.replace(__dirname, HOSTNAME)
      });
      return;
    }
    writeFile(res, path, file, filename, true);
  } catch (err) {
    res.send({
      code: 1,
      codeText: err
    });
  }
});
```



### 上传进度条

基于的axios提供的`onUploadProgress`，它允许为上传处理进度事件   onUploadProgress: function (progressEvent) {    // 处理原生进度事件  }。

axios本质是基于Ajax的，而XMLHttpRequest构造函数的实例对象上有一个uoload属性，该属性值上有一个onprogress事件。

```js
{
  // `onUploadProgress` 允许为上传处理进度事件
  // 浏览器专属
  onUploadProgress: function (progressEvent) {
    // 处理原生进度事件
  },

  // `onDownloadProgress` 允许为下载处理进度事件
  // 浏览器专属
  onDownloadProgress: function (progressEvent) {
    // 处理原生进度事件
  },
}
```

![image-20231114190758260](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231114190758260.png)



### 多文件上传

给input标签添加multiple属性。

```js
inputElem.addEventListener('change',()=>{
  let files = this.files
})
```

![image-20231114191747148](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231114191747148.png)





### 拖拽上传文件

需要给容器元素绑定拖拽事件，典型的拖拽事件有：

1. dragenter
2. dragleave
3. dragover
4. drop

浏览器对于拖拽到浏览器界面的文件，默认会尝试去打开并展示它。但是可以通过阻止默认行为来阻止。

```js
uploadContainer.addEventListener('dragover'，function(ev){
  ev.preventDefault()
})

uploadContainer.addEventListener('drop',function(ev){
  ev.preventDefault()
  const fileObj = ev.dataTransfer.files[0]  // 获取文件对象
})
```



### 大文件上传

切片上传以及断点续传。

思路：前端将大文件进行切片，切成一部分一部分的内容，一点点传给后端，后端每接收到一部分就将这一部分存在一个零时的文件夹下面，整个大文件的切片都存在这个对应的临时文件夹下面。当前端传送完所有的文件切片后，最后再发一个请求给后端说明文件切片都传递完毕，让后端将所有的临时文件夹下的切片文件合并为一个完整的大文件，然后将操作结果响应给前端即可。

断点续传：如果前一次已经有部分文件切片被上传到后端，下一次再次上传同一个大文件时，可以先请求服务器，以获取已经上传过的文件切片，前端根据这个信息只将剩下的需要上传的切片进行上传即可。   如果服务器没有提供提前查询已上传的切片的接口，前端可以依旧完全上传所有切片，只是这时后端会去一个个切片进行校验，已经存在的切片直接跳过不再处理。

 断点续传一定是基于切片上传的。

注意点：

- 前端将大文件切成许多切片，这些切片的名字一般比较固定，根据文件内容生成hash_index.[ext]
- 后端以前端文件切片的hash生成一个临时文件夹，用于存放同一个大文件的切片，最后再合并所有切片



```js
 const fileReader = new FileReader()
fileReader.readAsArrayBuffer(fileObj)
fileReader.onload = (event)=>{
  const buf = event.target.result
  const spark = new SparkMD5.ArrayBuffer()  // 用SparkMD5根据文件二进制内容生成唯一的文件名
  let HASH;
  spark.append(file);
  HASH = spark.end();   // 这就是文件的唯一hash名，但是没有后缀
  const suffix = /\.([0-9a-zA-Z]+)$/.exec(fileObj.name)[1]; // 文件名后缀
  
  const formData = new FormData()
  formData.append('file',fileObj)
  formData.append('filename',`${HASH}.${suffix}`)

  axios.post('xxxxx/xxxx',formData,{
    'Content-Type':'multipart/form-data'
  }).then(response=>{
    // ...
  },reason=>{
    // ...
  })
  
}
```











## 新部分

- 简历编写
- 项目经历如何编写
  - **明确项目名称和你的角色**：首先要清晰地标注项目的名称以及你在项目中扮演的角色
  - **使用简洁、明了的语言**：用简洁明了的语言描述你的项目经验。避免过多的技术术语，使得非技术人员也能理解。
  - **突出使用的技术和工具**：列出你在项目中使用的主要技术和工具，例如React, Vue, JavaScript, CSS, Git等。
  - **详细描述你的贡献**：具体描述你在项目中的工作，包括你负责的部分、你如何实现它、遇到的挑战以及你是如何克服这些挑战的。
  - **展示成果和影响**：如果可能，提供一些具体的成果，比如提高了网站的性能、增加了用户参与度、或者优化了代码结构等。使用数据和百分比来支持你的成果是一个很好的方法。
  - **项目成就和学习**：简述你从这个项目中学到了什么，以及这些经验如何帮助你成长为一个更好的前端开发者。
  - **保持简洁和相关性**：如果你有多个项目经验，选择最相关和最有影响力的项目来展示。保持每个项目描述的简洁，避免冗长和不必要的细节。
  - **视觉效果**：可以适当地使用列表、粗体或斜体来强调关键信息，使简历更具可读性。
  - **项目的亮点和难点**（自己也要精心准备如何回答）
- 项目亮点挖掘
- 大文件上传亮点



### 项目经历示例：

项目名称：xxxxxx

角色：前端团队负责人（主力开发）

项目时间：xxx年xx月 — xxx年xx月

使用技术栈：xxx，xxxxx，xxxx，xxx

项目概述: 作为前端团队的负责人，我带领一个由八名工程师组成的团队，完成了对我们公司核心产品--一款企业级数据分析平台的全面重构。这个项目的目标是提升平台的性能、增强用户体验，并引入新的数据可视化功能。

主要贡献：

- 设计并实现了全新的前端架构，使用了最新的React和Redux技术，以支持更加动态和交互式的用户界面。
- 引入D3.js来开发高度定制化的数据可视化组件，大大提升了报告的清晰度和交互性。
- 优化Webpack配置，将加载时间减少了40%，显著提升了应用性能。
- 制定并执行了全面的前端测试策略，使用Jest进行单元测试和集成测试，确保代码质量和应用稳定性。
- 主导前端团队的日常工作，包括代码审查、技术指导和决策制定，同时协助项目管理，确保项目按时交付。

项目难点：

- 性能优化:最大的挑战是优化复杂数据处理的性能。需要确保大量数据的实时处理和染不会影响应用的响应时间。
- 团队协作:协调一个多技能团队并保持进度一致，同时确保代码的一致性和质量，是一项挑战。
- 技术选型:选择合适的技术栈和工具来满足项目需求，同时考虑未来的可扩展性和维护性。

项目亮点：

- 创新的数据可视化:我们开发的自定义D3.js组件不仅提高了数据报告的可读性，还提升了用户的交互体验。
- 性能突破:通过优化前端架构和Webpack配置，实现了显著的性能提升，尤其是在数据密集型作中。
- 高标准的代码质量:实施严格的代码审查和全面的自动化测试，确保了应用的高可靠性和稳定性。

成果：

- 项目成功按期上线，用户反馈极佳，客户满意度提升20%
- 应用性能提升显著，页面加载时间减少了40%
- 新增的数据可视化功能极大地提高了产品的市场竞争力，帮助公司在行业中获得了更高的地位

学习与成长:：

这个项目不仅让我深化了对前端架构和性能优化的理解，还锻炼了我的团队管理和项目协调能力。通过这次经历，我学会了如何在保持技术创新的同时，有效地管理一个多元化的团队，确保项目目标的达成。



### 亮点示例

大文件上传，在回答面试时可以从这些维度进行展开或者讲解。

1. 基础概念
   - 描述在前端实现大文件上传的基本流程。
   - 解释为什么大文件上传比普通文件上传更具挑战性。
   - 什么是分片上传，它如何帮助在前端处理大文件上传?
2. 技术实现:
   - 如何在前端使用JavaScript实现大文件的切片上传?
   - 描述使用HTML5的File API来处理大文件上传的过程。
   - 在处理大文件上传时，如何在前端进行文件类型和大小的验证?
3. 性能优化:
   - 在大文件上传时，如何优化前端性能以提高用户体验?
   - 如果用户在上传过程中暂停或断网，你将如何处理已上传的数据?
   - 如何在前端实现上传进度的可视化反馈?
4. 错误处理和安全性:
   - 在大文件上传过程中，如果遇到网络错误或服务器错误，前端应该如何优雅地处理?
   - 描述在大文件上传中常见的安全问题及其解决方案。
   - 如何在前端实现大文件上传的加密处理?
5. 后端交互:
   - 大文件上传中的前后端协作通常是怎样的?请描述整个流程。
   - 如果后端API在上传过程中发生更改，前端应该如何灵活适应?
   - 在大文件上传中，前端和后端如何协调处理上传进度和错误恢复?
6. 用户体验:
   - 如何设计一个用户友好的大文件上传界面？
   - 在上传大文件时，如何减少对用户其他网站操作的影响？
   - 如果用户需要上传多个大文件，你将如何设计这个上传流程?
7. 现代技术和框架:
   - 使用React/AngularNue等现代前端框架，如何实现大文件上传的功能?
   - 在大文件上传中，Web Workers能发挥什么作用?
   - 描述使用云服务(如AWS S3)进行大文件上传的优势和挑战。



#### 大文件上传

##### 前端实现大文件上传的基本流程

在前端实现大文件上传的基本流程通常包括以下几个关键步骤：

1. **文件选择**：
   - 用户通过文件选择界面（通常是一个表单输入或拖放区域）选择要上传的文件。
   - 使用 HTML5 的 `File API` 来获取用户选择的文件信息。
2. **文件切片**：
   - 对于大文件，直接上传整个文件可能导致问题（如网络不稳定导致上传失败、浏览器崩溃等）。因此，将大文件切分成多个小块（通常称为“切片”）是一个常见做法。
   - 使用 JavaScript 将文件切分成多个小块。每个块可以是固定大小（如1MB）。
3. **上传前准备**：
   - 可以向服务器发送一个预请求，告知服务器将要上传的文件的信息（如文件名、文件大小、切片数量等）。
   - 服务器可以在此时进行一些准备工作，如检查文件是否已部分上传、为即将上传的文件分配资源等。
4. **并行或顺序上传切片**：
   - 切片可以并行上传，以提高上传效率，也可以顺序上传，以降低服务器压力。
   - 每个切片作为一个单独的请求发送到服务器。这些请求通常包含切片数据和一些元数据（如切片索引、总切片数等）。
5. **错误处理和重试机制**：
   - 在上传过程中，一些切片可能因网络问题或服务器问题上传失败。前端应该有机制来检测这些失败，并且能够重新尝试上传这些切片。
   - 可以设置重试次数限制，以避免无限重试。
6. **上传进度反馈**：
   - 在上传过程中，前端应提供实时的上传进度反馈。这可以通过监听每个切片上传请求的进度事件来实现。
7. **完成上传**：
   - 所有切片上传完成后，前端向服务器发送一个完成上传的信号。
   - 服务器收到完成信号后，开始将所有切片组合成原始文件。
8. **文件验证和清理**：
   - 服务器组合文件后，可以对文件进行验证，确保文件的完整性和正确性。
   - 验证完成后，前端和后端可以进行必要的清理工作，如删除已上传的切片文件。
9. **错误处理和用户反馈**：
   - 如果在任何上传阶段发生错误，应及时将错误信息反馈给用户。
   - 同时，前端应提供用户友好的错误信息和可能的解决方案。



##### 为什么大文件上传比普通文件上传更具挑战性

主要原因有几个：

1. **网络稳定性问题**：大文件上传需要更长的时间，这增加了网络连接中断的风险。如果在上传过程中出现网络问题，可能需要重新开始上传整个文件，这不仅浪费时间，还可能导致数据丢失。
2. **资源消耗**：上传大文件会占用更多的网络带宽和服务器资源。这可能导致服务器性能下降，影响其他用户的使用体验。
3. **浏览器和服务器限制**：某些浏览器和服务器对上传文件的大小有限制。大文件可能超出这些限制，需要特殊的配置或技术来处理。
4. **数据完整性和安全性**：在长时间的传输过程中，确保数据的完整性和安全性是一大挑战。需要采用额外的措施来保证文件在传输过程中不被损坏或篡改。
5. **用户体验问题**：大文件上传可能需要很长时间，这可能导致用户体验不佳。用户可能不清楚上传进度。

为了解决这些挑战，通常会采用一些策略，如文件分割上传（将大文件分割成小块，分别上传），断点续传（在连接中断后能从中断点重新开始上传），以及优化网络和服务器配置等。



##### 什么是分片上传，它如何帮助在前端处理大文件上传

分片上传是一种处理大文件上传的技术，它将大文件分割成多个小片段（分片），然后逐个上传这些分片。这种方法在前端处理大文件上传时具有多个优势：

1. **提高可靠性**：通过分片上传，即使在上传过程中发生网络问题，也只需要重新上传受影响的分片，而不是整个文件。这显著减少了因网络不稳定导致的重传需求。
2. **支持断点续传**：如果上传过程中断，可以在网络恢复后继续上传未完成的分片。这对于移动设备用户特别重要，因为他们可能会在不稳定的网络环境下上传文件。
3. **优化上传速度**：分片允许并行上传，可以同时上传多个分片，这样可以更有效地利用网络带宽，从而加快上传速度。
4. **减轻服务器负担**：服务器处理一系列小文件比处理一个大文件要容易。这有助于降低服务器的资源消耗，特别是在高负载情况下。
5. **灵活的错误处理**：在分片上传中，可以针对单个分片进行错误检测和恢复，而不是对整个文件进行处理。这提高了上传过程的稳定性和效率。
6. **进度控制和管理**：分片上传使得可以更精确地控制和展示上传进度，提高了用户体验。
7. **绕过文件大小限制**：某些浏览器或服务器对单次上传的文件大小有限制。分片上传可以绕过这些限制，因为每个分片都小于这个限制。

为了实现分片上传，前端需要具备将文件分割成分片的能力，并且后端服务器需要能够接收这些分片，并在所有分片上传完毕后将它们重新组装成原始文件。



##### 如何在前端使用JavaScript实现大文件的切片上传？

在前端使用JavaScript实现大文件的切片上传主要涉及以下几个步骤：

**1. 文件选择** 首先，你需要一个HTML元素让用户选择文件。通常使用`<input type="file">`元素：

```html
<input type="file" id="fileInput" />
```

**2. 读取文件** 当用户选择文件后，你可以使用File API来读取文件。这通常在一个事件监听器中完成，该监听器响应文件选择输入的更改：

```javascript
document.getElementById('fileInput').addEventListener('change', function(event) {
    var file = event.target.files[0]; // 获取选择的文件
    // 接下来可以处理这个文件
});
```

**3. 分片文件** 由于直接上传大文件可能会遇到各种问题，因此通常会将文件分割成更小的部分（分片）来上传。你可以使用`Blob.slice()`方法来分割文件：

```javascript
function sliceFile(file, chunkSize) {
    let chunks = [];
    let size = file.size;

    for (let start = 0; start < size; start += chunkSize) {
        let end = Math.min(start + chunkSize, size);
        chunks.push(file.slice(start, end));
    }

    return chunks;
}
```

在这个函数中，`chunkSize`是每个分片的大小（例如1MB），`chunks`数组包含了所有分片。

**4. 上传分片** 接下来，需要为每个分片创建一个`FormData`对象，并使用`XMLHttpRequest`或`fetch` API将它上传到服务器：

```javascript
async function uploadChunk(chunk, index) {
    let formData = new FormData();
    formData.append('file', chunk);
    formData.append('index', index);

    let response = await fetch('/upload', { // 服务器上传接口
        method: 'POST',
        body: formData
    });

    return response.ok;
}
```

**5. 合并分片** 一旦所有分片都成功上传到服务器，服务器需要一个机制来重新组合这些分片。这通常在服务器端的上传脚本中处理。

**6. 完整的上传过程** 将上述步骤结合起来，创建一个完整的上传过程：

```javascript
document.getElementById('fileInput').addEventListener('change', async (event) => {
    let file = event.target.files[0];
    let chunkSize = 1024 * 1024; // 例如，每个分片1MB
    let chunks = sliceFile(file, chunkSize);

    for (let i = 0; i < chunks.length; i++) {
        let success = await uploadChunk(chunks[i], i);
        if (!success) {
            console.error('Upload failed for chunk ' + i);
            return;
        }
    }

    console.log('File uploaded successfully');
});
```

**注意事项**

- **错误处理**：实际应用中需要考虑到错误处理和重试机制。
- **安全性**：确保服务器端安全地处理文件上传。
- **用户体验**：提供上传进度指示和必要的用户反馈。
- **并发和性能**：适当控制并发上传的分片数量，以平衡上传速度和服务器负载。



##### 在处理大文件上传时，如何在前端进行文件类型和大小的验证？

通常在文件选择后立即进行。以下是进行文件类型和大小的验证的步骤：

**1. 获取文件引用** 首先，需要获取到用户选择的文件。这通常是通过HTML的文件输入字段实现的：

```html
<input type="file" id="fileInput" />
```

在JavaScript中，你可以通过监听文件输入字段的变化来获取文件：

```javascript
document.getElementById('fileInput').addEventListener('change', function(event) {
    var file = event.target.files[0]; // 获取选择的文件
    // 接下来进行验证
});
```

**2. 验证文件大小** 要验证文件的大小，可以检查文件对象的`size`属性，该属性以字节为单位给出文件的大小。例如，如果你想限制文件大小不超过10MB，可以这样做：

```javascript
const MAX_SIZE = 10 * 1024 * 1024; // 10MB

if (file.size > MAX_SIZE) {
    alert('File is too large. Maximum size is 10MB.');
    return;
}
```

**3. 验证文件类型** 验证文件类型通常是通过检查文件的MIME类型（通过文件对象的`type`属性）或文件扩展名（通过文件名的字符串操作）。例如，如果你想允许用户上传JPEG和PNG图片，可以这样验证：

```javascript
const ALLOWED_TYPES = ['image/jpeg', 'image/png'];

if (!ALLOWED_TYPES.includes(file.type)) {
    alert('Invalid file type. Only JPEG and PNG are allowed.');
    return;
}
```

或者，通过文件扩展名验证：

```javascript
const ALLOWED_EXTENSIONS = ['.jpeg', '.jpg', '.png'];

if (!ALLOWED_EXTENSIONS.some(extension => file.name.endsWith(extension))) {
    alert('Invalid file type. Only JPEG and PNG are allowed.');
    return;
}
```

又或者判断文件的二进制前几位的值，因为不同类型的文件他们的二进制内容都有一部分是固定用于标识这是什么类型的文件的。



**4. 处理验证结果** 如果文件不符合要求，你可以向用户显示一个错误消息，并停止进一步的上传处理。如果文件通过验证，你可以继续上传处理。

**5. 综合示例** 将上述步骤结合，可以创建一个函数来处理文件选择和验证：

```javascript
document.getElementById('fileInput').addEventListener('change', function(event) {
    var file = event.target.files[0];

    // 验证文件大小
    const MAX_SIZE = 10 * 1024 * 1024; // 10MB
    if (file.size > MAX_SIZE) {
        alert('File is too large. Maximum size is 10MB.');
        return;
    }

    // 验证文件类型
    const ALLOWED_TYPES = ['image/jpeg', 'image/png'];
    if (!ALLOWED_TYPES.includes(file.type)) {
        alert('Invalid file type. Only JPEG and PNG are allowed.');
        return;
    }

    // 文件通过验证，继续处理上传
    // ...
});
```

**注意事项**

- 前端验证不是绝对安全的，因为它可以被绕过。因此，应该始终在服务器端再次验证文件类型和大小。
- 考虑到用户体验，应该在文件输入字段旁边或在文档中明确说明文件的类型和大小限制。



#### 业务背景和挑战

什么时候遇到的这个问题？ 大文件上传是许多在线应用和服务中的一个常见需求，尤其是在那些需要处理视频、音频、大型文档集或高分辨率图片的场景中。这项功能的业务背景和挑战可以从多个角度来看：

 **业务背景**

1. **媒体处理**：视频编辑平台、音频处理软件、图像库等需要上传大量媒体文件。
2. **数据备份与迁移**：企业需要备份或迁移大量数据，包括数据库文件、系统镜像等。
3. **内容分发网络**：在CDN中上传大文件以便更快地在全球范围内分发。
4. **科学与研究**：上传大型数据集，例如基因组序列、气象模型数据等。
5. **教育和在线学习**：上传高质量的教学视频和教材。
6. **法律和财务**：共享大量的法律文档或财务报表。

**挑战**

1. **性能问题**：大文件上传可能导致客户端（浏览器）性能下降，特别是在资源有限的设备上。
2. **网络不稳定**：大文件更有可能在上传过程中遇到网络问题，如断线、超时等。
3. **服务器负载**：大文件上传会给服务器带来更大的负载，特别是在处理大量此类请求时。
4. **用户体验**：长时间的上传过程可能导致用户感到不耐烦，影响用户体验。
5. **文件完整性和安全性**：确保文件在传输过程中不被破坏或篡改，同时保证数据的隐私和安全。
6. **断点续传**：支持在网络中断后能够继续上传，而不是重新开始。
7. **数据处理**：大文件需要更复杂的处理流程，例如切片、压缩和解压缩。
8. **兼容性和标准化**：确保各种浏览器和设备都能顺利完成上传过程。





![image-20240819220655042](images\image-20240819220655042.png)

#### 原理与实现

##### 拖拽上传



##### 检查和预览



##### 分片上传



##### 上传进度





##### 秒传



##### 暂停上传



##### 断点续传





#### 难点扩展

- web worker
- 失败重传
- 文件加密
- 传输加密
- 文件压缩处理







