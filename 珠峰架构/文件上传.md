# 文件上传



功能点：

- 整体上传
- 分片上传
- 进度条
- 秒传
- 断点续传(支持单个分片续传和刷新浏览器续传)
- 暂停和恢复

文件上传原理：

- 根据 http 协议

## FileReader 构造函数

该构造函数的实例对象可以将文件内容读取到内存中，同时实例对象上有一些列的异步方法，用于访问读取结果。

使用 FileReader 对象，web 应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用 File 对象或者 Blob 对象来指定所要处理的文件或数据。

创建实例

```js
var reader = new FileReader();
```

实例方法

- abort( ) ：终止文件读取操作
- readAsArrayBuffer(file)：异步按字节读取文件内容，结果用 ArrayBuffer 对象表示
- readAsBinaryString(file)： 异步按字节读取文件内容，结果为文件的二进制串
- readAsDataURL(file)： 异步读取文件内容，结果用 data:url 的字符串形式表示
- readAsText(file,encoding)： 异步按字符读取文件内容，结果用字符串形式表示

事件

- onabort：当读取操作被中止时调用
- onerror：当读取操作发生错误时调用
- onload：当读取操作成功完成时调用
- onloadend： 当读取操作完成时调用,不管是成功还是失败
- onloadstart：当读取操作将要开始之前调用
- onprogress：在读取数据过程中周期性调用

使用

FileReader 通过异步的方式读取文件内容，结果均是通过事件回调获取，下面是一个读取本地 txt 文件内容的例子：

```js
var input = document.getElementById('file'); //input file
input.onchange = function () {
  var file = this.files[0];
  if (!!file) {
    //读取本地文件，以gbk编码方式输出
    var reader = new FileReader();
    reader.readAsText(file, 'gbk');
    reader.onload = function () {
      //读取完毕后输出结果
      console.log(this.result);
    };
  }
};
```

读取方式

- readAsArrayBuffer(file)：异步按字节读取文件内容，结果用 ArrayBuffer 对象表示
- readAsBinaryString(file)： 异步按字节读取文件内容，结果为文件的二进制串
- readAsDataURL(file)： 异步读取文件内容，结果用 data:url 的字符串形式表示
- readAsText(file,encoding)： 异步按字符读取文件内容，结果用字符串形式表示

测试读取文件，一张图片（6764 字节）和一个 txt 文本（51 字节）作为测试文件：

![image-20220529204603554](..\typora-user-images\image-20220529204603554.png)

### readAsDataURL

readAsDataURL 会将文件内容进行 base64 编码后输出

```js
var file = this.files[0];
var reader = new FileReader();
reader.readAsDataURL(file);
reader.onload = function () {
  //读取完毕后输出结果
  console.log(this.result);
  //查看文件内容字节大小
  console.log(new Blob([this.result]));
};
```

图片输出结果：

![image-20220529204805480](..\typora-user-images\image-20220529204805480.png)

txt 输出结果：

![image-20220529204818584](..\typora-user-images\image-20220529204818584.png)

### readAsText

readAsText 可以通过不同的编码方式读取字符，默认使用`utf-8`读取

```js
var file = this.files[0];
var reader = new FileReader();
reader.readAsText(file, 'uft-8');
reader.onload = function () {
  //读取完毕后输出结果
  console.log(this.result);
  //查看文件内容字节大小
  console.log(new Blob([this.result]));
};
```

图片输出结果：

![image-20220529205041943](..\typora-user-images\image-20220529205041943.png)

txt 输出结果：

![image-20220529205109365](..\typora-user-images\image-20220529205109365.png)

readAsText 读取文件的单位是字符，故对于文本文件，只要按规定的编码方式读取即可；而对于媒体文件（图片、音频、视频），其内部组成并不是按字符排列，故采用 readAsText 读取，会产生乱码，同时也不是最理想的读取文件的方式。

### readAsBinaryString

与 readAsText 不同的是，readAsBinaryString 函数会按字节读取文件内容。然而诸如 0101 的二进制数据只能被机器识别，若想对外可见，还是需要进行一次编码，而 readAsBinaryString 的结果就是读取二进制并编码后的内容。尽管 readAsBinaryString 方法可以按字节读取文件，但由于读取后的内容被编码为字符，大小会受到影响，故不适合直接传输，也不推荐使用。

```js
var file = this.files[0];
var reader = new FileReader();
reader.readAsBinaryString(file);
reader.onload = function () {
  //读取完毕后输出结果
  console.log(this.result);
  //查看文件内容字节大小
  console.log(new Blob([this.result]));
};
```

图片输出结果：

![image-20220529205243535](..\typora-user-images\image-20220529205243535.png)

txt 输出结果：

![image-20220529205250231](..\typora-user-images\image-20220529205250231.png)

### readAsArrayBuffer

与 readAsBinaryString 类似，readAsArrayBuffer 方法会按字节读取文件内容，并转换为 ArrayBuffer 对象。文件读取后大小与原文件大小一致。这也就是 readAsArrayBuffer 与 readAsBinaryString 方法的区别，readAsArrayBuffer 读取文件后，会在内存中创建一个 ArrayBuffer 对象（二进制缓冲区），将二进制数据存放在其中。通过此方式，可以直接在网络中传输二进制内容。

简单理解为存放了一段二进制数据的内存空间。

图片输出结果：

![image-20220529205511740](..\typora-user-images\image-20220529205511740.png)

txt 输出结果：

![image-20220529205517955](..\typora-user-images\image-20220529205517955.png)

ArrayBuffer 中的内容对外是不可见的，若要查看其中的内容，就要引入另一个概念：类型化数组我们可以尝试查看下刚刚通过 readAsArrayBuffer 方法读取的图片文件内容：

![image-20220529205802442](..\typora-user-images\image-20220529205802442.png)

可以看到，整个图片文件的 6764 个字节，被分别存储在长度为 6764 的数组中，而数组中每一个元素的值，为当前字节的十进制数值。

### 应用场景

img 的 src 属性或 background 的 url 属性，可以通过被赋值为图片网络地址或 base64 的方式显示图片。

一般上传文件的处理方式：一般会先将本地文件上传到服务器，上传成功后，由后台返回图片的网络地址再在前端显示。

#### 本地图片预览

前端本地图片上传前的预览，通过 FileReader 的 readAsDataURL 方法，可以不经过后台，直接将本地图片显示在页面上。这样做可以减少前后端频繁的交互过程，减少服务器端无用的图片资源，代码如下：

```js
var input = document.getElementById('file'); // input file
input.onchange = function () {
  var file = this.files[0];
  if (!!file) {
    var reader = new FileReader();
    // 图片文件转换为base64
    reader.readAsDataURL(file);
    reader.onload = function () {
      // 显示图片
      document.getElementById('file_img').src = this.result;
    };
  }
};
```

对于图片上传，我们也可以先将图片转换为 base64 进行传输，此时由于传输的图片内容就是一段字符串，故上传接口可以当做普通 post 接口处理，当图片传输到后台后，可以在转换为文件实体存储。当然，考虑到 base64 转换效率及其本身的大小，本方法还是适合于上传内容简单或所占内存较小的文件。

## 上传图片的类型限制

### 方式一

通过 `input` 元素的 `accept` 属性来限制上传的文件类型

```html
.png格式:
<input type="file" id="inputFile" accept="image/png" />

.xls格式:
<input text="file" accept="application/vnd.ms-excel" />

.xslx格式:
<input text="fiel" accept="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />

图片:
<input type="file" accept="image/*" />
```

不足：如果用户把 JPEG 格式的图片后缀名更改为 `.png` 的话，就可以突破这个限制。

### 方式二

读取文件的二进制数据来识别正确的文件类型。**计算机并不是通过图片的后缀名来区分不同的图片类型，而是通过 “魔数”（Magic Number）来区分。**对于某一些类型的文件，起始的几个字节内容都是固定的，根据这几个字节的内容就可以判断文件的类型。

常见图片类型对应的魔数如下表所示：

| 文件类型 | 文件后缀 | 魔数                      |
| :------- | :------- | :------------------------ |
| JPEG     | jpg/jpeg | 0xFF D8 FF                |
| PNG      | png      | 0x89 50 4E 47 0D 0A 1A 0A |
| GIF      | gif      | 0x47 49 46 38（GIF8）     |
| BMP      | bmp      | 0x42 4D                   |

- 通过 input type="file" 标签获取到文件对象
- 通过 FileReader API 来读取文件的二进制内容（不需要读取文件的完整信息，读取开头特定的长度可以）

读取文件中指定范围的二进制数据方法：

```js
function readBuffer(file, start = 0, end = 2) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file.slice(start, end));
  });
}
```

- 逐一判断每个字节的内容是否一致

```js
function check(headers) {
  return (buffers, options = { offset: 0 }) =>
    headers.every((header, index) => header === buffers[options.offset + index]);
}
```

- 检测 PNG 图片类型

```html
<div>
  选择文件：<input type="file" id="inputFile" accept="image/*" onchange="handleChange(event)" />
  <p id="realFileType"></p>
</div>
```

```js
const isPNG = check([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]); // PNG图片对应的魔数
const realFileElement = document.querySelector('#realFileType');

async function handleChange(event) {
  const file = event.target.files[0];
  const buffers = await readBuffer(file, 0, 8);
  const uint8Array = new Uint8Array(buffers);
  realFileElement.innerText = `${file.name}文件的类型是：${
    isPNG(uint8Array) ? 'image/png' : file.type
  }`;
}
```

## 二进制数据上传

基于 XHR2 可以直接上传或下载二进制内容，无需像以往一样通过 form 标签由后端拉取二进制内容。

简单整理下上传逻辑： 1、通过 input[type="file"]标签获取本地文件 File 对象 2、通过 FileReader 的 readAsArrayBuffer 方法将 File 对象转换为 ArrayBuffer 3、创建 xhr 对象，配置请求信息 4、通过 xhr.sendAsBinary 直接将文件的 ArrayBuffer 内容装填至 post body 后发送

代码实现如下：

```js
var input = document.getElementById('file'); // input file
input.onchange = function () {
  var file = this.files[0];
  if (!!file) {
    var reader = new FileReader();
    reader.readAsArrayBuffer(file);
    reader.onload = function () {
      var binary = this.result;
      upload(binary);
    };
  }
};

//文件上传
function upload(binary) {
  var xhr = new XMLHttpRequest();
  xhr.open('POST', 'http://xxxx/opload');
  xhr.overrideMimeType('application/octet-stream');
  //直接发送二进制数据
  if (xhr.sendAsBinary) {
    xhr.sendAsBinary(binary);
  } else {
    xhr.send(binary);
  }

  // 监听变化
  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        // 响应成功
      }
    }
  };
}
```

## 扩展

xhr.overrideMimeTyp 与 xhr.responseType

一般情况下服务器在处理完请求后，响应给浏览器的响应头中含有 content-type，用于告诉浏览器服务器返回的数据的类型，浏览器就可以根据该请求头的值自动识别并进行响应的处理。

overrideMimeType 方法的作用是用来重写`response`的`content-type`。

**注意:** xhr.overrideMimeType()方法在 send()之前调用

## Blob 对象

Blob 允许我们可以通过 JS 直接操作二进制数据。Blob 对象可以看做是存放二进制数据的容器，此外还可以通过 Blob 设置二进制数据的 MIME 类型。

一个 Blob 对象就是一个包含有只读原始数据的类文件对象。Blob 对象中的数据并不一定都是 JavaScript 中的原生形式。File 接口基于 Blob，继承了 Blob 的功能,并且扩展支持了用户计算机上的本地文件。

创建实例

```js
var blob = new Blob(dataArr:Array<any>, opt:{type:string});
```

- dataArray：数组，包含了要添加到 Blob 对象中的数据，数据可以是任意多个 ArrayBuffer，ArrayBufferView， Blob，或者 DOMString 对象。

- opt：对象，用于设置 Blob 对象的属性（如：MIME 类型）

1、创建一个装填 DOMString 对象的 Blob 对象

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214157975-1381640633.png)

2、创建一个装填 ArrayBuffer 对象的 Blob 对象

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214204991-1533610697.png)

3、创建一个装填 ArrayBufferView 对象的 Blob 对象（ArrayBufferView 可基于 ArrayBuffer 创建，返回值是一个类数组。如下：创建一个 8 字节的 ArrayBuffer，在其上创建一个每个数组元素为 2 字节的“视图”）

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214211507-2138861162.png)

通过 Blob.slice()

此方法返回一个新的 Blob 对象，包含了原 Blob 对象中指定范围内的数据

```less
Blob.slice(start:number, end:number, contentType:string)
```

- start：开始索引，默认为 0
- end：截取结束索引（不包括 end）
- contentType：新 Blob 的 MIME 类型，默认为空字符串

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214220586-1491607027.png)

通过 canvas.toBlob()

```javascript
var canvas = document.getElementById('canvas');
canvas.toBlob(function (blob) {
  console.log(blob);
});
```

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214233650-666441369.png)

### 应用

#### 分片上传

通过 Blob.slice 方法，可以将大文件分片，轮循向后台提交各文件片段，即可实现文件的分片上传。分片上传逻辑如下：

- 获取要上传文件的 File 对象，根据 chunk（每片大小）对文件进行分片
- 通过 post 方法轮循上传每片文件，其中 url 中拼接 querystring 用于描述当前上传的文件信息；post body 中存放本次要上传的二进制数据片段
- 接口每次返回 offset，用于执行下次上传

下面是分片上传的简单实现：

```js
initUpload();

//初始化上传
function initUpload() {
  var chunk = 100 * 1024; //每片大小
  var input = document.getElementById('file'); //input file
  input.onchange = function (e) {
    var file = this.files[0];
    var query = {};
    var chunks = [];
    if (!!file) {
      var start = 0;
      //文件分片
      for (var i = 0; i < Math.ceil(file.size / chunk); i++) {
        var end = start + chunk;
        chunks[i] = file.slice(start, end);
        start = end;
      }

      // 采用post方法上传文件
      // url query上拼接以下参数，用于记录上传偏移
      // post body中存放本次要上传的二进制数据
      query = {
        fileSize: file.size,
        dataSize: chunk,
        nextOffset: 0
      };

      upload(chunks, query, successPerUpload);
    }
  };
}

// 执行上传
function upload(chunks, query, cb) {
  var queryStr = Object.getOwnPropertyNames(query)
    .map((key) => {
      return key + '=' + query[key];
    })
    .join('&');
  var xhr = new XMLHttpRequest();
  xhr.open('POST', 'http://xxxx/opload?' + queryStr);
  xhr.overrideMimeType('application/octet-stream');

  //获取post body中二进制数据
  var index = Math.floor(query.nextOffset / query.dataSize);
  getFileBinary(chunks[index], function (binary) {
    if (xhr.sendAsBinary) {
      xhr.sendAsBinary(binary);
    } else {
      xhr.send(binary);
    }
  });

  xhr.onreadystatechange = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var resp = JSON.parse(xhr.responseText);
        // 接口返回nextoffset
        // resp = {
        //     isFinish:false,
        //     offset:100*1024
        // }
        if (typeof cb === 'function') {
          cb.call(this, resp, chunks, query);
        }
      }
    }
  };
}

// 每片上传成功后执行
function successPerUpload(resp, chunks, query) {
  if (resp.isFinish === true) {
    alert('上传成功');
  } else {
    //未上传完毕
    query.offset = resp.offset;
    upload(chunks, query, successPerUpload);
  }
}

// 获取文件二进制数据
function getFileBinary(file, cb) {
  var reader = new FileReader();
  reader.readAsArrayBuffer(file);
  reader.onload = function (e) {
    if (typeof cb === 'function') {
      cb.call(this, this.result);
    }
  };
}
```

以上是文件分片上传前端的简单实现，当然，此功能还可以更加完善，如后台需要对合并后的文件大小进行校验；或者前端加密文件，全部上传完毕后后端解密校验等。

#### 通过 url 下载文件

window.URL 对象可以为 Blob 对象生成一个网络地址，结合 a 标签的 download 属性，可以实现点击 url 下载文件实现如下：

```js
createDownload('download.txt', 'download file');

function createDownload(fileName, content) {
  var blob = new Blob([content]);
  var link = document.createElement('a');
  link.innerHTML = fileName;
  link.download = fileName;
  link.href = URL.createObjectURL(blob);
  document.getElementsByTagName('body')[0].appendChild(link);
}
```

执行后页面上会生成此 Blob 对象的地址，点击后可下载：

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214307058-499657467.png)

查看下载结果：

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214312934-1343358624.png)

#### 通过 url 显示图片

img 的 src 属性及 background 的 url 属性，都可以通过接收图片的网络地址或 base64 来显示图片，同样的，我们也可以把图片转化为 Blob 对象，生成 URL（URL.createObjectURL(blob)），来显示图片。

![img](https://images2015.cnblogs.com/blog/948198/201610/948198-20161002214320606-2044023964.png)











## 课程部分

基于js管理文件上传，大文件上传和断点续传



内容大纲：

- axios基础封装
- 前端后端通信的数据格式
- 基于FileReader读取文件和处理
- 基于spark-md5生成唯一文件名
- 上传文件的大小和类型限制
- 上传图片的缩略图展示
- 典型的文件上传方案：FormData和Base64
- 上传的进度条展示和控制
- 文件拖拽上传
- 大文件的切片上传和优化
- 多文件上传和进度管控
- 断点续传及其原理
- 服务器端nodejs的实现原理



项目依赖：

- axios：发送网络请求
- qs：基于对象数据类型生成key=value&key=value这样的字符串
- spark-md5：基于文件内容生成唯一的名字







前端部分代码和界面展示，后端部分代码展示。

![image-20231112101807106](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231112101807106.png)

后台程序将上传的文件存放到项目根目录下的upload目录中。



### Content-Type

在前后端通信中，常用的 `Content-Type` 类型有几种主要的类型，主要用于指定发送到服务器的数据的媒体类型。这些类型包括：



1. **`application/json`**:

   - 用于发送 JSON 格式的数据。

   - 常用于 REST API。

     

2. **`application/x-www-form-urlencoded`**:

   - 用于发送 HTML 表单格式的数据。

   - 数据以键值对的形式发送，键和值都进行了 URL 编码。

   - 每个键和值都被编码为等号 (`=`) 分隔的形式，而不同的键值对之间则用 `&` 符号连接（格式类似于 URL 查询字符串的格式）。

   - **单个键值对**:

     - 假设你有一个名为 name 的字段，其值为 Alice，那么编码后的数据将是：

       ```
       name=Alice
       ```

   - **多个键值对**:

     - 假设你有两个字段，name 值为 Alice

        和 age 值为 30，则编码后的数据将是：

       ```
       name=Alice&age=30
       ```

   - **包含空格和特殊字符**:

     - 如果值包含空格或特殊字符，这些字符将被 URL 编码。例如，name 为 Alice Smith 和 city 为 New York 的数据将编码为：

       ```
       name=Alice%20Smith&city=New%20York
       ```

     - 在这个例子中，空格被编码为 `%20`。

   - **包含数组或复杂结构**:

     - 对于简单的键值对，这种格式非常有效，但对于包含数组或更复杂结构的数据，这种格式可能不太适用。例如，尝试表示数组（如 colors=["red", "green", "blue"]）时，可能需要将其转换为多个键值对：

       ```
       colors=red&colors=green&colors=blue
       ```

     - 或者使用某种约定来表示数组，如：

       ```
       colors[]=red&colors[]=green&colors[]=blue
       ```

   在实际应用中，浏览器的 HTML 表单和大多数前端框架都会自动处理这种编码。当使用 `application/x-www-form-urlencoded` 作为 `Content-Type` 时，这种数据格式被广泛用于发送简单的文本数据。

   

   在 `application/x-www-form-urlencoded` 格式中，参数通常**不是**拼接在 URL 中传给后端的，而是作为请求体（request body）的一部分发送。这与 URL 参数（通常用于 GET 请求）是不同的。

   以下是这两种情况的对比：

   1. **URL 参数（Query Strings）**:
      - 主要用于 GET 请求。
      - 参数拼接在 URL 的末尾，如 `http://example.com/api?name=Alice&age=30`。
      - 适用于发送少量数据。
   2. **请求体（Request Body）**:
      - 在 `application/x-www-form-urlencoded` 格式下，数据作为 HTTP 请求的体部分发送。
      - 主要用于 POST 请求。
      - URL 保持不变，如 `http://example.com/api`，而数据（如 `name=Alice&age=30`）包含在请求体中。

   这种编码格式常见于 HTML 表单提交，其中表单数据编码为键值对，并在 POST 请求的请求体中发送到服务器。这使得它适合发送大量或复杂的数据，**与 URL 参数不同，它不受 URL 长度限制**。

   

3. **`multipart/form-data`**:

   - 用于发送包含文件上传的表单数据。

   - 除了文件，还可以用来发送文本字段。

   - 是一种用于 HTTP 请求的编码类型，主要用于在表单中上传文件。这种格式允许将表单数据分成多个部分（或 "part"），每个部分包含一段数据。这种格式特别适合于文件上传，因为它允许在单个请求中发送二进制数据（如文件内容）和非二进制字段。

     在 `multipart/form-data` 格式中，数据通常按以下方式组织：

     1. **多部分格式**:
        - 每个表单元素（如文本字段、文件等）都作为消息的一个部分发送。
        - 部分之间由特殊的分隔符分隔，这个分隔符在请求的 `Content-Type` 头中定义。
     2. **文本字段和文件**:
        - 文本字段以普通文本形式发送。
        - 文件以它们的原始二进制格式发送。
     3. **头信息**:
        - 每个部分通常包含一些头信息，如 `Content-Disposition`，其中包含字段名和文件名（对于文件字段）。

     例如，假设你有一个表单，其中包含一个名为 `name` 的文本字段和一个用于上传文件的字段 `file`。在 `multipart/form-data` 格式中，请求体可能看起来像这样：

     ```
     --boundary12345
     Content-Disposition: form-data; name="name"
     
     Alice
     --boundary12345
     Content-Disposition: form-data; name="file"; filename="example.txt"
     Content-Type: text/plain
     
     [文件内容]
     --boundary12345--
     ```

     在这个例子中，`boundary12345` 是部分之间的分隔符。每个部分首先包含描述其内容的头信息，然后是实际的数据。

     由于其多部分和二进制友好的特性，`multipart/form-data` 是处理表单上传，特别是文件上传的理想选择。它比 `application/x-www-form-urlencoded` 更复杂，但它允许更灵活和高效的数据传输。

     

4. **`text/plain`**:

   - 纯文本数据。

   - 较少使用，因为它不提供额外的结构信息。

   - 不含任何特殊的结构或编码，它就是纯粹的文本内容，没有像 JSON 或 XML 那样的键值对、标签或特殊符号来表示数据结构。

   - **单纯文本**:

     - 只包含普通的文本字符。
     - 例如：`Hello, world!`

   - **没有特定结构**:

     - 不支持复杂的数据结构，如对象、数组或键值对。
     - 所有内容都是连续的文本，没有用于数据分隔或组织的特殊字符。

   - **不支持特殊编码**:

     - 与 `application/json` 或 `application/xml` 不同，`text/plain` 不支持内部结构化或特殊编码。
     - 换行符和空格在文本中原样表示。

     

5. **`application/xml` 或 `text/xml`**:

   - 用于发送 XML 数据。

   - 像 `application/json`，但使用 XML 格式。

   - 用于在 HTTP 请求和响应中发送 XML (eXtensible Markup Language) 数据。XML 是一种标记语言，用于描述和传输结构化数据。它使用自定义标签来定义数据结构，使得数据既易于阅读，又易于机器处理。

     在 `application/xml` 格式中，数据通常按以下方式组织：

     1. **标签和元素**:

        - XML 数据由一系列嵌套的标签组成，每个标签代表数据的一个元素。

        - 例如：

          ```
          xmlCopy code<person>
            <name>Alice</name>
            <age>30</age>
          </person>
          ```

        - 这个例子中有一个根元素 `<person>`，包含两个子元素：`<name>` 和 `<age>`。

     2. **属性**:

        - XML 元素可以有属性，这些属性提供关于元素的附加信息。

        - 例如：

          ```
          xmlCopy code<person role="user">
            <name>Alice</name>
            <age>30</age>
          </person>
          ```

        - 这里，`person` 元素有一个 `role` 属性，其值为 `"user"`。

     3. **层次结构和嵌套**:

     4. XML 支持复杂的层次结构和嵌套元素，允许表示复杂的数据结构。

        - 例如：

          ```
          xmlCopy code<person role="user">
            <name>Alice</name>
            <age>30</age>
            <address>
              <street>Main Street</street>
              <city>Wonderland</city>
            </address>
          </person>
          ```

        - 在这个例子中，`address` 是一个嵌套元素，包含 `street` 和 `city` 元素。

     5. **声明和字符编码**:

        - XML 文档通常以 XML 声明开始，指明版本和字符编码。

        - 例如：

          ```
          xmlCopy code<?xml version="1.0" encoding="UTF-8"?>
          <person>...</person>
          ```

        `application/xml` 格式的使用在某些领域，如企业系统集成、配置文件和网络协议（如 SOAP），仍然非常流行。它提供了一种灵活而强大的方式来表示和传输结构化数据。然而，由于其冗长和复杂性，JSON 在许多现代 Web 应用程序中已经取代了 XML 作为首选的数据交换格式。

        

6. **`text/html`**:

   - 主要用于返回 HTML 格式的响应数据。

   - 是一种用于发送 HTML (HyperText Markup Language) 格式数据的 MIME 类型。当使用 `text/html` 作为 `Content-Type` 时，它指示传输的数据是 HTML 格式的文档或片段。HTML 是构建网页和网页应用的标准标记语言，它定义了网页的结构和内容。

     在 `text/html` 格式中，数据组织如下：

     1. **HTML 标签**:

        - HTML 文档由一系列标签构成，这些标签描述了页面的不同部分和内容。

        - 例如，一个简单的 HTML 文档可能看起来像这样：

          ```
          htmlCopy code<!DOCTYPE html>
          <html>
          <head>
            <title>Example Page</title>
          </head>
          <body>
            <h1>Hello, world!</h1>
            <p>This is a simple HTML example.</p>
          </body>
          </html>
          ```

        - 这里，`<html>`, `<head>`, `<title>`, `<body>`, `<h1>`, 和 `<p>` 都是 HTML 标签。

     2. **属性**:

        - HTML 标签可以有属性，这些属性提供了关于标签的额外信息。

        - 例如，在一个链接 (`<a>`) 标签中，href 属性指定链接的目标地址：

          ```
          <a href="https://www.example.com">Visit Example.com</a>
          ```

     3. **结构和布局**:

        - HTML 定义了网页的结构和布局，例如段落、标题、列表、表格等。
        - 还可以通过 CSS (Cascading Style Sheets) 来增强这些元素的视觉样式。

     4. **嵌入内容**:

        - HTML 还允许嵌入图片、视频、音频和其他媒体类型，以及通过 `<script>` 标签嵌入或引用 JavaScript 代码。

     `text/html` 是网页和网络应用最基本的组成部分，它使得文本能够以丰富的格式显示在网页浏览器中。当浏览器接收到 `text/html` 格式的响应时，它会解析 HTML 文档，并根据其内容渲染页面。

     

7. **`application/octet-stream`**

   在前端需要以二进制形式传递数据给后端时，通常使用的是 `application/octet-stream`。这种 `Content-Type` 用于传输原始的二进制数据。它不假定任何特定的数据结构，格式，或编码，因此是传输未加工的二进制数据的理想选择。

   使用场景包括：

   1. **文件上传**:
      - 当上传未知类型或不需要特别处理的文件时，可以使用 `application/octet-stream`。这适用于后端仅需要存储或转发文件数据而不需要处理其内容的情况。
   2. **下载和上传大型二进制数据**:
      - 对于大型的二进制数据，如图像、视频、音频文件或其他媒体类型，`application/octet-stream` 可以作为一种高效的传输方式。
   3. **自定义二进制格式的数据**:
      - 如果前端和后端之间有自定义的二进制数据格式（如特定于应用程序的协议），那么使用 `application/octet-stream` 会很合适。

   在使用 `application/octet-stream` 时，前端通常需要以 `Blob` 或 `ArrayBuffer` 的形式处理数据。后端则需要能够接收并正确处理原始二进制流。这种方式的一个关键考虑是确保前端和后端对数据的处理和解释保持一致。

   

   在前端获取文件并将其以有效的二进制形式传给后端，通常涉及以下几个步骤：

   1. **获取文件**:

      - 通常通过 HTML `<input>` 元素的 `type="file"` 获取用户选择的文件。

      - 例如：

        ```
        <input type="file" id="fileInput">
        ```

   2. **读取文件内容**:

      - 使用 JavaScript 的 `FileReader` API 来读取文件内容。
      - 可以选择读取为 `ArrayBuffer`（适用于任何二进制数据）或者 `Blob` 对象。

   3. **构建表单数据或直接发送**:

      - 如果是通过表单上传，使用 `FormData` 对象添加文件。
      - 也可以直接将读取到的 `Blob` 或 `ArrayBuffer` 数据通过 `fetch` 或 `XMLHttpRequest` 发送。

   4. **发送请求**:

      - 使用 `fetch` API 或 `XMLHttpRequest` 向后端发送请求。
      - 在请求中设置正确的 `Content-Type`（如果直接发送二进制数据，通常是 `application/octet-stream`）。

   具体的 JavaScript 示例代码如下：

   **通过 `FormData` 发送文件**

   ```
   // 获取文件输入元素
   const input = document.getElementById('fileInput');
   
   // 添加 'change' 事件监听器
   input.addEventListener('change', function(event) {
     const file = event.target.files[0];
     const formData = new FormData();
   
     // 将文件添加到 FormData 对象
     formData.append('file', file);
   
     // 发送 FormData 对象到后端
     fetch('/upload', {
       method: 'POST',
       body: formData
     })
     .then(response => response.json())
     .then(data => console.log(data))
     .catch(error => console.error('Error:', error));
   });
   ```

   **直接发送二进制数据**

   ```
   javascriptCopy codeinput.addEventListener('change', function(event) {
     const file = event.target.files[0];
     const reader = new FileReader();
   
     reader.onload = function(event) {
       // 获取 ArrayBuffer
       const arrayBuffer = event.target.result;
   
       // 发送二进制数据到后端
       fetch('/upload', {
         method: 'POST',
         body: arrayBuffer,
         headers: {
           'Content-Type': 'application/octet-stream'
         }
       })
       .then(response => response.json())
       .then(data => console.log(data))
       .catch(error => console.error('Error:', error));
     };
   
     // 以 ArrayBuffer 的形式读取文件
     reader.readAsArrayBuffer(file);
   });
   ```

   在这两种方法中，重要的是确保后端能够正确处理接收到的数据格式。如果你使用 `FormData`，后端通常会解析表单数据并将文件作为文件对象处理。如果直接发送二进制数据，后端需要能够解析原始的二进制流。

   

这些 `Content-Type` 类型是用于指定 HTTP 请求和响应中内容的数据格式，帮助服务器解析接收到的数据以及告诉客户端如何解析响应数据。不同的后端框架和前端库可能在处理这些类型时有所不同，但这些是最通用的类型。





### 上传FormData格式的数据

一般通过js原生提供的FormData构造函数创建实例，然后在实例上设置文件名和起对应的文件对象，然后再将这个FormData实例对象通过Ajax传递给后端即可，注意设置请求头信息中的content-type字段的值为`multipart/form-data`。

```js
const fm = new FormData()

fm.append(key,value)   // 这些key和value需要和后端商量，使用什么字段和值；文件对象又用什么key
fm.append('filename',file)

axios.psot('http://xxx.com/xxx',fm, {
  headers:{
    'Content-Type':'multipart/form-data'
  }
})
```



axios封装点：

1. default.baseURL

2. default.headers

3. default.transformRequest，用于在发送请求之前对请求的数据进行转换。这个功能允许你在请求被发送到服务器之前对请求体（request body）进行自定义处理。

   以下是 `default.transformRequest` 的一些关键点：

   1. **默认行为**:
      - 在不配置 `transformRequest` 的情况下，`axios` 默认会将 JavaScript 对象转换为 JSON 字符串，如果 `Content-Type` 是 `application/json` 的话。
      - 对于 `FormData`、`Blob`、`ArrayBuffer` 和 `URLSearchParams` 类型的数据，`axios` 默认不会进行转换。
   2. **自定义转换**:
      - 通过提供一个函数或函数数组，你可以自定义如何转换请求数据。
      - 这在你需要修改请求数据，或者在发送之前将数据格式化为特定格式时非常有用。
   3. **使用方式**:
      - `transformRequest` 函数接收请求的数据和请求头作为参数。
      - 你应该返回一个字符串、`Buffer`、`ArrayBuffer`、`FormData`、`Stream`、`URLSearchParams` 或者简单保留原样。

对于 `axios` 中的 GET 请求，`transformRequest` 也是有效的，但其应用场景可能与 POST 或其他请求方法略有不同。在 GET 请求中，通常不会发送请求体（request body），因此 `transformRequest` 主要用于修改请求头或进行其他不涉及请求体的转换。

由于 GET 请求没有请求体，所以如果你尝试在 `transformRequest` 中修改请求体，它可能不会有任何实际效果。然而，这个功能可以用于以下目的：

1. **修改请求头**:
   - 对于某些场景，你可能需要根据请求的特定条件动态地修改请求头。
2. **日志记录或监控**:
   - 可以使用 `transformRequest` 来记录请求信息，例如记录请求发送前的时间戳。
3. **预处理请求数据**:
   - 尽管 GET 请求通常不包含请求体，但在某些情况下，你可能需要对即将发送的查询参数（URL 中的参数）进行预处理或序列化，尽管这通常更适合在请求发起之前或通过其他方式进行。

下面是一个简单的例子，演示了如何在 GET 请求中使用 `transformRequest` 来修改请求头：

```
javascriptCopy codeaxios.get('/your-endpoint', {
  transformRequest: [(data, headers) => {
    // 修改请求头
    headers['Custom-Header'] = 'CustomValue';
    return data;
  }]
});
```

在这个例子中，`transformRequest` 用于向请求添加一个自定义的请求头。需要注意的是，由于 GET 请求没有请求体，所以 `data` 参数在这种情况下是没有意义的。





**默认情况下，axios将 JavaScript 对象序列化为 `JSON` 。** 要以`application/x-www-form-urlencoded`格式发送数据，您可以使用以下选项之一。

在浏览器中，可以使用[`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) API，如下所示：

```js
const params = new URLSearchParams();
params.append('param1', 'value1');
params.append('param2', 'value2');
axios.post('/foo', params);
```

> 请注意，不是所有的浏览器(参见 [caniuse.com](http://www.caniuse.com/#feat=urlsearchparams))都支持 `URLSearchParams` ，但是可以使用[polyfill](https://github.com/WebReflection/url-search-params) (确保 polyfill 全局环境)

或者, 可以使用[`qs`](https://github.com/ljharb/qs) 库编码数据:

```js
const qs = require('qs');
axios.post('/foo', qs.stringify({ 'bar': 123 }));
```

或者用另一种方式 (ES6),

```js
import qs from 'qs';
const data = { 'bar': 123 };
const options = {
  method: 'POST',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  data: qs.stringify(data),
  url,
};
axios(options);
```



当前端要以base64格式传文件给后端时，可以使用x-www-form-urlencoded的格式进行传递，但是在传递文件时，需要想将文件转为base64格式，然后再通过，如qs库，将需要传递给后端的数据转为xxx=xxx&xxx=xxx。 







### 基于FormData上传文件

单一文件的上传

```html
<div class="container">
  <div class="item">
    <h3>单一文件上传TFORM-DATAJ</h3>
    <section class="upload_box">
      <input type="file" class="upload_inp">  
      <div class="upload button box">
        <button class="upload button select">选择文件</button>
        <button class="upload button upload">上传到服务器</button>
    </div>
      <div class="upload tp">只能上传 PNG/JPG/JPEG 格式图片，且大小不能超过2MB</div>
      <ul class="upload_list">
    		<!-- <li>
				<span>文件:...</span><span><em>移除</em></span></li> -->
    </ul>
    </section>
</div>
```

input type='file'文件默认通过css隐藏，因为样式差。通过自己写的按钮事件来触发input框的change事件。

对于按钮是否可以正常点击会进行判断，同时不可点击时，会通过css改变按钮的样式。

重点：

- 点击按钮，通过js代码触发input框的点击事件， inputEle.click()

- 当用户选择文件，获取用户选择的文件

  ```js
  inputEle.addEventListener('change',function (event){
    // 获取用户选中的文件对象， 该文件在inputEle对象的files上，该files属性是一个类数组对象
    const file = this.files[0]
    if(!file) return 
    
    // 限制文件上传格式   这是方式一    
    if(!/(png|jpg|jpeg|gif)/i.test(file.type)){
      alert('请上传正确格式的文件')
      return 
    }
    
    // 限制文件类型的方式二，  <input type='file' accept='.png,.jpeg,.jpg'>
    
    
    // 限制文件上传大小
    if(file.size >2*1024*1024){
      alert('上传文件不能超过2mb')
      return 
    }
    
    
  })
  ```

  文件对象的格式：

  - size表示选中的文件的大小，单位是字节
  - type表示文件的类型
  - name表示文件名字

  ![image-20231113190922831](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231113190922831.png)



将文件对象上传到服务器：

服务器接口说明：

- post请求
- 请求头content-type：'multipart/form-data'
- 服务器一般会规定该Fom实例对象需要添加的字段和值，比如file字段存文件对象，filename字段存文件名
- 上传成功后，后端给到上传成功的状态码和一些信息，其中一般会包含上传文件在服务器中地址信息字段等

```js
const formData = new FormData()
formData.append('file',fileObj)
formData.append('filename',fileObj.name)

axios.post('xxxxx/xxxx',formData,{
  'Content-Type':'multipart/form-data'
}).then(response=>{
  // ...
},reason=>{
  // ...
})
```



**后端部分代码**

服务器端上传文件的处理借助了一个库——multiparty来实现。

```js

/*-API-*/
// 延迟函数
const delay = function delay(interval) {
    typeof interval !== "number" ? interval = 1000 : null;
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, interval);
    });
};

// 基于multiparty插件实现文件上传处理 & form-data解析
// auto表示是否使用插件自动处理文件的上传
const uploadDir = `${__dirname}/upload`;
const multiparty_upload = function multiparty_upload(req, auto=false) {
    let config = {
        maxFieldsSize: 200 * 1024 * 1024,
    };
    if (auto) config.uploadDir = uploadDir;
    return new Promise(async (resolve, reject) => {
        await delay();
      
      	// Form方法就是根据config配置对象，将客户端传递的FormData格式的数据进行处理
        new multiparty.Form(config)
            .parse(req, (err, fields, files) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve({
                    fields,
                    files
                });
            });
    });
};

// 单文件上传处理「FORM-DATA」
app.post('/upload_single', async (req, res) => {
    try {
        let {
            files
        } = await multiparty_upload(req, true);
        let file = (files.file && files.file[0]) || {};
        res.send({
            code: 0,
            codeText: 'upload success',
            originalFilename: file.originalFilename,
            servicePath: file.path.replace(__dirname, HOSTNAME)
        });
    } catch (err) {
        res.send({
            code: 1,
            codeText: err
        });
    }
},{
  headers:{
    'Content-Type':'multipart/form-data'
  }
});
```





### 基于base64上传图片文件

base64一般只适合上传图片类文件。基于原生JS的FileReader类将文件对象转为base64等格式。前端将base64格式的图片文件传给后端，后端解析base64文件为图片并存下来。

重点是：

1. 基于原生js提供的FileReader构造函数将文件对象通过readAsDataURL方法转为base64

```js
const fileReader = new FileReader()
fileReader.readAsDataURL(fileObj)
fileReader.onload = (event)=>{
  const base64 = event.target.result
  axios.post('xxxx/xxx',Qs.stringify({
    file:encodeURIComponent(base64),  // 服务端进行解码后处理
    filename:fileObj.name
  }),{
    headers:{
      'Content-Type':'application/x-www-form-urlencoded'
    }
  })
}
```





后端代码逻辑：

文件名是后端根据文件内容生成的唯一值，但有些情况下，后端可能要求前端来生成唯一文件名并传给后端直接使用。

```js
// 创建文件并写入到指定的目录 & 返回客户端结果
const writeFile = function writeFile(res, path, file, filename, stream) {
  return new Promise((resolve, reject) => {
    if (stream) {
      try {
        let readStream = fs.createReadStream(file.path),
            writeStream = fs.createWriteStream(path);
        readStream.pipe(writeStream);
        readStream.on('end', () => {
          resolve();
          fs.unlinkSync(file.path);
          res.send({
            code: 0,
            codeText: 'upload success',
            originalFilename: filename,
            servicePath: path.replace(__dirname, HOSTNAME)
          });
        });
      } catch (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
      }
      return;
    }
    fs.writeFile(path, file, err => {
      if (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
        return;
      }
      resolve();
      res.send({
        code: 0,
        codeText: 'upload success',
        originalFilename: filename,
        servicePath: path.replace(__dirname, HOSTNAME)
      });
    });
  });
};

// 检测文件是否存在
const exists = function exists(path) {
  return new Promise(resolve => {
    fs.access(path, fs.constants.F_OK, err => {
      if (err) {
        resolve(false);
        return;
      }
      resolve(true);
    });
  });
};


// 单文件上传处理「BASE64」
app.post('/upload_single_base64', async (req, res) => {
  let file = req.body.file,
      filename = req.body.filename,
      spark = new SparkMD5.ArrayBuffer(),  // 用SparkMD5根据文件二进制内容生成唯一的文件名
      suffix = /\.([0-9a-zA-Z]+)$/.exec(filename)[1],
      isExists = false,
      path;
  file = decodeURIComponent(file);
  file = file.replace(/^data:image\/\w+;base64,/, "");
  file = Buffer.from(file, 'base64');
  spark.append(file);
  path = `${uploadDir}/${spark.end()}.${suffix}`;
  await delay();
  // 检测是否存在
  isExists = await exists(path);
  if (isExists) {
    res.send({
      code: 0,
      codeText: 'file is exists',
      originalFilename: filename,
      servicePath: path.replace(__dirname, HOSTNAME)
    });
    return;
  }
  writeFile(res, path, file, filename, false);
});
```



### 前端缩略图展示和命名

- 前端生成文件唯一文件名
- 缩略图展示，基于base64，然后赋值给img标签的src属性即可
- 如果前后端都不做文件名唯一化处理，那么不同用户上传相同的文件名的不同文件时，一定会存在冲突，要么是后上传的覆盖新上传的，要么是判断有同名文件的情况下，不再存储后来的文件
- 客户端用spark-md5库来实现，spark-md5需要接收的是文件对象二进制buffer数据进行处理

```js
 const fileReader = new FileReader()
fileReader.readAsArrayBuffer(fileObj)
fileReader.onload = (event)=>{
  const buf = event.target.result
  const spark = new SparkMD5.ArrayBuffer()  // 用SparkMD5根据文件二进制内容生成唯一的文件名
  let HASH;
  spark.append(file);
  HASH = spark.end();   // 这就是文件的唯一hash名，但是没有后缀
  const suffix = /\.([0-9a-zA-Z]+)$/.exec(fileObj.name)[1]; // 文件名后缀
  
  const formData = new FormData()
  formData.append('file',fileObj)
  formData.append('filename',`${HASH}.${suffix}`)

  axios.post('xxxxx/xxxx',formData,{
    'Content-Type':'multipart/form-data'
  }).then(response=>{
    // ...
  },reason=>{
    // ...
  })
  
}
```

后端代码：

```js

// 创建文件并写入到指定的目录 & 返回客户端结果
const writeFile = function writeFile(res, path, file, filename, stream) {
  return new Promise((resolve, reject) => {
    if (stream) {
      try {
        let readStream = fs.createReadStream(file.path),
            writeStream = fs.createWriteStream(path);
        readStream.pipe(writeStream);
        readStream.on('end', () => {
          resolve();
          fs.unlinkSync(file.path);
          res.send({
            code: 0,
            codeText: 'upload success',
            originalFilename: filename,
            servicePath: path.replace(__dirname, HOSTNAME)
          });
        });
      } catch (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
      }
      return;
    }
    fs.writeFile(path, file, err => {
      if (err) {
        reject(err);
        res.send({
          code: 1,
          codeText: err
        });
        return;
      }
      resolve();
      res.send({
        code: 0,
        codeText: 'upload success',
        originalFilename: filename,
        servicePath: path.replace(__dirname, HOSTNAME)
      });
    });
  });
};


// 检测文件是否存在
const exists = function exists(path) {
  return new Promise(resolve => {
    fs.access(path, fs.constants.F_OK, err => {
      if (err) {
        resolve(false);
        return;
      }
      resolve(true);
    });
  });
};


// 基于multiparty插件实现文件上传处理 & form-data解析
const uploadDir = `${__dirname}/upload`;
const multiparty_upload = function multiparty_upload(req, auto=false) {
  let config = {
    maxFieldsSize: 200 * 1024 * 1024,
  };
  if (auto) config.uploadDir = uploadDir;
  return new Promise(async (resolve, reject) => {
    new multiparty.Form(config)
      .parse(req, (err, fields, files) => {
      if (err) {
        reject(err);
        return;
      }
      resolve({
        fields,
        files
      });
    });
  });
};

app.post('/upload_single_name', async (req, res) => {
  try {
    let {
      fields,
      files
    } = await multiparty_upload(req);
    let file = (files.file && files.file[0]) || {},
        filename = (fields.filename && fields.filename[0]) || "",
        path = `${uploadDir}/${filename}`,
        isExists = false;
    // 检测是否存在
    isExists = await exists(path);
    if (isExists) {
      res.send({
        code: 0,
        codeText: 'file is exists',
        originalFilename: filename,
        servicePath: path.replace(__dirname, HOSTNAME)
      });
      return;
    }
    writeFile(res, path, file, filename, true);
  } catch (err) {
    res.send({
      code: 1,
      codeText: err
    });
  }
});
```



### 上传进度条

基于的axios提供的`onUploadProgress`，它允许为上传处理进度事件   onUploadProgress: function (progressEvent) {    // 处理原生进度事件  }。

axios本质是基于Ajax的，而XMLHttpRequest构造函数的实例对象上有一个uoload属性，该属性值上有一个onprogress事件。

```js
{
  // `onUploadProgress` 允许为上传处理进度事件
  // 浏览器专属
  onUploadProgress: function (progressEvent) {
    // 处理原生进度事件
  },

  // `onDownloadProgress` 允许为下载处理进度事件
  // 浏览器专属
  onDownloadProgress: function (progressEvent) {
    // 处理原生进度事件
  },
}
```

![image-20231114190758260](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231114190758260.png)



### 多文件上传

给input标签添加multiple属性。

```js
inputElem.addEventListener('change',()=>{
  let files = this.files
})
```

![image-20231114191747148](C:/Users/shuyi/Desktop/learn-notes/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/images/image-20231114191747148.png)





### 拖拽上传文件

需要给容器元素绑定拖拽事件，典型的拖拽事件有：

1. dragenter
2. dragleave
3. dragover
4. drop

浏览器对于拖拽到浏览器界面的文件，默认会尝试去打开并展示它。但是可以通过阻止默认行为来阻止。

```js
uploadContainer.addEventListener('dragover'，function(ev){
  ev.preventDefault()
})

uploadContainer.addEventListener('drop',function(ev){
  ev.preventDefault()
  const fileObj = ev.dataTransfer.files[0]  // 获取文件对象
})
```



### 大文件上传

切片上传以及断点续传。

思路：前端将大文件进行切片，切成一部分一部分的内容，一点点传给后端，后端每接收到一部分就将这一部分存在一个零时的文件夹下面，整个大文件的切片都存在这个对应的临时文件夹下面。当前端传送完所有的文件切片后，最后再发一个请求给后端说明文件切片都传递完毕，让后端将所有的临时文件夹下的切片文件合并为一个完整的大文件，然后将操作结果响应给前端即可。

断点续传：如果前一次已经有部分文件切片被上传到后端，下一次再次上传同一个大文件时，可以先请求服务器，以获取已经上传过的文件切片，前端根据这个信息只将剩下的需要上传的切片进行上传即可。   如果服务器没有提供提前查询已上传的切片的接口，前端可以依旧完全上传所有切片，只是这时后端会去一个个切片进行校验，已经存在的切片直接跳过不再处理。

 断点续传一定是基于切片上传的。

注意点：

- 前端将大文件切成许多切片，这些切片的名字一般比较固定，根据文件内容生成hash_index.[ext]
- 后端以前端文件切片的hash生成一个临时文件夹，用于存放同一个大文件的切片，最后再合并所有切片



```js
 const fileReader = new FileReader()
fileReader.readAsArrayBuffer(fileObj)
fileReader.onload = (event)=>{
  const buf = event.target.result
  const spark = new SparkMD5.ArrayBuffer()  // 用SparkMD5根据文件二进制内容生成唯一的文件名
  let HASH;
  spark.append(file);
  HASH = spark.end();   // 这就是文件的唯一hash名，但是没有后缀
  const suffix = /\.([0-9a-zA-Z]+)$/.exec(fileObj.name)[1]; // 文件名后缀
  
  const formData = new FormData()
  formData.append('file',fileObj)
  formData.append('filename',`${HASH}.${suffix}`)

  axios.post('xxxxx/xxxx',formData,{
    'Content-Type':'multipart/form-data'
  }).then(response=>{
    // ...
  },reason=>{
    // ...
  })
  
}
```































