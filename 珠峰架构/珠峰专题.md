珠峰专题

## 类（继承）（姜文）

ES6中的类和ES5中构造函数

在ES5中创建一个实例则需要通过new一个构造函数。构造函数创建的实例有两种属性：私有属性或方法和共有属性或方法。在构造函数的函数体内可以写一系列的其他代码逻辑。

```js
function Animal(){
	this.type = '哺乳类'
}
Animal.prototype.eat = function(){
	console.log('eat')
}
let animal = new Animal
既可以new执行也可以当作普通函数执行。我们一般并不会直接去实例化一个抽象类，比如上面的动物类，而是让其他类用于继承


function Tiger(){
	Animal.call(this)   // 继承了父类实例上的属性，但是还没有继承父类原型上的方法或者属性
}
如果要继承父类原型上的方法，可能的写法有：
Tiger.prototype = Animal.prototype   //这样做存在一个问题：父类和子类公用一个原型对象，那么子类在原型上添加的内容就能在父类上反应出来了，所以不合理。

改善的写法：(注意原型链中constructor的指向  )
Tiger.prototype.__proto__ = Animal.prototype     //写法一
Object.setPrototypeOf(Tiger.prototype, Animal.prototype)    //写法二
Tiger.prototype = Object.create(Animal.prototype, {constructor:{value:Tiger}})    //写法三

let tiger = new Tiger()
```

ps:一般构造函数的prototype属性是Object构造函数的一个实例，所以构造函数的`prototype.__proto__`一般指向Object.prototype,而`Object.prototype.__proto__`则是原型链的尽头，值为null。同时构造函数的原型上有一个类叫constructor，它指回构造函数本身。

面试：如何让一个构造函数不能通过new调用而只用于继承？

```js
//方式一:
function Animal(){
	if(new.target === Animal){
		throw new Error('构造函数不能用new调用')
	}
	this.type = '哺乳类'
}

//方式二:
function Animal(){
	if(!(this instanceof Animal)){
		throw new Error('构造函数不能用new调用')
	}
	this.type = '哺乳类'
}
```

ES6中的class只能通过new关键字来调用，直接调用类名的话会报错。

```js
class Animal {
	constructor(){
		//在这里可以写一系列的其他代码逻辑
		
		this.type = '哺乳类'
		this._b = 200
	}
	a = 100  //ES7中支持这种写法，等价于向类的实例对象上添加属性
	
	get b(){    //向类的原型上添加了属性b的getter方法
		return this._b
	}
	
	set b(newvalue){
		this._b = newvalue
	}
	
	static get c(){   //ES6中支持的类的静态属性的写法
		return 300
	}
	
	eat(){  //公共方法
		console.log('eat')  
	}
	
	static flag = true  // ES7支持写法，给类添加静态属性
}

还是可以通过
Animal.prototype.xxx = xxx，向类的原型中添加属性或者方法
```

```js
class Animal {
	constructor(){
		this.type = '哺乳类'
	}
	static get flag(){
		return 'animal'
	}
	eat(){
		console.log('eat')
	}
}
//ES6中的继承
ES6中的继承做了一下几步操作：
1. Tiger.__proto__ = Animal  //让子类继承父类的静态属性或者方法
2. 内部自动调用 Animal.call(this)
3. Tiger.prototype = Object.create(Animal.prototype)
class Tiger extends Animal{
	
}
console.log(Tiger.flag)  //animal
let tiger = new Tiger()
console.log(tiger.type)   //哺乳类
console.log(tiger.eat())  //eat
```

```js
class Animal {
	constructor(){
		this.type = '哺乳类'
	}
	static get flag(){
		return 'animal'
	}
	eat(){
		console.log('eat')
	}
}
//ES6中的继承
ES6中的继承做了一下几步操作：
1. Tiger.__proto__ = Animal  //让子类继承父类的静态属性或者方法
2. 内部自动调用 Animal.call(this)
3. Tiger.prototype = Object.create(Animal.prototype)
class Tiger extends Animal{
	constructor(){
		super()    //子类的constructor上的super指父类的constructor，且this指向的是子类实例
	}
	static getFlag(){
		return super.flag   //子类的静态属性上的方法指向的是父类本身 
	}
	eat(){
		super.eat()     //子类原型上中用super指代的是父类的原型
	}
}

```





进阶面试：用ES5的语法模拟实现ES6的类

```js
"use strict"

function _typeof(obj) {
  "@babel/helpers - typeof"
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj
    }
  } else {
    _typeof = function _typeof(obj) {
      return obj &&
        typeof Symbol === "function" &&
        obj.constructor === Symbol &&
        obj !== Symbol.prototype
        ? "symbol"
        : typeof obj
    }
  }
  return _typeof(obj)
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function")
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: { value: subClass, writable: true, configurable: true },
  })
  if (superClass) _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf =
    Object.setPrototypeOf ||
    function _setPrototypeOf(o, p) {
      o.__proto__ = p
      return o
    }
  return _setPrototypeOf(o, p)
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct()
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor
      result = Reflect.construct(Super, arguments, NewTarget)
    } else {
      result = Super.apply(this, arguments)
    }
    return _possibleConstructorReturn(this, result)
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call
  }
  return _assertThisInitialized(self)
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  }
  return self
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false
  if (Reflect.construct.sham) return false
  if (typeof Proxy === "function") return true
  try {
    Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {})
    )
    return true
  } catch (e) {
    return false
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o)
      }
  return _getPrototypeOf(o)
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function")
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i]
    descriptor.enumerable = descriptor.enumerable || false
    descriptor.configurable = true
    if ("value" in descriptor) descriptor.writable = true
    Object.defineProperty(target, descriptor.key, descriptor)
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps)
  if (staticProps) _defineProperties(Constructor, staticProps)
  return Constructor
}

var Animal = /*#__PURE__*/ (function () {
  function Animal() {
    _classCallCheck(this, Animal)

    this.type = "哺乳类"
  }

  _createClass(
    Animal,
    [
      {
        key: "eat",
        value: function eat() {
          console.log("eat")
        },
      },
    ],
    [
      {
        key: "flag",
        get: function get() {
          return "animal"
        },
      },
    ]
  )

  return Animal
})()

var Tiger = /*#__PURE__*/ (function (_Animal) {
  _inherits(Tiger, _Animal)

  var _super = _createSuper(Tiger)

  function Tiger() {
    _classCallCheck(this, Tiger)

    return _super.apply(this, arguments)
  }

  return Tiger
})(Animal)

console.log(Tiger.flag)
var tiger = new Tiger()
console.log(tiger.type)
console.log(tiger.eat())
```



## common.js模块化规范

在node环境下，import './a.js';这种语法是无法被识别的。如果使用，控制台输出结果为：SyntaxError: Cannot use import statement outside a module。







## js中的同步和异步编程

异步任务队列中有宏任务队列和微任务队列之分。在首次主线程中的任务全部执行完毕之后，将开启事件循环机制，将任务队列中的任务一项项的取出来。在取出任务队列中的任务时，是一项一项的取出的，同时在进行事件循环时，js引擎的执行机制是：先去微任务队列中查看是否有任务，如果有，先入栈一项进行执行，执行完成后出栈，然后再到微任务队列中查看是否有微任务，有则继续上面的步骤，没有则去宏任务中查看是否有宏任务，有的话，则入栈一项宏任务到主线程执行，执行完毕后出栈，然后再到任务队列中，先看是否有新的微任务，有则同上面一样执行，没有则去宏任务队列中查看是否有其他宏任务，有则同上一样执行，没有则等待任务队列出现任务再次进行相应的流程。

重点一句话：主线程每次执行完成之后，都会去任务对列中先看微任务，再看宏任务。同时这些任务都是一项一项的入栈执行并出栈的。所以每次执行宏任务队列中的一项任务之前都会先查看微任务中是否有任务等待执行，有则执行完后再执行宏任务中的任务（一项一项入栈执行后出栈）。

```js
头条面试：
async function async1(){
	console.log('async1 start')
	await async2()
	console.log('async1 end')
}
async function async2(){ console.log('async2') }
console.log('script start')
setTimeout(function(){
	console.log('setTimeout')
},0)
async1()
new Promise(function(resolve){
	console.log('promise1')
	resolve()
}).then(()=>{
	console.log('promise2')
})
console.log('script end')



自己的答案：
'script start'
'promise1'
'script end'
'async1 start'
'promise2'
'async2'
'async1 end'
'setTimeout'


自己做错的原因点在于：
1.错误理解了 async函数是开启一个异步任务，而实际的情况是：async函数被调用时，函数体内部从开始到遇到第一个await语句后，加上await语句的右边部分都是同步执行的。只是将await的左半部分及其函数体后面的语句作为一个微任务加入到任务队列中去。



正确答案：
'script start'
'async1 start'
'async2'
'promise1'
'script end'
'async1 end'
'promise2'
'setTimeout'
```

![image-20210623221947465](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210623221947465.png)







### 手写promise A+ （promise设计规范）

基于原生js实现自己的一套内置promise功能。Promise是浏览器底层用C语言实现的。这里只是用js去尽可能的模拟。同时Promise在JavaScript中是一个类（或者说构造函数）。所以要放些的话，也是写为类或者构造函数。

```js
class Promise{
    constructor(excutor){
        let self = this
        this.status = 'pending'
        this.value 
        this.callbacks={
            fulfilledCallbacks:[],
            rejectedCallbacks:[]
        }
        function resolve(value){
            if(self.status !=='pending') return
            self.status = 'resolved'
            self.value =value
            let callbacks = self.callbacks.fulfilledCallbacks
            if(callbacks.length){
                callbacks.forEach(callback=>{
                    callback(value)
                })
            }
        }
        function reject(reason){
            if(self.status !=='pending') return
            self.status = 'rejected'
            self.value = reason
            let callbacks = self.callbacks.rejectedCallbacks
            if(callbacks.length){
                callbacks.forEach(callback=>{
                    callback(reason)
                })
            }
        }
        excutor(resolve,reject)
    }
    then(onResolved,onRejected){
        
    }
}
```





### js实现前端页面的上传并渲染预览

html中上传文件的唯一控件：`<input type="file">`

关键点：

```<input type='file'>
在input文件上传元素中，当上传文件时，会触发元素的change事件，同时会在该元素对象的files属性上存放着待上传的元素组成的数组对象。
文件上传元素的onchange事件
FileReader构造函数实例
FileReader构造函数实例对象的 readAsDataURL（）方法
FileReader构造函数实例对象的 onload事件
FileReader构造函数实例对象的 result属性
```

```js
<head>
    <style>
        .box {
            box-sizing: border-box;
            width: 200px;
            height: 200px;
            padding: 10px;
            border: 1px solid #ccc;
        }

        .input-box {
            position: relative;
            box-sizing: border-box;
            width: 100%;
            height: 100%;
            border: 1px solid black;
            text-align: center;
        }

        span {
            line-height: 180px;
        }
				
      
      	//目的是让文件上传元素处于最上层且完全透明后能看见下面的内容，但是点击的时候实际上点击还是文件上传元素
        input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
        }

        .preview {
            width: 100%;
            display: none;
        }
    </style>
</head>

<body>
    <div class=box>
        <div class='input-box'>
            <span>点击上传</span>
            <input type='file' class='file-input'>
        </div>
        <img src='#' class='preview'>
    </div>

    <script>
        let inputBox = document.querySelector('.input-box')
        let fileInput = document.querySelector('.file-input')
        let preview = document.querySelector('.preview')
        fileInput.addEventListener('change', function () {
            inputBox.style.display = 'none'
            let file = this.files[0]
            let reader = new FileReader()
            reader.readAsDataURL(file)
            reader.onload = function () {
                preview.src = this.result   //this.result就是以DataURL的形式读取到的文件是一个字符串，类似于data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...
                preview.style.display = 'block'
            }
        })
    </script>
</body>
```


如果需要服务器端处理，把字符串`base64,`后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。

### 可视化拖拽和拖拽文件上传

传统做法：

-   元素监听鼠标单击事件

    -   元素监听鼠标移动事件
    -   元素监听鼠标释放事件
    -   同时计算元素位置坐标是否在上传区域

新api方法：

-   Drag和Drop

工作原理：

0.  给需要被拖拽的标签元素添加标签属性：draggable = 'true' ,并绑定ondrag事件
0.  给接受拖拽元素的放置区域标签元素添加 ondragover 和 ondrop事件，同时必须在事件处理函数中阻止默认行为，因为浏览器对元素的拖拽事件的默认方式是禁止拖拽

开发常用技巧：

在被拖拽的元素上：

-   ondragstart
-   ondrag用于拖拽开始时，给事件或者被拖拽元素添加一些数据，可存放拖拽数据和拖拽元素的id
-   ondragend

在被拖拽元素想要放置的目标元素身上：

-   ondragenter
-   ondragover当被拖拽元素进入到拖拽元素的放置区域内时触发的事件，可以在这个事件中进行一些元素的样式设置，同时必须阻止默认事件行为。
-   ondragleave
-   ondrop当被拖拽元素放置到拖拽元素的放置区域内时触发的事件，在该事件中可以对元素进行真实的移动，比如先获取到被拖拽元素，然后使用appendChild方法对被拖拽元素进行移动

例子一：




![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c351a57b340644ac96c1c4153143fc16~tplv-k3u1fbpfcp-watermark.image)




![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88371b97e457446a9ea49e4c5358aca0~tplv-k3u1fbpfcp-watermark.image)



![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30dba5537d8a42de85b74034930cebf2~tplv-k3u1fbpfcp-watermark.image)



例子二：

```<head>
    <style>
        .wrap {
            background: #e5e5e5;
            width: 500px;
            height: 100px;
            margin: 0 auto;
            text-align: center;
            line-height: 100px;
            color: #fff;
        }

        #box {
            height: 500px;
            border: 2px solid skyblue;
        }

        #box img {
            width: 100px;
            height: 100px;
        }
    </style>
</head>

<body>
    <h1 class="wrap">
        将文件推入内部实现在框内显示
    </h1>
    <div id="box">
    </div>
    <script>
        //获取元素
        let oWrap = document.querySelector('.wrap')
        //
        oWrap.ondragover = function (ev) {
            return false;
            //防止默认触发
            ev.preventDefault()
            //防止事件冒泡
            ev.stopPropagation()
        }
        oWrap.ondrop = function (ev) {
            //获取了从外部拖进来的文件
            let file = ev.dataTransfer.files[0];
            //创建读取文件的对象,
            let oFile = new FileReader();
            //通过读取文件对象的readAsDataURL 方法读取指定的文件,此方法只读取路径
            // oFile.readAsDataURL(file)
            /*通过文件的不同类型选择不同的读取方式*/
            if (file.type.includes('image')) {
                oFile.readAsDataURL(file)
            } else if (file.type.includes('text')) {
                //解决中文乱码
                oFile.readAsText(file, 'gb2312')
            }
            //获取的结果在oFile.result上,读取为空,因为读取需要时间
            //文件信息读取完毕之后会触发oFile.onload
            oFile.onload = function () {
                let src = oFile.result;
                let dom = '';
                //第一种方式
                // box.innerHTML+=`<img src="${oFile.result}" width="50px" height="50px"  />`
                //第二种方式,此处也判断如果file.type包含image用以下这种方式
                if (file.type.includes('image')) {
                    let img = new Image();
                    img.src = src;
                    //box标签追加img元素
                    box.appendChild(img);
                } else if (file.type.includes('text')) {
                    //创建内容标签
                    dom = document.createElement('p')
                    dom.innerHTML = src
                    //box标签追加img元素
                    box.appendChild(dom);
                }
            }
        }
    </script>
</body>
```



![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81d8e6930a3c4548b645c9192bc7d4ec~tplv-k3u1fbpfcp-watermark.image)




![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a95a561709954a65ac9b02e6cf723509~tplv-k3u1fbpfcp-watermark.image)



![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8f2697675f34262a187a27a028f397b~tplv-k3u1fbpfcp-watermark.image)













## 前端文件下载

方式：

0.  前后端配合
0.  纯前端实现

### 前后端配合

方式一：

- a链接标签的href属性直接指向服务器端的静态资源文件。

  ```
  <a href="URL"></a>
  ```

  ```
  export const exportFile = (url, fileName) => {
    const link = document.createElement('a')
    const body = document.querySelector('body')
  
    //关键步骤：
    link.href = url
    link.download = fileName    //a标签里有download属性可以自定义文件名
  
    // fix Firefox
    link.style.display = 'none'
    body.appendChild(link)
  
    link.click()   //自动模拟a标签的点击事件
    body.removeChild(link)   //点击后再移除
  }
  
  //无法监听错误信息
  ```

方式二：

- 通过window.open()打开新页面下载文件

  ```
  window.open(`url`, '_self')
  //下载excel文件，后端提供接口，接口返回的是文件流，可以直接使用window.open()
  //当参数错误时，或其它原因导致接口请求失败，这时无法监听到接口返回的错误信息，需要保证请求必须是正确的且能正确返回数据流，不然打开页面会直接输出接口返回的错误信息，体验不好。
  ```

其他类似方法：form、iframe、location.href

以上方式，当在下载`.mp3`格式，或者视频文件时，浏览器会直接播放该文件，而达不到直接下载的功能，此时，当下载音视频文件时无法使用以上两种方式。

方式三：

- 前端传参或者发送数据，后端根据接收的数据生成文件或根据参数查找出对应的数据在生成文件，然后后端在响应头中设置：`Content-disposition：attachment(附件)；filename="fliename.fileType"`

  Content-disposition： 用于指定文件类型、文件名和文件编码等。

  > `Content-disposition`（内容-部署）是`MIME`协议类型的扩展，`MIME`协议指示`MIME`用户代理如何显示附加的文件。

- 浏览器接收到响应头后就会触发下载行为

优点：

-   根据参数生成不同的文件，灵活性高
-   能实现大数据量或大文件的下载

缺点：

-   如果需要下载的是用户生成的内容（在线作图等）或者内容已经全部返回到客户端，会造成资源和带宽的浪费

方式四：

- ajax请求下载，通过ajax请求返回`Blob`对象，或者`ArrayBuffer`对象

  ```js
  第一步：请求数据
  //纯ajax
  const getBlob = (url) => {
    return new Promise((resolve,reject)=>{
      let xhr = new XMLHttpRequest()
      xhr.open('GET','url',true)
      xhr.responseType = 'blob'
      xhr.onload = ()=>{
        if(xhr.status ===200){
          resolve(xhr.response)
        }
      }
      xhr.send()
    })
  }
  
  
  //axios方法
  import axios from 'axios'
  const getFile = url => {
      return new Promise((resolve, reject) => {
          axios({
              method:'get',
              url,
              responseType: 'arraybuffer'   //重点在这行
          }).then(data => {
              resolve(data.data)
          }).catch(error => {
              reject(error.toString())
          })
      })
  }
  
  //注意点：
  //如果下载文件是文本类型的(如: .txt, .js之类的), 那么用responseType: 'text'也可以, 但是如果下载的文件是图片, 视频之类的, 就得用arraybuffer或blob
  
  
  
  //注意：
  //在上面ajax请求回来的后端的数据类型是Blob或者ArrayBuffer。其中ArrayBuffer不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。   Blob格式的数据也需要转换，所以都需要转换。
  
  //第二步：将数据下载保存
  const saveAs = (blob,filename)=>{
    if (window.navigator.msSaveOrOpenBlob) {
      navigator.msSaveBlob(blob, filename)
    } else {
      const link = document.createElement('a')
      const body = document.querySelector('body')
  
      link.href = window.URL.createObjectURL(blob) // 创建对象url，将blob对象转为可操作的对象
      link.download = filename
  
      // fix Firefox
      link.style.display = 'none'
      body.appendChild(link)
  
      link.click()
      body.removeChild(link)
  
      window.URL.revokeObjectURL(link.href) // 移除调用 URL.createObjectURL() 创建的 URL 对象，减少内存消耗
    }
  }
  
  //为了解决IE(ie10 - 11)和Edge无法打开Blob URL链接的方法，微软自己有一套方法window.navigator.msSaveOrOpenBlob(blob, filename)，打开并保存文件，以上代码做了简单的兼容，navigator.msSaveBlob(blob, filename)是直接保存。
  ```

  获取和下载组合为一个方法：

  ```js
  const getBlob = (url)=>{
    return new Promise((resolve,reject)=>{
      const xhr = new XMLHttpRequest()
      xhr.open('GET','url',true)
      xhr.responseType = 'blob'
      xhr.onload=function(){
        if(xhr.status ==200){
          resolve(xhr.response)
        }
      }
      xhr.send()
    })
  }
  
  const saveFile = (blob,filename)=>{
      if(window.navigator.msSaveOpenBlob){
          navigator.msSaveBlob(blob,filename)
      }else{
          const link = document.createElement('a')
          const body = document.querySelector('body')
          link.href = window.URL.createObjectURL(blob)
          link.download = filename
          link.click()
          body.addpendchild(link)
          window.URL.revokeObjectURL(link.href)
      }
  }
  
  export const download = (url,filename)=>{
      getBlob(url).then(res=>{
          saveFile(res.filename)
      })
  }
  ```

  开发实际需求：

  > 服务器端下载视频，存储到本地，然后再播放，下载存储后播放不了,debug后发现是responseType未正确设置

  responseType值的类型可为如下



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e25fa95b7847489eb681369203b150dd~tplv-k3u1fbpfcp-watermark.image)


- XMLHttpRequest.responseType 属性是一个枚举类型的属性，返回响应数据的类型。它允许我们手动的**设置返回数据的类型**。如果我们将它设置为一个空字符串，它将使用默认的"text"类型。

  当将responseType设置为一个特定的类型时，你需要确保服务器所返回的类型和你所设置的返回值类型是兼容的。那么如果两者类型不兼容，你会发现服务器返回的数据变成了null，即使服务器返回了数据。还有一个要注意的是，给一个同步请求设置responseType会抛出一个InvalidAccessError 的异常。

  ##### DOMString

  在Ajax中，DOMString就等同于JS中的普通字符串。

  ##### ArrayBuffer(又称**类型化数组**)

  ArrayBuffer对象用来表示通用的、固定长度的原始二进制数据缓冲区。`ArrayBuffer` 不能直接操作，而是要通过[类型数组对象]或 [`DataView`]对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。

  #### 批量下载

  用到两个库`jszip` 和 `file-saver`, 通过`ajax`获取文件，然后用 `jszip` 压缩文件, 再用 `file-saver` 生成文件

  ```
  export const download = () => {
    const urls = ['url', 'url']   //需要下载的路径
    const zip = new JSZip()
    const cache = {}
    const promises = []
    urls.forEach((item) => {
      const promise = getBlob(item).then((data) => { // 下载文件, 并存成ArrayBuffer对象
        zip.file('下载文件名', data, { binary: true }) // 逐个添加文件
        cache[item.fileName] = data
      })
      promises.push(promise)
    })
  
    Promise.all(promises).then(() => {
      zip.generateAsync({ type: 'blob' }).then((content) => { // 生成二进制流
        FileSaver.saveAs(content, `打包下载.zip`) // 利用file-saver保存文件
      })
    })
  }
  ```

  完整代码：

  ```
  /**
   * 获取文件
   * @param url
   * @returns {Promise<any>}
   */
  const getBlob = (url) => {
    return new Promise((resolve) => {
      const xhr = new XMLHttpRequest()
  
      xhr.open('GET', url, true)
      xhr.responseType = 'blob'   //告诉服务器你期望的响应格式
      xhr.onload = () => {
        if (xhr.status === 200) {
          resolve(xhr.response)
        }
      }
  
      xhr.send()
    })
  }
  
  /**
   * 批量打包zip包下载
   * @param urlArr Array [{url: 下载文件的路径, fileName: 下载文件名称}]
   * @param filename zip文件名
   */
  export const download = (urlArr, filename = '打包下载') => {
    if (!urlArr.length > 0) return
    const zip = new JSZip()
    const cache = {}
    const promises = []
    urlArr.forEach((item) => {
      const promise = getBlob(item.url).then((data) => { // 下载文件, 并存成ArrayBuffer对象
        zip.file(item.fileName, data, { binary: true }) // 逐个添加文件
        cache[item.fileName] = data
      })
      promises.push(promise)
    })
  
    Promise.all(promises).then(() => {
      zip.generateAsync({ type: 'blob' }).then((content) => { // 生成二进制流
        FileSaver.saveAs(content, `${filename}.zip`) // 利用file-saver保存文件
      })
    })
  }
  ```

### 纯前端实现

纯前端实现并不是一定不需要后端，只是有时候后端的数据已经给到前端，用户下载的文件内容只需要现有的数据，这时候就可以是使用纯前端实现下载文件的功能来减小服务器资源和带宽的浪费。

应用场景：

-   在线作图、在线表格输入

步骤：

0.  将数据生成对应的data:URLs或者blob:URL
0.  处理下载（或叫导出）方式

##### data: URLs

`data: URLs`是前缀为`data:`的 `URL` 字符串，格式为。

```
data:[<mediatype>][;base64], <data>
```

mediatype是个 MIME 类型的字符串，例如 "image/jpeg" 表示 `JPEG` 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII。

##### 数据转换`data:URLs`

第一种、对于文本类型，可以直接将数据拼接

> const dataURL = `data:text/plain;base64,` + textData

第二种、通过`window.btoa()`方法

`btoa()`函数将二进制数据的“字符串”创建base-64编码的ASCII字符串。

```
let str = new Blob(['some thing'])
console.log(btoa(str))  // W29iamVjdCBCbG9iXQ==
let dataURL = 'data:text/plain;base64,' + btoa(str) // data:text/plain;base64,W29iamVjdCBCbG9iXQ==
```

第三种、通过`FileReader.readAsDataURL(blob)`方法

对于`File`或`Blob`对象，可以使用`FileReader.readAsDataURL()`的方法转换为`data:URLs`

示例:

```
const blob = new Blob(['some thing'])
const reader = new FileReader()
reader.onloadend = function() {
  const dataUrl = is_chrome_ios 
            ? reader.result
                    : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;')
}
reader.readAsDataURL(blob)
```

##### 生成`BlobURLs`

blob: URLs是URL.createObjectURL() 静态方法创建的一个 DOMString，其中包含一个表示参数中给出的对象的URL。URL.createObjectURL()方法只能处理File或Blob对象，所以如果要生成blobURLs则必须将数据转换为blob对象或file对象。

```
如果数据不是File或Blob对象
const blob = new Blob([data][, MIMEType])
生成BlobURLs
const BlobURL = URL.createObjectURL(blob)
```

> 创建出来的`BlobURLs`需要手动调用`URL.revokeObjectURL()`销毁，否则会一直保留到页面关闭，为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。

##### 处理下载（或叫导出）方式

第一种、<a>标签的download和href

其中<a>标签的download是HTML5标准新增的属性，作用是指示浏览器下载URL而不是导航到URL，因此将提示用户将其保存为本地文件。另外，download属性的值可以指定下载文件的名称。

href则支持dataURLs和blobURLs两种类型的值。

示例

```
<a download="filename" href="dataURLs或BlobURLs"></a>
```

第二种、location.href或window.open()

这个方法是直接把 DataURLs 或者 BlobURLs 传到浏览器地址中触发下载。有两种方式：

```
window.location.href = urls; // 本窗口打开下载
window.open(urls, '_blank'); // 新开窗口下载
```

第三种、msSaveOrOpenBlob（IE10+)

这是 IE 特有的方法。

```
navigator.msSaveOrOpenBlob(blob, fileName);
```

第四种、iframe(IE <= 9)

其他更现代的浏览器也支持此方法，不过此方法效率和安全性较低，所以一般只在 IE <= 9 时使用。

```
var frame = document.createElement("iframe");

if ( frame ) {
  document.body.appendChild(frame);
  frame.setAttribute("style", "display:none");
  frame.contentDocument.open("txt/html", "replace");
  frame.contentDocument.write(data); // data 是 string 类型
  frame.contentDocument.close();
  frame.focus();

  frame.contentDocument.execCommand("SaveAs", true, filename);
  document.body.removeChild(frame);
}
```

优点

-   减少服务器资源和带宽
-   只需要前端，增加了前端的可控性

缺点

-   对于大数据量支持度不好
-   有兼容性问题





##  文件上传（张仁阳）

[珠峰视频连接](https://www.bilibili.com/video/BV1ZZ4y1u7pV/?spm_id_from=333.788.recommend_more_video.0)

前端二进制对象的转换关系图。

![browserbinary2](http://img.zhufengpeixun.cn/browserbinary2.jpg)

 

上图中的9个类型都是对象或者类型，理解每个对象是什么和有什么作用。 从底层往上层讲。

### ArrayBuffer

ArrayBuffer对象用来表示通用的，固定长度的原始二进制数据缓冲区。本质是一个**字节数组**，里面的元素是一个个 的字节组成。

开发者不能直接操作ArrayBuffer 的内容，而是需要通过类型数组对象（TypeArray） 或者 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读取缓冲区中的内容。

计算机之认识0和1，一个0或者1 算一位，8位构成一个字节。

```js
let buffer = new ArrayBuffer(8)   
console.log(buffer.byteLength)   // 8  字节长度  64 bit
```

![bytearray](http://img.zhufengpeixun.cn/bytearray.jpg)



### TypeArray（类型数组）

类型化的数据，该数组中每个元素占用的字节数是固定。

[TypedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)对象描述了一个底层的二进制数据缓冲区(binary data buffer)的一个类数组视图(view)TypeArray不是一个类，而类似于一个接口，它本身不能被实例化，无法访问，可以将它理解为接口。

- 但它本身不可以被实例化，甚至无法访问，你可以把它理解为接口,它有很多的实现

| 类型        | 单个元素值的范围 | 大小(bytes) | 描述                  |
| :---------- | :--------------- | :---------- | :-------------------- |
| Int8Array   | -128 to 127      | 1           | 8 位二进制有符号整数  |
| Uint8Array  | 0 to 255         | 1           | 8 位无符号整数        |
| Int16Array  | -32768 to 32767  | 2           | 16 位二进制有符号整数 |
| Uint16Array | 0 to 65535       | 2           | 16 位无符号整数       |

int：表示有符号整数

Uint:表示无符号整数

8Array：表示一个元素项占8位（占一个字节）

16Array：表示一个元素项占16位（占两个字节）





![TypedArray](http://img.zhufengpeixun.cn/TypedArray.jpg)







TypeArray对象数组中的每个元素占的字节数量是固定的，一个字节或者两个字节。

```js
const buffer = new ArrayBuffer(8);
console.log(buffer.byteLength);//8
const int8Array = new Int8Array(buffer);
console.log(int8Array.length);//8
const int16Array = new Int16Array(buffer);
console.log(int16Array.length);//4
```



![image-20210821224519161](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210821224519161.png)



### DataView  

DataView类型的数据中每个元素的长度可以自定义。 

- [DataView](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView)视图是一个可以从二进制ArrayBuffer对象中读写多种数值类型（即每个元素的字节长度）的底层接口
- `setInt8(byteOffset, value)`从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个8-bit数(一个字节)，从byteOffset位置开始，设置一个以8个位(bit)的字节数。
- `getInt8(byteOffset, byteLength)`从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个8-bit数(一个字节)  ，从buffer的第byteOffset个字节开始读取，读取多少个字节byteLength

````js
new DataView(buffer [, byteOffset [, byteLength]])   
````

![DataView](http://img.zhufengpeixun.cn/DataView.jpg)

```js
const buffer = new ArrayBuffer(2);
console.log(buffer.byteLength);// 2个字节
const view1 = new DataView(buffer);
view1.setInt8(0, 1); 
console.log(view1.getInt8(0));//1

view1.setInt8(1, 2); 
console.log(view1.getInt8(1));//2

console.log(view1.getInt16(0));//258
```

作用：让开发者任意的去读写某个Buffer中指定字节位置的特定长度（bit）位所代表的数据。



### Blob

**大 文件对象。可以理解为blob就是一个文件，可以将他读为二进制。 通过FileReader来读为二进制或DataURL或者text。**

Blob是一个类似文件的对象。内部放的是类似文件的数据。 

- [Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

- [Blob()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob) 构造函数返回一个新的 Blob 对象。 blob的内容由参数数组中给出的值的串联组成。

- new Blob([string | buffer ], { type:'xxxx' })

- 可以通过fetch或者Ajax或者文件上传标签的得到一个File或者Blob 

- 使用 FileReader 类的实例对象去blob内容，可以读为多种格式，比如readAsText，readAsDataURL，readAsArrayBuffer等

  对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。

  - `readAsText()`：读取文本文件（可以使用txt打开的文件），返回文本字符串，默认编码是UTF-8
  - `readAsDataURL()`：读取文件获取一段以data开头的字符串，这段字符串的本质就是DataURL，DataURL是一种将文件嵌入到文档的方案。DataURL是将资源转换为base64编码的字符串形式,并且将这些内容直接储存在url中

- 构造函数

   

  ```
  var aBlob = new Blob( array, options );
  ```

  - array 是一个由`ArrayBuffer`, `ArrayBufferView`, `Blob`, `DOMString` 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。

  - options 是一个可选的

    ```
    BlobPropertyBag
    ```

    字典

    - `type` 默认值为 "",它代表了将会被放入到blob中的数组内容的MIME类型

  

```html
<body>
    <script>
     let debug = { name: "zhufeng" };
     let str = JSON.stringify(debug);
     console.log("str", str);

     var blob = new Blob([str], { type: "application/json" });
     console.log("blob.size", blob.size);

        function readBlob(blob, type) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function (event) {
                    resolve(event.target.result);
                };
                switch (type) {
                    case "ArrayBuffer":
                        reader.readAsArrayBuffer(blob);
                        break;
                    case "DataURL":  // 就是二进制数据转为可读的字符串 base64字符串
                        reader.readAsDataURL(blob);
                        break;
                    case "Text":  // 文本字符串
                        reader.readAsText(blob, 'UTF-8');
                        break;
                    default:
                        break;
                }
            });
        }
        readBlob(blob, "ArrayBuffer").then((buffer) => {
            console.log("buffer", buffer);
        });
        readBlob(blob, "DataURL").then((base64String) => {
            console.log("base64String", base64String);
        });
        readBlob(blob, "Text").then((text) => {
            console.log("text", text);
        });
    </script>
</body>
```

打印结果：

![image-20210821230611791](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210821230611791.png)



**关键是拿到buffer然后按照规则改buffer数据达到修改源文件。**读取的数据往往是服务器返回的文件，MP3或者图片或者本地文件上传等。

项目中下载文件很常用blob。

blob不能连用，要把blob赋值给一个图片的话，需要先将它转为url地址。

### Object URL

- 可以使用浏览器新的 API URL 对象通过方法生成一个地址来表示 `Blob` 数据，比如一个图片的blob数据不能直接用，直接将blob实例赋值给img标签的src属性是没法显示的。需要先转为URL地址。d'd'd
- 格式为 `blob:<origin>/<uuid>`
- [URL.createObjectURL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL) 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。
- [revokeObjectURL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL) 静态方法用来释放一个之前已经存在的、通过调用 `URL.createObjectURL()` 创建的 URL 对象



使用Object URL下载例子：

```js
function download(){
   	let debug = {name:'zhufeng'}
    let str = JSON.stringify(debug)
	let blob = new Blob(str,{type:'application/json'})
    let a = document.createElement('a')
    a.download = 'user.json'  //下载时的文件明
    a.rel = 'noopener'  // 不打开连接
    a.href = blob  //这样写是不对的，不能直接将blob对象赋值给href属性
    a.href = URL.createObjectURL(blob)  //正确的写法
    a.dsipatchEvent(new MouseEvent('click'))  //代码模拟点击事件 ，另一种写法 a.click()
    URL.revokeObjectURL(blob) //这步收回对象URL地址，收回的原因：上面将blob变为url地址，URL内部会引用blob，这样blob就不会被内存回收了，消耗性能。所以要销毁objectURL地址，也会销毁blob。
}
```



### 图片预览和裁剪上传

image组件部分：

```jsx
import React,{Component} from 'react'
export default class Image extends Component {
    state ={
        file:null,
        dataURL:''，
        times:1,   //默认放大的倍数
        startX:0,
        startY:0,
        startDrag:false,   //记录鼠标拖动的开始或者结束
        prevX:0,
        prevY:0,
        clipImgUrl:''
    }
	handleChange = (event)=>{
        let file = event.target.file[0]
        let Reader = new FileReader()
        reader.onload = (event)=>{
            this.setState({
                file,
                dataURL:reader.result
            })
            this.imageRef.current.onload = ()=>{
                this.drawImage()
            } 
        }
        reader.readAsDataURL(file)
    }
    drawImage =(left=this.state.prevX, top=this.state.pervY)=>{
        let image = this.imageRef.current
        let canvas = this.canvasRef.current
        let ctx =canvas.getContext('2d')
        ctx.clearRect(0,0,canvas.width,canvas.height)
        let imageWidth = image.width
        let iamgeHeight = iamge.height
        //ctx.drawImage(image,0,0,imageWidth,iamgeHeight) //这种画的方式可能导致图片超出部分无法显示，同时对于图片宽高小于canvas宽高的情况下也没有实现水平垂直居中。
        
        if(imageWidth>iamgeHeight){   //这种情况下会存在当图片小于canvas尺寸时，会拉伸图片,大于时会压缩
            let scale = canvas.width/imageWidth
        	imageWidth = canvas.width * this.state.times
            imageHeight = iamgeHeight * scale * this.state.times
        }else{
            let scale = canvas.height/iamgeHeight
            imageHeight = canvas.height * this.state.times
            imageWidth = imageWidth * scale * this.state.times
        }
        ctx.drawImage(image,(canvas.width-imageWidth)/2 +left,(canvas.height - imageHeight)/2 +top,imageWidth,iamgeHeight)
    }
    
    bigger =()=>{
        	this.setState({
                times:this.state.times+0.1
            },()=>{this.drawImage()})   //注意这种写法，setState函数能接收两个参数，以前不知道
    }
    
    smaller =()=>{
        	this.setState({
                times:this.state.times-0.1
            },()=>{this.drawImage()})   //注意这种写法，setState函数能接收两个参数，以前不知道
    }
    
    //图片拖动
    handleMouseDown = (event)=>{
        //鼠标按下时记录鼠标起始位置
        this.setState({
            startX:event.clientX,
            startY:event.clientY，
            startDrag：true
        })
    }
    
    handleMouseMove = (event)=>{
        //event.clientX-this.state.startX为x方向的移动距离，
        //event.clientY-this.state.startY为y方向的移动距离
        let {startX,startY,prevX,prevY} = this.state
        if(this.state.startDrag){
            //注意这里有一个bug，在第一次拖动后，在第二次开始拖动时，event.clientX-this.state.startX的值首先会先置为0，舍得图片回到初始位置。
            //this.drawImage(event.clientX-this.state.startX,event.clientY-this.state.startY)
            //处理办法是记录上一次拖动后的偏移量
            this.drawImage(event.clientX-startX+prevX,event.clientY-startY+prevY)
        }
    }
    
    handleMouseUp = (event)=>{
        this.setState({
            startDrag:false,
            prevX:event.clientX-this.state.startX +this.state.prevX,
            prevY:event.clientY-this.state.startY +this.state.prevY
        })
    }
}
```



ctx.drawImage(image,0,0,imageWidth,iamgeHeight)的表现如下：

![image-20210822111313312](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822111313312.png)





this.drawImage(event.clientX-this.state.startX,event.clientY-this.state.startY)不做处理的bug表现：

第二次拖动之前：

![image-20210822114237254](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822114237254.png)

第二次一拖动，先将图片还原到初始位置 

![image-20210822114314726](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822114314726.png)



在将图片通过canvas画的时候，需要调整图片的大小以至于使得图片的长边能完成展示在canvas中，所以这就涉及图片的等比例缩放。代码：

```jsx
if(imageWidth>iamgeHeight){   //这种情况下会存在当图片小于canvas尺寸时，会拉伸图片,大于时会压缩
            let scale = canvas.width/imageWidth
        	imageWidth = canvas.width * this.state.times
            imageHeight = iamgeHeight * scale * this.state.times
        }else{
            let scale = canvas.height/iamgeHeight
            imageHeight = canvas.height * this.state.times
            imageWidth = imageWidth * scale * this.state.times
        }
        ctx.drawImage(image,(canvas.width-imageWidth)/2 +left,(canvas.height - imageHeight)/2 +top,imageWidth,iamgeHeight)
```

#### 剪切

```jsx
confirm = (event)=>{
    let canvas = this.canvasRef.current
    let ctx =canvas.getContext('2d')
    const imageData = ctx.getImageData(100,100,100,100)  //从x，y为100，100的位置开始截取canvas像素信息，截取的长度是100，宽度也是100
    let clipCanvas = document.createElement('canvas')
    clipCanvas.width = 100
    clipCanvas.height = 100
    let clipCtx = clipCanvas.getContext('2d') 
    clipCtx.putImageData(imageData,0,0)
    let dataURL = clipCanvas.toDataURL()
    this.clipImg.current.src = dataURL
    this.setState({
        clipImgUrl:dataURL
    })
}
```

#### 上传

```js
upload =(event)=>{
	let bytes = atob(this.state.clipImgUrl.split(',')[1])   //atob将base64转为字节数组
	let arrayBuffer = new ArrayBuffer(bytes.length)   //arrayBuffer是没法直接使用的 
	let uint8Array = new Uint8Array(arrayBuffer)  
	for(let i=0;i<bytes.length;i++){
		uint8Array[i] = bytes.charCodeAt(i)   //将图片的base64格式的每个字符依次取出放在uint8Array中
	}
	let blob = new Blob([arrayBuffer]，{type:'image/png'})
	let request = new XMLHttpReaquest()
	let formData =new FormData()  //创建文件上传对象
	formData.append('name','zhufeng')   //加字段 key 与 value
	formData.append('clip',blob)   //加字段 key 与 value
	request.open("POST",'url',true)
	request.send(formData)	
}
```

this.state.clipImgUrl的格式：

![image-20210822122206131](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822122206131.png)

this.state.clipImgUrl.split(',')[1]的格式：

![image-20210822122327838](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822122327838.png)

let bytes = atob(this.state.clipImgUrl.split(',')[1])中bytes的格式：

![image-20210822122337704](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822122337704.png)



补充：

Window atob() 方法用于解码使用 base-64 编码的字符串。

```js
window.atob(encodedStr)
encodedStr: 必需，是一个通过 btoa() 方法编码的字符串。
该方法返回一个解码的字符串。
```

```js
var str = "RUNOOB";
var enc = window.btoa(str);
var dec = window.atob(enc);
 
var res = "编码字符串为: " + enc + "<br>" + "解码后字符串为: " + dec;
```

base-64 编码使用方法是 [btoa()](https://www.runoob.com/jsref/met-win-btoa.html) 。

 ![image-20210822121941086](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822121941086.png)



charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。



文件特别大的情况下，使用buffer可能不是特别好，这时可以考虑用分片。

base64和二进制数据之间的关系是base64用字符串形式表示二进制数据，base64是一种编码方式。





在项目中虽然可以直接将base64格式的图片数据上传给后台，但是并不建议这么做，因为base64太大，太长。同一个图片，base64格式的体积要比二进制格式的大33%左右。base64将原来的3个字节存放的内容变为了4个字节存放，多了1/3。



### 音频剪辑

主要借助第三方库——ffmpeg

例子的html部分：

![image-20210822140715602](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822140715602.png)

![image-20210822140739340](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210822140739340.png)



```jsx
export default class Audio extends Component{
    startRef = React.createRef()
	endRef = React.createRef()
	audioRef = React.createRef()
	audioClipRef = React.createRef()
	state={
		
	}
	//剪辑音频，首先要先得到音频文件，确定开始和结束的时间点，调用第三方库（ffmpeg）进行截取
	clip=async ()=>{
        this.worker = createWorker('ffmpeg-worker-mp4.js的路径')
        let response = await axios({
            url:'mp3文件的url'，
            method：'GET',
            responseType:'arraybuffer'   //直接将返回的数据用buffer格式表示
        })
        let originBuffer = response.data  //buffer格式的data
        let start = parseInt(this.startRef.current.value)  //这里还可以做数据检查
        let end = parseInt(this.endRef.current.value)  //这里还可以做数据检查
        let duration = end - start
        let result = (await toPromise(
            this.worker,
            getClipCommand(originBuffer,start,duration)
        ))  //result便是剪切后的数据结果
        
        let blob = bufferToBlob(result)
        let audioClip = this.audioClipRef.current
        audioClip.src = URL.createObjectURL(blob)
        audioClip.load()
        audioClip.play()
    }
   
    
    
}

//把webwork变为一个promise
const toPromise=(worker,command)=>{
    return new Promise((resolve)=>{
        const onSuccess = function (event){
            switch (event.data.type){
                case:'done':
                    worker.removeEventListener('message',onSuccess)
                    resolve(event)
                    break;
                default:
                    break;
            }
        }
        worker.addEventListener('message',onSuccess)
        command && worker.postMessage(command)
    })
}

//将buffer转为一个大文件对象
const bufferToBlob=(buffer)=>{
    return new File([buffer],'xxxname.mp3',{type:'audio/mpeg'})
}

//音频剪切
const getClipCommand=(arrayBuffer,start=0,duration=10)=>{
	return {
        type:'run',
        argument:`-ss ${start} -i input.mp3 ${duration ? `-t ${duration}`:'' }-acodec copy output.mp3`.split(' '),
        MEMFS:[
            {
                data: new Uint8Array(arrayBuffer),
                name:'input.mp3'
            }
        ]
    }
}

const createWorker =(path)=>{
    return new Worker(path)  //因为剪辑操作需要花费比较长的时间，所以通过web worker开启一个子进程去处理剪辑操作，从而不阻塞主进程。
}
```





## 图片裁剪（周啸天）



基于react，canvas做一个类似于微信头像的裁切和上传功能。

这个项目中图片的裁切是基于前端的canvas实现

- react创建组件
- 组件中使用jsx语法构建页面
- 属性和状态的管理
- canvas实现图片裁切
- html5拖拽

项目基于create-react-app创建项目框架
基于REM构建响应式页面，现在真实项目中响应式常用的方案有：

- @media
- rem
- flex


```
<script>
	//计算rem
    ~function(){
        let event = 'onorientationchange' in window ? 'onorientationchange' :'resize'
        let computed =()=>{
            let HTML = document.documentElement,
                deviceW = HTML.clientWidth,
                designW = 750,
                ratios = deviceW/designW 
            if(deviceW >=designW) ratio =100
            HTML.style.fontSize = ratios +'px'
            window.ratio = ratios
        }
        computed()
        window.addEventListener(event,computed)
    }()
</script>

判断是否存在移动端的横屏竖屏事件，有则用，无则用resize事件代替
```

项目的开发流程：

- 点击头像区域实现头像裁剪组件的显示，当点击返回或者保存图片时，实现头像裁剪组件的隐藏，总结就是两个区域的分别显示与隐藏
- 在头像裁剪组件中，首先要在点击选择图片后实现图片的读取与预览在绘制区域（canvas）
- 实现图片在canvas中的放大和缩小和移动
- 保存图片是把选中部分的图片进行裁剪
- 保存后将裁剪的图像回显到头像区域，在真实项目中可能需要先把裁剪好的图片传给服务器，服务器存好后，再返回头像页面去获取存在服务器中的头像信息

```jsx
图片裁剪部分html
render(){
    return (
        <div className='clipBox'>
            <div className='canvasBoxDiv'>
                <canvas className='canvas'></canvas>		
                <div className='mask'></div>
            </div> 
            
			<div className='btnBox'>
                <input type='file' accept='image/*' className='file'></input>
                <button className='choose'>选择图片</button>
                <button>方法</button>
                <button>缩小</button>
                <button className='submit'>保存图片</button>
            </div>

        </div>

    )
}
```

注意点：

在react的jsx语法模块，定义在组件实例的原型上的非箭头函数形式的方法，被直接用在jsx中的DOM元素作为事件处理函数的时候，函数内部的this指向的并不是组件实例而是绑定该事件的DOM元素。例如：

```jsx
fun(){
    console.log(this)  //这时this代表的button元素
}
render(){
    return <button onClick={this.fun}></button>
}

<button onClick={this.fun.bind(this)}></button>   //手动绑定this为组件实例
```



初始化确定canvas画布的大小和内部裁剪层的大小和定位。

```jsx
class imageClip extends Component{
    constructor(props){
        super(props)
        let winW = document.documentElement.clientWidth,
            ratio = window.ratio //html的字体大小，因为前面采用的是响应式rem布局
        let w = winW -0.4*ratio,   //被用作canvas的宽度
            h = w, //被用作canvas的高度
            maskW = 0.7*w,  //遮罩层的高度
            maskH = maskW,  //遮罩层的宽度
            maskLeft = (w- maskW)/2,  //遮罩层的left
            maskTop = (h-maskH)/2 //遮罩层的top
        this.state = {
            w,h,maskW,maskH,maskLeft,maskTop,
            maskShow:false
        }        
    }
    
    inputFileChange=()=>{
        this.setState({maskShow:true})
        //获取文件对象
        let file = this._file.files[0]
        if(!file)return 
        //使用内置对象读取文件对象以转为base64的格式，读取的结果存放在reader的result属性上。
        let reader = new FileReader()
        reader.readAsDateURL(file)
        reader.onload = () => {
            this.img = new Image()
            this.img.src = reader.result
            this.img.onload = () => {
                //将读取的结果交给canvas进行绘制，但是如果不处理图片的大小，可能导致canvas不能完全展示完整的图片
                let ratioWH = 1,
                    {w,h} =this.state  //w,h 是canvas的宽和高
                this.imageTruthWidth = this.img.width
                this.imageTruthHeight = this.img.height
                this.imageWidth = this.img.width
                this.imageHeight = this.img.height
                //图片的宽大于高 或者图片的宽小于高的情况都叫图片进行压缩或者拉伸
                if(this.imageWidth>this.imageHeight){
                    ratioWH = this.imageWidth / w
                    this.imageWidth = w
                    this.imageHeight = h / ratioWH
                }else{
                    ratioWH = this.imageHeight / h
                    this.imageHeight = h
                    this.imageWidth = w / ratioWH
                }
                //图片的left和top值，用以实现在canvas中水平和垂直居中
                this.imageLeft = (w - this.imageWidth)/2
                this.imageTop = (h -this.imageHeight)/2
                this.drawImage()
            } 
        }
    }
	
    drawImage = ()=>{
        let {w,h} =this.state
        this.ctx = this._canvas.getContext('2d')
        this.ctx.clearReact(0,0,w,h)  //清除画布内容
        this.ctx.drawImage(this.img,this.imageLeft,this.imageTop, this.imageWidth ,this.imageHeight)
    }
    
    render(){
        let { w,h,maskW,maskH,maskLeft,maskTop,maskShow} = this.state
        return (
            <div className='clipBox'>
                <div className='canvasBoxDiv'>
                    <canvas className='canvas' 
                    	width = {w}
                        height = {h}
                        ref={t=>this._canvas=t}
                    ></canvas>		
                    <div className='mask' style={{
                            display:maskShow?'black':'none',
                            width:maskW + 'px',
                            height:maskH +'px',
                            top:maskTop +'px',
                            left:maskLeft+'px'
                        }}></div>
                </div> 

                <div className='btnBox'>
                    <input type='file' accept='image/*' className='file' ref={
                            x=>{this._file=x}}
                        	onChange={this.inputFileChange}
                        ></input>
                    <button className='choose' onClick={()=>{
                            this._file.click()
                        }}>选择图片</button>
                    <button onClick={
                            ()=>{
                                if(this.img){
                                    this.imageWidth +=10
                                    this.imageHeight +=10
                                    this.drawImage()
                                }
                            }
                        } >放大</button>
                    <button onClick={
                            ()=>{
                                if(this.img){
                                    this.imageWidth -=10
                                    this.imageHeight -=10
                                    this.drawImage()
                                }
                            }
                        }>缩小</button>
                    <button className='submit' onClick={}>保存图片</button>
                </div>
            </div>
        )
    }

}
```

input type='file' 的表单控件的在change事件被触发时，上传的文件对象在该元素对象的files中，图片文件对象的格式如下：

![image-20210818214219101](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210818214219101.png) 





在通过FileReader将读出的图片通过canvas.drawImage(image,x,y,width,height)绘制到canvas画布上后，可能出现的情况是：图片的原始尺寸大于整个canvas画布的宽高，导致图片超出部分无法显示。

![image-20210818000850368](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210818000850368.png)

需要开发者做的处理：

根据当前图片的宽高和当前canvas元素的宽高大小，让图片在canvas中完全显示。如果当前图片的width / height 大于1，则保证图片的宽要和canvas的宽一样大。所以宽缩小的比例是： canvas.width / image.width 。 为了保证图片的高也等比缩放，所以图片的高等于： image.height *  canvas.width / image.width。如果width / height 小于1 ，则用高度。

处理过后的图片情况：

![image-20210818221631779](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210818221631779.png)

在处理的图片在canvas中的位置后的表现情况：

![image-20210818222012698](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210818222012698.png)





图片拖动：

具体流程，当开始按下是，先记录按下时的坐标位置（相对于画布的位置）

当移动的时候不断获取最新鼠标位置，减去之前初始的位置得出偏移量，

然后再重新根据最新图标绘制图形。

```jsx
<canvas className='canvas' 
    width = {w}
    height = {h}
    ref={t=>this._canvas=t}
    onTouchStart = {
        ev=>{ //手指事件对象中可能记录多个手指的位置信息，在这里只取第一个
            let point = ev.changeTouches[0]
            this.startX = point.clientX
            this.startY = point.clientY
        }
    }
    onTouchMove = {
        ev=>{
            let point = ev.changeTouches[0]
            let moveX = point.clientX - this.startX
            	moveY = point.clientY - this.startY
            //在实际项目中的时候还需要判断用户是否是真的需要移动图片，而不是因为误触导致的行为
            if(Math.abs(moveX)>10||Math.abs(moveY)>10){
                this.imageTop += moveY
                this.imageLeft += moveX
                this.drawImage()  
            }
            //如果只处理到上面的情况的话，移动图片会导致图片快速的移动并离开视野范围，这是因为moveX/Y在每次移动时都是以onTouchStart事件中确定的startX/Y为初始位置，这就导致moveY/X不断变大，导致图片每次的偏移量就越来越大。所以要更新一下每次移动后的新坐标
            this.startX = point.clientX
            this.startY = point.clientY
        }
    }
></canvas>	
```

![image-20210818225230686](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210818225230686.png)





保存图片的操作：

裁剪图片，先将mask框部分选中的数据读取出来，使用canvas中getImageDate(x,y,width,height)

```jsx
 <button className='submit' onClick={
 	ev=>{
        if(!this.img) return 
        let iamgesData = this.ctx.getImageDate(maskLeft,maskTop,maskWidth,maskHeight)
        //上面的图片数据不能直接就交给img的src属性，而要变为图片
        let temCanvas = document.createElement('canvas'),
            temCtx = temCanvas.getContext('2d')
        temCanvas.width = maskWidth
        temCanvas.height = maskHeight
        temCtx.putImageData(iamgesData,0,0,0,0,maskWidth,maskHeight)
        //某个需要展示切后图片的img元素
        img.src = temCanvas.toDataURL('image/png')
    }
 }>保存图片</button>
```









## 模块化语法（周啸天）

### 定义：

模块（构件）：一种可以有自己的模块名字，内部有能实现一定功能逻辑的代码的集合体。它对外表现出接口特征，对内有自己的代码逻辑和数据。简而言之，模块就是一个具有独立作用域，对外暴露特定功能接口的代码集合。

脚本和模块的异同：

都可以存在一个单独的文件中, 都可以被其他模块(脚本)引入, 也可以引入其他模块(脚本)的数据。

可以按需导入模块中的数据, 但是不能按需导入脚本中的数据，对应脚本，一旦导入了它, 就会将脚本中的所有数据全都导入到了全局作用域中。对于模块, 则可以只导入我们需要的数据。一个模块可能会暴露出很多的变量、函数和对象, 但我们可以只把需要的那一部分导入进来使用。

### 模块化的优势：

- 避免变量的命名冲突
- 代码隔离，避免相互影响
- 利于项目维护
- 模块之间的依赖明确

### 模块化的发展历程：

#### **无模块化**

表现：

```html
<script src="jquery.js"></script>
<script src="jquery_scroller.js"></script>
<script src="main.js"></script>
<script src="other1.js"></script>
<script src="other2.js"></script> 	
<script src="other3.js"></script>
```

要求：

被依赖的脚本的引入必须放在使用该脚本的其他脚本的前面，否则报错

不足：

- 引入的脚本可能直接在全局写入变量造成命名空间的污染
- 脚本之间的依赖很不明确
- 维护成本高

#### **Common.js**

注：node.js采用的模块化规范，一个单独的文件就是一个模块。

表现：

```javascript
//a.js模块(导出)
var a = 5;
var add = function(param){ 
    return a + param
}
module.exports.a = a;module.exports.add = add

// b.js引用自定义a.js模块，参数包含路径，可省略.js（导入）
var addFn = require('./a-commonJs')
console.log(addFn.add(3)) 
```

注意：

- 导出模块内的数据或者方法的方式有：

  ```javascript
  exports.key = value
  
  exports.functionName 
  
  module.exports.key = value
  
  module.exports.functionName 
  
  module.exports = {
      key,
      functionName
  }
  
  //以下是错误的导出方式：
  exports = {
      key,
      functionName
  }
  
  //原因可以理解为在模块化函数内部有这样的代码： 
  exports = module.exports
  return module.exports
  //所以exports本质是对module.exports的引用，函数内部真正导出的是module.exports所指向的那个内存中的对象。
  ```

解决的点：

- 依赖问题被解决
- 全局命名空间污染被解决

不足：

- 当require引入一个模块时，这个方法读取的模块代码是同步加载执行的，在服务器端，因为模块文件都存在本地，所以读取速度可以很快，但是用在客户端的话，由于依赖的模块都是要通过网路请求获取的所以耗时较长，**CommonJS不适合浏览器端模块加载**，更合理的方案是使用异步加载，比如AMD规范。

扩展：CommonJS 在 NodeJs 中的模块加载机制

1. 路径分析
2. 文件定位
3. 编译执行

前端浏览器会缓存静态脚本文件以提高性能，NodeJs 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅缓存文件，而在 NodeJs 中缓存的是编译和执行后的对象。

下图是，路径分析和文件定位步骤：

![image-20210418105915555](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210418105915555.png)

编译执行：

在定位到文件后，首先会检查该文件是否有缓存，有的话直接读取缓存，否则，会新创建一个 Module 对象。

1. 将 JavaScript 代码用函数体包装，隔离作用域。

```
(function(exports, require, modules, __filename, __dirname) {
    exports.add = function(a, b) {
      return a + b;
    };
 });

```

2. 执行函数，注入模块对象的 exports 属性，require 全局方法，以及对象实例，`__filename`, `__dirname`，然后执行模块的源码。
3. 返回模块对象 module.exports 属性。





####  **AMD规范**(Asynchronous Module Definition)

注：RequireJS 采用的模块化规范，AMD规范则是**异步加载模块**，模块的加载不影响它后面语句的运行。所有依赖  这个模块的语句都定义在一个回调函数中，等到依赖加载完成之后，这个回调函数才会运行。是在前端页面中使用的js代码。     AMD需要在模块最开始就把当前模块依赖的内容导入，然后再开发，ES6模块化规范也是一样。所有的模块导入都要放在本模块的开始位置。   **依赖前置、提前执行**。

表现：

```javascript
//基于三个API。引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。
require([module], callback)   //加载一个模块
define(id, [depends], callback)   //定义一个模块
require.config()   //指定引用路径

//使用：
//现在html中引入require.js
<script data-main="./alert" src="./require.js"></script>

define(['a','b','c','d','e','f'],function(a,b,c,d,e,f){
    //必须先声明并初始化要用到的所有模块
    a.functionName();
    if(false){
        b.functionName();   //没有用到B模块，但是B模块还是会被提前执行以准备好
    }
})
```

完整实例：

```
在html文件中引入require.js模块规范实现文件

<script src='./require.js' data-main='index.js'></script> index.js作为入口文件。
data-main表示在加载完成require文件后，会立即加载并执行该属性对应得js文件


index.js中
(function(){
	require.config({
	baseUrl:''
		paths:{
			'module1':'./xxx1'
			'module2':'./xxx2'    //定义了模块 
		}
	})
	
	require(['module2'],function(module2){
		.......
	})
})()


module1.js：
define(function(){
	const name = 'abc'
	
	return {
		name:name
	}
})


module2.js：
define(['module1'], function(module1){
	console.log(module1.name)
})

```



 优点: 

- 适合在浏览器环境中异步加载模块、并行加载多个模块
- 实现 JavaScript 文件的异步加载，避免网页失去响应

不足：不能按需加载。



#### **CMD**

注：SeaJS采用的模块化规范。 **依赖就近、延迟执行**。

```javascript
define(function(require, exports, module){
	const a = require('./a')   //需要时引入
	a.functionName()
	if(false){
		const b = require('./b')  //需要时引入
        b.functionName();  
    }
})
```

完整实例：

```js
在html文件中：
<script src='./sea.js'></script>
<script>
	seajs.use('./index.js')  //入口文件
</script>

index.js:
define(function(require,export, module){
	const foo = require('./foo.js')
	console.log(foo.name)
})


foo.js:
define(function(require,export, module){
	const name = 'abc'
    module.exports = {
    	name:name
    }
})
```



#### **ES6模块化**

注：ECMAScript 6 中引入的模块化功能

表现：

````javascript
// 模块定义 add.js
export function add(a, b) {
  return a + b;
}
export default 函数表达式|对象|变量名  //导出默认成员，一个文件只能有一个,再导出默认成员后还可以导出其他成员
export const key1 = value1
export const key2 = value2
export function fn(){...}
//不同名时，彼此之间不会覆盖或者写为  cosnt key1 = value1; const key2 = value2; function fn(){...}  
export {a,b,fn}



// 模块使用 main.js
import 变量名 form '模块标识'  //这种方式导入的时模块的默认导出成员，如果模块没有导出默认成员的话那么这个变量名对应的值就是 undefined  
                     
import { add } from "./add.js"; //加载模块中的其他成员并以对象结构的方式获得
                     
import * as exportObjName from '模块标识'  //直接将模块内部导出的其他成员放在一个对象内
                     
console.log(add(1, 2)); // 3

````

完整实例：

```
在浏览器端使用：
在html文件中：
<script src='./index.js' type='module'></script>  //需要以服务器方式运行该html文件才可以，如果直接以本地文件得方式打开的化，则会报错。


index.js:
import 

```

常见的导出方式：

```
方式一：
export const name = 'abc'
export const age = 17
export const fun = function(value){
	....
} 

方式二：统一导出
export {
	name,
	age,
	fun
}

方式三：起别名并导出
export {
	name as fName
	age as fName
	funa as fFun 
}




export default xxx
```

常见的导入方式：

```
方式一：
import { name, age, fun } from './module1.js'


方式二：
import { name as mName, age as mAge, fun as mFun} from './foo.js'


方式三：
import { fName as mName, fName as mAge, fFun as mFun} from './foo.js'


方式四：
import * as foo from './foo.js'




import xxx from './foo.js'
```

export 和 import 的结合使用：

```
export {name, age, fun } from './foo.js'
```



注意：

- 在一个文件或模块中，export 可以有多个，export default 仅有一个，export 类似于具名导出，而 default 类似于导出一个变量名为 default 的变量。同时在 import 的时候，对于 export 的变量，必须要用具名的对象去承接，而对于 default，则可以任意指定变量名。

- es6的模块化语法是不能直接在node.js中使用的，虽然能在工程化项目中看到对应的用法，那是经过配置的结果

  ```
  add.js中
  export const a = 123
  export const b = 345
  
  main.js中
  import {a,b} from './add'
  console.log(add.a);
  
  执行node main.js 后控制台报错  SyntaxError: Cannot use import statement outside a module
  ```

- 错误导出方式：

  - export 123
  - export  num = 123
  - export num 
  - export function (){....}
  - export { key1:key1,key2:key2}
  - export = {key1,key2}

  

![image-20210718000912979](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210718000912979.png)

import关键字导入的模块必须是能在解析阶段就能确定的。

import既有关键字 又有import函数。

可以使用import的函数实现动态加载js文件。



在脚手架中使用的import方法，在脚手架项目中写的import函数引入的js文件会被webpack解析，webpack会将import方法中单独引入的文件单独打包到一个文件中。在使用时引入。

### ES Module加载过程

![image-20210718005204005](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210718005204005.png)





问题：

![image-20210718102342842](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210718102342842.png)

在index.js中打印的name是why还是aaaaaa？

答案是：aaaaaa

解析：在ES6的语法中，export导出的看似是对象方式，其实并不是，它导出的就是类似于变量本身（变量的引用）。

![image-20210718103217851](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210718103217851.png)





在node.js中使用ES6的模块化规范，在node.js中默认不自动开启识别ES6的模块化规范。如果想让ES6识别js文件中模块化语法的话，有两种方式：

- 在package.json中设置type字段为module

  

- 将js文件使用.mjs扩展名

![image-20210718104011949](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210718104011949.png)



在node中用ES6引入其他模块时，要加上文件扩展名。在框架的脚手架中不需要，因为脚手架处理好了。



### CommonJs和ES6区别

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

  - CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

  - ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

    

- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

  - 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。

  - 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。


CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 总结

对于服务端的模块而言，由于其模块都是存储在本地的，模块加载方便，所以通常是采用同步读取文件的方式进行模块加载。而对于浏览器而言，其模块一般是存储在远程网络上的，模块的下载是一个耗时的过程，所以通常是采用动态异步脚本加载的方式加载模块文件。另外，无论是客户端还是服务端的 JavaScript 模块化实现，都会对模块进行缓存，以此减少二次加载的开销。





#### CommonJS和ES6的模块化语法的相互套用情况

![image-20210718105151885](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20210718105151885.png)





## 基于JS管理大文件上传和断点续传



功能点：

- 对axios进行二次封装
- 前后端通信的数据格式
- FileReader实现文件读取和处理
- spark-md5生成文件名
- 上传文件大小和格式限定
- 上传文件缩略图展示
- 文件上传的两种方案：FormData 和 BASE64
- 文件上传进度展示和管控
- 文件推拽上传
- 大文件切片上传及优化
- 多文件上传及进度管控
- 断点续传及原理
- 基于Node+Express+multiparty管理文件上传



项目依赖：axios   qs   spark-md5

上传文件后，在后端会将文件放在指定的文件夹中，比如upload文件夹。



请求主体传递给服务器的数据格式：FORM DATA  / x-www-form-urlencoded / json字符串 / 普通文本字符串 / Buffer ....等，这些数据格式都是能够在前后端之间进行传递的。

- FORM DATA 格式一般用于文件的上传
- x-www-form-urlencoded 格式一般用于非文件格式上传:  xxx=xxx&xx=xx
-  json字符串 格式一般也是非文件格式上传
- 普通文本字符串 格式一般也是非文件格式上传
- Buffer 格式一般用于文件的上传



例子：

```js
(function(){
    //js原生提供的一个类,用于生成FormData类型的对象
    let fm = new FormData;
    
    //向该对象中添加文件对象，通过append方法将需要传给后端的信息依次加入到fm实例对象中，存在fm中后，通过axios发请求时将fm实例对象放在post请求的请求体中，传给服务器。但是通过 form data格式传递数据给后台时，需要设置请求头格式。'Content-Type':'multipart/form-data',告诉服务器前端传递的数据的格式数据
    
    fm.append('file', '');  //要传的文件对象
    fm.append('filename', '');  //文件的名字
    
    //给这个后端接口传递的数据应该是FormData类型的实例对象，对象中有两个字段（后端服务器确定的字段）,file字段标识文件对象， filename表示文件名
    axios.post('http://127.0.0.1:8000/upload_single', fm, 
               {headers:{
                   'Content-Type':'multipart/form-data'
               }}
              )   
})
```

传递给后端的不同格式的数据，都有对应的MIME类型，都需要考虑设置请求的中Content-Type字段的值。告诉服务器请求携带的数据的格式。



axios的intance部分：

```js
// 将axios发送请求的公共信息进行提取，没有使用闭包包起来

let instance = axios.create()
instance.defaults.baseURL = 'http://xxxx:80/'
instance.defaults.headers['Content-Type'] = 'multipart/form-data'

// post请求 请求体中数据的格式化参数配置项, 该配置项只针对 post系列请求,项目中所有的post请求，把POST请求通过请求主体传给服务器的信息转为设置的特定格式，该配置项的值是一个函数，函数中接受两个参数，data是开发者用axios发请求时传递写在post请求体参数位置的数据，headers则获取的是开发者自己配置的信息或者基础配置项时设置的headers信息，该返回值是什么最后发给服务器的就是什么数据
instance.defaults.transformRequest = (data, headers) =>{
    
    //目的：将{ file:'aa',filenames:'bb'} 格式的post请求体参数变为 file=aa&filename=bb的格式（可以借助第三方包：qs） qs.stringify({ file:'aa',filenames:'bb'})
    
    const contentType = headers['Content-Type']
    if(contentType ==='application/x-www-form-urlencoded'){
         return qs.stringify(data)
    }
    return data
}
instance.interceptors.response.use(response=>{
    return response.data
},reason=>{
    //所有请求失败处理，服务器处理失败和网络失败都走这里
    return Promise.reject(reason)
})
```

![image-20211026214411483](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026214411483.png)

upload部分：

```js
(function(){
    let fm = new FormData;
    fm.append('file', ''); 
    fm.append('filename', '');  
    
    instance.post('/upload_single', fm).then(response=>{
        //response 中如果不做过滤则包含了响应头，响应体和原生ajax实例信息等
 		// 更常见的是对该response 过滤出它的响应体数据，对此可以在基本配置中增加axios的拦截器，前面已经处理了。
    }).catch(reason=>{
        //....
    })    
    
    
    // 下面传给axios的是一个对象，但是最终发给服务器的必须是要转为 xxx=xxx&xxx=xxx 格式，这可以在intance文件中处理
    instance.post(
        '/upload_single_base64', 
        {
            file:'',
            filenames:''
        }, 
        {
            headers:{
                'Content-Type':'application/x-www-form-urlencoded'
            }
        }
    )
})
```



### 案例一（formData格式上传）

基于Form Data上传文件和图片

> 单文件  FORM DATA 方式上传处理：由服务端自动生成文件的名
>
> method: POST
>
> utl:xxxxx/xxx
>
> params: multipart/form-data
>
> - file: 文件对象
> - filename: 文件名

UI部分:

![image-20211026221003307](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026221003307.png)

![image-20211026220936041](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026220936041.png)



其中input type='file'  表单控件是隐藏的，因为该控件样式难看。而是自己定义一些控件，当点击这些控件的时候间接触发文件上传控件的对应事件。

![image-20211026221156921](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026221156921.png)

![image-20211026221217422](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026221217422.png)



选择文件后做格式校验，大小校验等。点击上传后再上传到服务器。选择和上传分开。





![image-20211026222021334](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026222021334.png)



![image-20211026222100463](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026222100463.png)





![image-20211026222539242](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026222539242.png)

```js
(function(){
    let upload1 = document.querySelector("#uploade1")
    let upload_inp = upload1.querySelector(".upload_inp")
    let upload_button_select = upload1.querySelector(".upload_button.select")
    let upload_button_upload = upload1.querySelector(".upload_button.upload")
    let upload_tip = upload1.querySelector(".upload_tip")
    let upload_list = upload1.querySelector(".upload_list")
    
    let _file = null // 在整个闭包作用于的最外层创建一个变量用于存放input控件change事件产生的file文件对象
    
    
    // 移除文件封装
     const clearHandele = ()=>{
         upload_tip.style.display = 'block'
         upload_list.style.display = 'none'
         upload_list.innerHTML = ``
         _file = nulldd
     } 
    
    // 点击事件做委托移除文件
    upload_list.addEventListener('click',function(e){
        let target = e.target
        if(target.tagName ==='EM'){
            // 说明点击的是移除按钮，下面这几段代码需要在文件上传成功或实在或移除上传文件时后做，所以可以封装为一个方法。
            clearHandele()
        }
        
    })
    
    
    // 监听用户选择文件的操作
    upload_inp.addEventListener('change', function(e){
        // 获取用户选中的文件对象   
        // 触发了upload_inp的change事件后对应的文件对象被存放在upload_inp的files属性中，该属性的值是类数组对象
        let file = this.files[0]   
        if(!file) return
        
        // 限制文件上传的格式，方案一
        if(!/(PNG|JPG|JPEG)/i.test(file.type)){
            alert('上传的图片的格式必须是 PNG|JPG|JPEG 格式之一')
            return
        }
        
        //方案二，在html文件上传控件的标签属性设置
        // <input type='file' accept='.png'>
        
        // 方案三，up主：大圣 说过文件格式是可以造假的，但文件的二进制格式是无法造假的，所以更强大的是使用文件的二进制进行判断。
        
        //限制文件上传的大小, 2MB
        if(file.size>2*1024*1024){
            alert('上传的图片超过2MB')
            return
        }
        
        _file = file 
        
        // 显示上传的文件
        upload_tip.style.display = 'none'
        upload_list.style.display = 'block'
        upload_list.innerHTML = `<li> 
			<span>文件按：${file.name} </span>
			<span><em>移除</em></span>
		</li>`
    })
    
    // 点击选择文件，按钮触发上传文件的input框的选择文件行为
    upload_button_select.addEventListener('click',function(){
        if(
            this.classList.contains('disable')
            ||
            this.classList.contains('loading')
        ){
            return 
        }
        upload_inp.click()
    })
    
    
    // 控制文件上传过程中按钮的样式类的方法
    const changeDisable = flag =>{
        if(flag){
            upload_button_upload.classList.add('loading')
            upload_button_select.classList.add('disable')
            return 
        }
        upload_button_upload.classList.remove('loading')
        upload_button_select.classList.remove('disable')
    }
    
    // 上传文件到服务器
    upload_button_upload.addEventListener('click',function(){
        if(
            this.classList.contains('disable')
            ||
            this.classList.contains('loading')
        ){
            return 
        }
        
        if(!_file){
            alert('请先选择需要上传的文件')
            return 
        }
        changeDisable(true)
        // 将文件传递给服务器：FormData格式,传给服务器一个formDate对象
        let formDate = new FormData()
        formDate.append('file', _file)
        formData.append('filename', _file.name)
        instance.post('/upload_single', formData).then(data=>{
            if(+data.code===0){
                alert(`文件上传成功，您可以基于${data.servicePath}访问该资源`)
                return
            }
            return Promise.reject(data.codeText)
        }).catch(reson=>{
            // 状态码失败和服务器内部失败都将走到这里, 其实这里还可以增加项目的优化，可以将失败的原因返回给服务器，让服务器做一些错误统计。做错误日记的跟踪。
            alert(`文件上传失败 ，您可以稍后再试`)
        }).finally(()=>{
            //promise不论成功还是失败都走这里
            clearHandele()
            changeDisable()
        })
    })
    
    
})()
```

文件上传中的等待上传的文件对象的数据格式：

![image-20211026224043233](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026224043233.png)



![image-20211026224359652](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026224359652.png)



Blob对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于`Blob`，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

Blob类的原型上有一些方法，这些方法可以用于文件对象的处理，比如大文件切片上传会使用它的原型上的slice方法。



` <input type='file' accept='.png'>`  限制文件上传格式的表现是：

![image-20211026225720673](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211026225720673.png)

` <input type='file' accept='.png,.jpg,.jpeg'>`  





案例一的后端代码：

```js
const express = require('express'),
      fs = require('fs'),
      bodyParser = require('body-parser'),
      multiparty = require('multiparty'),
      SparkMD5 = require('spark-md5')

const app = express(),
      port = 8888,
      HOST = 'http:127.0.0.1',
      HOSTNAME = `${HOST}:${PORT}`

app.listen(PORT,()=>{
    console.log(`server is running at ${PORT}`)
})

// 解决跨域
app.use((req, res, next)=>{
    res.header("Access-Control-Allow-Origin","*")
    req.method === 'OPTIONS'? res.send('CURRENT SERVERS SUPPORT CROSS DOMAIN REQUESTS!'):next()
})

// 中间件
app.use(bodyParser.urlencoded({
    extended:false,
    limit:'1024mb'
}))

// 延迟函数
const delay = function delay(interval){
    typeof interval !=='number'? interval =1000 : null
    return new Promise(resolve=>{
        setTimeout(()=>{
            resolve()
        },interval)
    })
}

const uploadDir = `${__dirname}/upload`
const multiparty_upload = function multiparty_upload(req, auto){
    // auto表示是否允许使用该插件自动将上传文件进行处理并存在服务端本地  
    typeof auto !== "boolean" ? auto = false : null
    let config = {
        maxFieldsSize = 200*1024*1024
    }
    if(auto) config.uploadDir = uploadDir
    return new Promise(async (resolve, reject)=>{
        //故意延迟返回给客户端，以模拟上传耗时
        await delay()  
        // multiparty.Form实例对象的parse将按照传入的配置项参数把客户端传递的form data格式的文件进行解析。
        new multiparty.Form(config).parse(req, (error,fields, files)=>{
            if(error){
                reject(error)
                return
            }
            resolve({
                fields, // 该值是一个对象，它内部包含了filename值即前端传递过来的filename值
                files  //该值表示文件对象
            })
        })
    })
}

app.post('/upload_single',async (req,res)=>{
    try{
        let {
            fields,
            files
        } = await multiparty_upload(req, true)  //multiparty_upload 服务器端处理文件上传是通过multiparty实现的
        let file = (files.file && files.file[0] || {})
		res.send({
            code:0,
            codeText:'upload success',
            originalFilename:file.originalFilename,
            servicePath:file.path.replace(__dirname,HOSTNAME)
        })
    }catch(error){
        res.send({
            code:1,
            codeText:err
        })
    }
})

```

服务端针对文件上传的核心思想就是基于一个插件multiparty实现将前端传递的文件对象变为图片上传到服务器指定目录下，并防止文件命名冲突而进行自动命名用hash计算。   multiparty对于同一个文件进行多次上传的话都会再次在后端生成并保存一个新文件只是名字不同。

扩展： async / await 只能接受成功的Promise 或者 异步，成功后才能继续await后面的语句，对于失败的话，使用try /  catch捕获。





### 案例二（后端生成文件名并存储）

> 单文件  BASE64 方式上传处理
>
> method: POST
>
> utl:xxxxx/xxx/xx
>
> params: application/x-www-form-urlencoded
>
> - file: 文件对象（base64格式）
> - filename: 文件名

基于base64上传文件，base64格式上传一般只适用于图片或者音频，视频（音视频的很少）。

![image-20211028093419159](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211028093419159.png)



js：

```js
(function(){
    let upload2 = document.querySelector("#uploade2")
    let upload_inp = upload2.querySelector(".upload_inp")
    let upload_button_select = upload2.querySelector(".upload_button.select")   
    

    // 将选择的文件转为base64格式的方法
    const changeBASE64 = (file)=>{
        return new Promise((resolve,reject)=>{
            let fileReader = new FileReader()
            fileReader.readAsDataURL(file)
            fileReader.onload = (ev)=>{
                resolve(ev.target.result)
            }
        })
    }
    
    // 监听用户选择文件的操作
    upload_inp.addEventListener('change', async function(e){
        let file = this.files[0],
            BASE64,
            data
        
        if(!file) return
        if(/(PNG|JPG|JPEG)/i.test(file.type)){
            alert('上传的图片的格式必须是 PNG|JPG|JPEG 格式之一')
            return
        }
        
        //限制文件上传的大小, 2MB
        if(file.size>2*1024*1024){
            alert('上传的图片超过2MB')
            return
        }
        
        // 在做完格式和大小检验后直接上传到服务器，上面的file只是文件对象，需要将它转为base64码
        // 在FileReader类的实例上有许多的方法将文件对象转为不同格式数据
        //let fileReader = new FileReader()   
        //fileReader.readAsDataURL(file)  //将file文件对象转为base64，但是这个方法是异步进行转换的，要拿到转换后的数据需要监听该对象的事件。
        //fileReader.onload = ev =>{}
        
        upload_button_select.classList.add('loading')
        
        BASE64 = await changeBASE64(file)
        
        //将获取的base64格式的数据传给后端，后端往往是在拿到base64格式的数据后，先反转为对应的源文件后存在指定位置
       try{
           data = await instance.post('/upload_single_base64',{
               // 为了防止base64格式文件在传输过程中出现乱码，需要对base64格式数据进行编码特殊字符，防止传输过程中特殊字符乱码的问题,   服务器拿到客户端传递的结果后，需要解码decodeURIComponent

               file:encodeURIComponent(BASE64)，
               filename:file.name
           },{
               header:{
                   'Content-Type':'application/x-www-form-urlencoded'
               }
           }
                                     )
           
           if(+data.code ===0){
               alert(`文件上传成功,您可以基于${data.servicePath}访问上传文件`)
               return 
           }
           // promise 结合 async await  如何去监测服务器响应的非响应码情况的失败的方法
           throw data.codeText
       }catch(error){
           alert('文件上传失败，请您稍后再试一试')
       }finally{
            upload_button_select.classList.remove('loading')
       }
        
       //在try catch语法中还有一个方法finally，它会在try语句的代码体代码执行完后 或者 在try语句的代码体代码执行中报错后执行catch错误捕获代码体代码后  都执行finally中的代码
          
    })
    
    // 验证按钮是否具有不可点击样式
    const checkIsDisable = element =>{
        let classList = element.classList
        return classList.contains('disable') || classList.contains('loading')
    }
    
    
    // 点击选择文件，按钮触发上传文件的input框的选择文件行为
    upload_button_select.addEventListener('click',function(){
        if(checkIsDisable(this)) return 
        upload_inp.click()
    })
    
    
})()
```



任何文件基本上都能被编译为BASE64码，一个图片本身可以被编译为base64字符串，该字符串则可以直接代表图片本身并被浏览器识别并渲染。

**将文件转为base64码格式的话，需要基于原生JS提供的一个类——FileReader类，可以将文件对象变为指定的数据格式。**



在传递给后端base64格式的文件时，前端多次传递同一张图片给后端，在后端都只是存了一张图片，即使前端将该文件命名更改了再上传也是被后端识别为同一张图片的。

后端代码：

```js
//判断文件是否已经存在
const exists = function exists(path){
    return new Promise(resolve=>{
        fs.access(path, fs.constants.F_OK, error=>{
            if(error){
                resolve(false)
            }
            resolve(true)
        })
    })
}

// 对于不存在的文件存放到服务器本地
const writeFile = function writeFile(res,path,file,filename,stream){
    return new Promise((resolve,reject)=>{
        if(stream){

        }
        fs.writeFile((path,file,error)=>{
            if(error){
                reject(error)
                res.send({

                })
                return
            }
            resolve()
            res.send({
                code:0,
                codeText:'upload success',
                originalFilename:filename,
                servicePath:path.replace(__dirname,HOSTNAME)
            })
        })
    })
}

app.psot('upload_single_base64',async (req.res)=>{
    let file = req.body.file,
        filename = req.body.filename,
        // spark用于根据文件的内容最终生成一个hash名，注意是根据文件的内容而不是文件名字，所以才可以保证两张图片名字不一样，但内容一样的话最终也是生成同一个文件名
        spark = new SparkMD5.ArrayBuffer(), 
        // 获取文件名的后缀
        suffix = /\.([0-9a-zA-Z]+)$/.exec(filename)[1],
        isExists = false,
        path
    
    
    file = decodeURIComponent(file)
    // 将base6格式的数据前面的前缀去掉，前缀是用于声明数据的格式，后面才是具体的文件内容
    file = file.replace(/^data:image\/\w+;base64,/,'')
    // 使用node提供的Buffer.from方法将base64数据转为buffer格式的数据
    file = Buffer.from(fisle,'base64')\
    // 将buffer格式的数据使用spark生成唯一文件名,该名字通过spark.end()方法获取
    spark.append(file)
    path = `${uploadDir}/${spark.end()}.${suffix}`
    await delay()
    
    isExists = await exists(path)
    if(isExists){
        res.end({
            code:0,
            codeText:'file is exists',
            originalFilename:filename,
            servicePath:path.replace(__dirname,HOSTNAME)
        })
        return 
    }
	writeFile(res,path,file,filename,false)
})
```

  前面两个上传文件的案例中，文件的命名都是由后端来完成的。



### 案例三(客户端生成文件名上传)



> 单文件  FORM DATA 方式上传处理：由客户端自动生成文件的名并传递给服务端处理
>
> method: POST
>
> utl:xxxxx/xxx/xx
>
> params: multipart/form-data
>
> - file: 文件对象
> - filename: 文件名(前端将文件处理为hash命名的文件名)



客户端实现文件名的命名以及缩略图的展示并上传。前端传给后端的文件的名字是什么后端就存什么，但是这个服务器会判断新上传文件的名字和已存在的文件名字是否冲突，冲突的话就不再保存新上传的同名文件。  具体后端是存新的上传的文件还是对新的同名文件不做处理，要看后端的代码逻辑。

![image-20211028214455336](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211028214455336.png)

js:

```JS
(function(){
    let upload3 = document.querySelector("#uploade3")
    let upload_inp = upload3.querySelector(".upload_inp")
    let upload_button_select = upload3.querySelector(".upload_button.select")   
    let upload_button_upload = upload3.querySelector(".upload_button.upload")   
    let upload_abbre = upload3.querySelector(".upload_abbre")   
    let upload_abbre_img = upload_abbre.querySelector("img")   
    let _file = null
    

    // 将选择的文件转为base64格式的方法
    const changeBASE64 = (file)=>{
        return new Promise((resolve,reject)=>{
            let fileReader = new FileReader()
            fileReader.readAsDataURL(file)
            fileReader.onload = (ev)=>{
                resolve(ev.target.result)
            }
        })
    }
    
    
    // 监听用户选择文件的操作
    upload_inp.addEventListener('change', async function(e){
        let file = this.files[0]
        
        if(!file) return
        if(/(PNG|JPG|JPEG)/i.test(file.type)){
            alert('上传的图片的格式必须是 PNG|JPG|JPEG 格式之一')
            return
        }
        
        _file = file
        
        // 文件预览 ,不限制大小， 同时在文件还在转为base64格式时按钮样式是无法点击样式且无法点击
        upload_button_select.classList.add('disable')
        BASE64 = await changeBASE64(file)
        upload_abbre.style.display = 'block'
        upload_abbre_img.src = BASE64
        upload_button_select.classList.remove('disable')
    })
    
    // 验证按钮是否具有不可点击样式
    const checkIsDisable = element =>{
        let classList = element.classList
        return classList.contains('disable') || classList.contains('loading')
    }
    
    // 点击选择文件，按钮触发上传文件的input框的选择文件行为
    upload_button_select.addEventListener('click',function(){
        if(checkIsDisable(this)) return 
        upload_inp.click()
    })
    
    // 将文件对象转为Buffer格式的数据
    const changeToBuffer = function changeToBuffer(file){
        return new Promise(resolve=>{
            let fileReader = new FileReader()
            fileReader.readAsArrayBuffer(file)
            fileReader.onload = ev =>{
                let buffer = ev.target.result,
                    spark = new SparkMD5.ArrayBuffer(),
                    suffix
                
                spark.append(buffer)
                HASH = spark.end()
                suffix = /\.([a-zA-Z0-9]+)$/.exec(file.name)[1]
                resolve({
                    buffer,
                    HASH,
                    suffix,
                    filename:`${HASH}.${suffix}`
                })
            }
        })
    }
    
    //控制文件上传过程中按钮的样式类的方法
    const changeDisable = flag =>{
        if(flag){
            upload_button_upload.classList.add('loading')
            upload_button_select.classList.add('disable')
            return 
        }
        upload_button_upload.classList.remove('loading')
        upload_button_select.classList.remove('disable')
    }
    
    // 上传文件到服务器
    upload_button_upload.addEventListener('click',async function(){
        if(checkIsDisable(this)) return 
        
        if(!_file){
            alert('请先选择需要上传的文件')
            return 
        }
        changeDisable(true)
        
        // 生成文件的hash名
        let { filename } = await changeToBuffer(_file)
        // 将文件传递给服务器：FormData格式,传给服务器一个formDate对象
        let formDate = new FormData()
        formDate.append('file', _file)
        formData.append('filename', filename)
        instance.post('/upload_single_name', formData).then(data=>{
            if(+data.code===0){
                alert(`文件上传成功，您可以基于${data.servicePath}访问该资源`)
                return
            }
            return Promise.reject(data.codeText)
        }).catch(reson=>{
            // 状态码失败和服务器内部失败都将走到这里
            alert(`文件上传失败 ，您可以稍后再试`)
        }).finally(()=>{
            //promise不论成功还是失败都走这里
            changeDisable()
            upload_abbre.style.display = 'block'
        	upload_abbre_img.src = BASE64
            _file = null
        })
    })
})()
```

选择完图片后需要进行预览，就是给img元素的src属性赋值。原理：将图片编译为base64后赋值给img的src。

客户端自己编译文件的hash名后交给后端，需要借助spark-md5这个第三方包实现命名。该第三方包的使用注意，该插件本身是要把文件对象转为Buffer格式再交给该包进行处理，最后根据文件内容生成一个唯一hash值。



后端代码：

```js

const uploadDir = `${__dirname}/upload` 
const multiparty_upload = function multiparty_upload(req, auto){
    typeof auto !=='boolean'? auto = false:null
    let config = {
        maxFieldsSize:200*1024*1024
    }
    if(auto) config.uploadDir = uploadDir
    return new Promise((resolve,reject)=>{
        await delay()
        new multiparty.Form(config)
        .parse(req,(error,fields,files)=>{
            if(error){
                reject(error)
                return 
            }
            resolve({
                fields,
                files
            })
        })
    })
}

app.post('/upload_single_name',async (req,res)=>{
    try{
        let {
            fields,
            files
        } = await multiparty_upload(req)
        
        let file = (files.file && files.file[0]) || {},
            filename = (fields.filename&&fields.filename[0])||'',
            path = `${uploadDir}/${filename}`,
            isExists =false
        
        isExists = await exists(path)
        if(isExists){
            res.send({
                code:0,
                codeText:'file is exists',
                originalFilename:filename,
                servicePath:path.replace(__dirname,HOSTNAME)
            })
            return 
        }
        writeFile(res, path, file, filename, true)
    }catch(error){
        res.send({
            code:1,
            codeText:err
        })
    }
})
```



### 案例四（上传进度管控）

![image-20211030124831940](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030124831940.png)

![image-20211030124841895](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030124841895.png)

原理：随着文件上传，拿到上传后的进度，改变value div的width属性值。



```js
(function (){
    let upload4 = document.querySelector("#uploade4")
    let upload_inp = upload4.querySelector(".upload_inp")
    let upload_button_select = upload4.querySelector(".upload_button.select")   
    let upload_progress = upload4.querySelector("upload_progress")   
    let upload_progress_value = upload_progress.querySelector(".value")   

    // 验证按钮是否具有不可点击样式
    const checkIsDisable = element =>{
        let classList = element.classList
        return classList.contains('disable') || classList.contains('loading')
    }

	const delay =function delay(interval){
        typeof interval !=='number'?interval = 1000: null
        return new Promise(resolve=>{
            setTimeout(()=>{
                resolve()
            },interval)
        })
    }
    
    // 监听用户选择文件的操作
    upload_inp.addEventListener('change', async function(e){
        let file = this.files[0],
        	data

        if(!file) return
        if(/(PNG|JPG|JPEG)/i.test(file.type)){
            alert('上传的图片的格式必须是 PNG|JPG|JPEG 格式之一')
            return
        }

        // 文件预览 ,不限制大小， 同时在文件还在转为base64格式时按钮样式是无法点击样式且无法点击
        upload_button_select.classList.add('loading')

        try{
            let formData = new FormData()
            formData.append('file',file)
            formData.append('filename',file.name)
            data = await instance.post(
                '/upload_single',
                formData，
                {
                //文件上传中的回调函数 xhr.upload.onprogress
                    onUploadProgress(ev){
                    let { loaded, total } = ev
                    upload_progress.style.display = 'block'
                    upload_progress_value.style.width = `${loaded/total *100}%`
                    }							
        		}
        )
        if(+data.code === 0){
            upload_progress_value.style.width = 100%
            await delay(5 00)    
            alert('文件上传成功！')
            return 
        }
        throw data.codeText
    }catch(error){
        alert('文件上传失败请稍后再试!')
    }finally{
        upload_button_select.classList.remove('loading')
        upload_progress.style.display = 'none'
        upload_progress_value.style.width = `0%`
    }
})

// 点击选择文件，按钮触发上传文件的input框的选择文件行为
upload_button_select.addEventListener('click',function(){
    if(checkIsDisable(this)) return 
    upload_inp.click()
})
})()
```

监听上传的进度。在axios中，在发请求的配置项中提供了一个回调函数——onUploadProgress( )——该回调函数的事件对象中

axios核心也是原生Ajax的封装， 而原生的Ajax实例对象上有一个属性叫upload，该属性对应的是另一个对象，该对象上有许多的方法，其中一个就是onpregress事件属性。

![image-20211030131155633](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030131155633.png)



该onprogres事件对应的处理函数在被定义且触发时，默认会传入一个事件对象ev，该事件对象的结构如下：

![image-20211030131540298](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030131540298.png)





### 案例五（多文件上传）

![image-20211030133035084](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030133035084.png)



```js
(function(){
    let upload5 = document.querySelector("#uploade3")
    let upload_inp = upload5.querySelector(".upload_inp")
    let upload_button_select = upload5.querySelector(".upload_button.select")   
    let upload_button_upload = upload5.querySelector(".upload_button.upload")   
    let upload_list = upload5.querySelector(".upload_list")   
    let _files = []
    


    upload_list.addEventListener('click'.async function(ev){
        let target = ev.target,
            currentLi = null,
        	key
        if(target.tagName ==='EM'){
            currentLi = target.parentNode.parentNode
            if(!currentLi) return 
            // 移除对应的dom树中的li
            upload_list.removeChild(currentLi)  
            // 移除files中对应的文件对象
            key = currentLi.getAttribute('key')
           _files = _files.filter(item=> item.key!==key )
            if(_files.length ===0){
                upload_list.style.display = 'none'
            }
        }
    })
    
    //获取唯一值
    const creatRandom = ()=>{
        let ran = Math.random()*new Date()
        return ran.toString(16)/replace('.','') 
    }
    
    // 监听用户选择文件的操作
    upload_inp.addEventListener('change', async function(e){
        let files =Array.from( this.files )//类数组对象
        if(!files.length)return 
        _files = files.map(item=>{
            return {
                file,
                filename:file.name,
                key:creatRandom()
            }
        })
         //重新组织数据结构，为一个文件对象设置一个为唯一值，作为自定义属性存储到li元素上，点击移除时，基于该唯一值到files中将对应的项进行删除
        let str = ``
        _files.forEach((item,index)=>{
            str += `<li key="${item.key}">
				<span>文件${index+1}：${item.filename}</span>
            	<span><em>移除</em></span>
				</li>`
        })
        upload_list.innerHTML = str
        upload_list.style.display = 'block'
    })
    
    // 验证按钮是否具有不可点击样式
    const checkIsDisable = element =>{
        let classList = element.classList
        return classList.contains('disable') || classList.contains('loading')
    }
    
    // 点击选择文件，按钮触发上传文件的input框的选择文件行为
    upload_button_select.addEventListener('click',function(){
        if(checkIsDisable(this)) return 
        upload_inp.click()
    })
    
    
    //控制文件上传过程中按钮的样式类的方法
    const changeDisable = flag =>{
        if(flag){
            upload_button_upload.classList.add('loading')
            upload_button_select.classList.add('disable')
            return 
        }
        upload_button_upload.classList.remove('loading')
        upload_button_select.classList.remove('disable')
    }
    
    // 上传文件到服务器
    upload_button_upload.addEventListener('click',async function(){
        if(checkIsDisable(this)) return 
        
        if(!_files.length){
            alert('请先选择需要上传的文件')
            return 
        }
        changeDisable(true)
        let upload_list_arr =  Array.from(upload_list.querySelectorAll('li'))
        // 循环发送文件上传请求并检测每个文件的上传进度
      	_files = _files.map(item=>{
            let fm = new FormData(),
                currentLi = upload_list_arr.find(liBox=>liBox.getAttribute('key')===item.key),
                currentSpan = currentLi?currentLi.querySelector('span:nth-last-child(1)'):null,
                
            fm.append('file',item.file)
            fm.append('filename',item.filename)
            return instance.post(
                '/upload_single', 
                fm, 
            	{
                    onUploadProgress(ev){
                        // 检测每个文件的上传进度
                        currentSpan?currentSpan.innerHTML =  `${(ev.loaded/ev.total*100).toFiexd(2)}`:null
                       
                    }
                }
            ).then(data=>{
                if(+data.code === 0){
                    currentSpan?currentSpan.innerHTML = '100%'
                    return 
                }
                return Promise.reject()
            })
        })
            
        
        Promise.all(_files).then(()=>{
            alert('所有文件都上传成功！')
        }).catch(()=>{
             alert('文件过程存在未上传成功的文件，请稍后再试！')
        }).finally(()=>{
            changeDisable(false)
            upload_list.innerHTML = ''
            upload_list.style.display='none'
            _files = []
        })
    })
})()
```

![image-20211030134107560](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030134107560.png)



![image-20211030145157970](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030145157970.png)



###  案例六（拖拽上传）

![image-20211030160616823](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030160616823.png)

![image-20211030160706084](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030160706084.png)



![image-20211030160732529](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030160732529.png)

js:

```js
(function(){
    let upload = document.querySelector('#upload6'),
        upload_inp = upload.querySelector(".upload_inp"),
    	upload_submit = upload5.querySelector(".upload_submit"),   
    	upload_mark = upload5.querySelector(".upload_mark")，
        isUploading = false
    
    // 拖拽获取文件对象，采用的 H5新增的拖拽事件api   dragenter dragleave dragover drop
    upload.addEventListener('dragover', function(ev){
        ev.preventDefault()
    })
    upload.addEventListener('drop', function(ev){
         ev.preventDefault()
        // 获取拖拽进入可放置区域的文件对象， 具体是在事件对象的dataTransfer属性上有对应的文件对象
        let file = ev.dataTransfer.files[0]
        if(!file)return 
        uploadFile(file)
    })
    
    
    upload_inp.addEventListener('change', function(ev){
        let file = this.files[0]
        if(!file)return 
        uploadFile(file)
    })
    
    //点击按钮获取文件对象并上传
    upload_submit.addEventListener('click',function(){
        upload_inp.click()
    })
    
    
    // 文件上传方法
    const uploadFile =async file=>{
        // 控制正在上传过程中时点击无效
        if(isUploading) return 
        isUploading = true
        
        // 显示文件上传中的遮罩层
        upload_mark.style.dispaly ='block'
        try{
            let fm = new FormData(),
                data
            fm.append('file',file)
            fm.append('filename',file.name)
            data = await instance('/upload_single', fm)
            if(+data.code ===0){
                alert('文件上传成功！')
                return 
            }
            throw data.codeText
        }catch(error){
            alert('文件上传失败')
        }finally{
            //无论上传成功或失败都隐藏遮罩层
            upload_mark.style.dispaly ='none'
            isUploading =false
        }
        
    }
})()
```

文件上传有两种方式：

- 点击按钮上传
- 拖拽上传

将文件拖入浏览器界面内后松开，浏览器会有一个默认行为就是去尝试打开该文件。但在文件上传中要阻止该默认事件。



### 案例七（大文件的断点和切片上传）

之前的项目中，传递到后端的文件的体积相对较小。对于大文件的上传，如果直接上传，有可能在传输过程中因为上传的时间过长网络等问题导致文件上传失败。在失败后，下次再传的话又将完全重新上传。为此就不得不考虑解决，主流的解决方案是——**切片上传和断点续传**。

原理：正常情况下，将一个文件传给服务器，就将file对象通过formData格式传给服务器，服务器在获取到文件后存在指定的后台目录并返回结果告知前端。  那如果上传的文件很大，前端并不是将整个文件全部一次传给后端，而是将文件进行切片，分片上传给服务器，服务器分片接受文件切片后存在它的本地（可能在后端上传的目录中新建一个文件夹(临时文件夹)，将收到的切片放到指定的文件夹），当前端所有的切片都上传成功了，那么再给后端发送一个请求让服务器将该文件的所有切片进行合并生成一个完整的文件对象。服务器再合并成功后通知前端消息即可。

基于切片上传就可以做断点续传能力，比如一个文件一共切为了10文档片段并上传，只成功的上传了3个切片。那下次再上传文件时，同样切为10个切片，但是此时可以先请求服务器特定的接口，该接口告诉开发者当前已经上传了哪些切片。 那么前端只需要将剩下的切片上传给服务器就可以。

如果服务器没有提供类似的接口以告知已经有哪些切片，那一般服务器自己也会做一个处理，比如现在服务器没有给判断已经上传了哪些切片的接口，前端在仍然是传递10个切片，当后端已有的切片被再次传给后端时，则后端不会再去进行切片的保存了，而是立即返回前端一个状态以说明该切片已经存在。

断点续传的核心思路就是： 一个大文件切为多个切片，传给后端，传过的就不再传了。

- 传过的切片再次重新传给服务器，服务器发现已经传过了，则直接返回已经传过且不做额外处理

  

- 服务器提供一个接口，每次上传之前，客户端先发送一个请求拉取一下已经传过的切片，客户端自己判断后，将未上传的文件切片上传，服务器将没有传过的存起来，最后传完以后再发送一个请求去后台以合并切片，服务器最后合成一个完整的文件并通知客户端。



把一个文件切为许多切片，切为许多切片后，切片的名字一般采用的格式是，先根据完整文件的内容生成一个hash值，然后加一个下划线，然后再是切片顺序索引——HASH_num.后缀名。

在后端生成的临时文件夹的名字也是由相应的文件内容的hash值命名。前端完整上传完后发请求给服务器请求将对应的hash名目录下的切片合并。 只要前端将hash传给服务器，服务器找到对应的文件夹并进行切片合并。



> 获取已经上传的切片
>
> url:'xxxxx/xxxx'
>
> mrthod:GET
>
> params: 
>
> ​	HASH：文件对象生成的hash



> 上传切片
>
> url:'xxx/xxx/xxx'
>
> method:POST
>
> params:multipart/form-data
>
> ​	file:切片
>
> ​	filename: 切片名字【hash值_切片编号.后缀】



>合并切片
>
>url:'xxx/xx/x'
>
>method:POST
>
>params:application/x-www-form-urlencode
>
>​	HASH：文件的hash名字
>
>​	count：切片数量



![image-20211030180505639](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030180505639.png)

js:

```js
(function (){
    let upload7 = document.querySelector("#uploade7")
    let upload_inp = upload7.querySelector(".upload_inp")
    let upload_button_select = upload7.querySelector(".upload_button.select")   
    let upload_progress = upload7.querySelector("upload_progress")   
    let upload_progress_value = upload_progress.querySelector(".value")   

    // 验证按钮是否具有不可点击样式
    const checkIsDisable = element =>{
        let classList = element.classList
        return classList.contains('disable') || classList.contains('loading')
    }

    const delay =function delay(interval){
        typeof interval !=='number'?interval = 1000: null
        return new Promise(resolve=>{
            setTimeout(()=>{
                resolve()
            },interval)
        })
    }

    // 将文件对象转为HASH格式的数据
    const changeToBuffer = function changeToBuffer(file){
        return new Promise(resolve=>{
            let fileReader = new FileReader()
            fileReader.readAsArrayBuffer(file)  // 对于大文件而言，这步需要消耗一定的时间
            fileReader.onload = ev =>{
                let buffer = ev.target.result,
                    spark = new SparkMD5.ArrayBuffer(),
                    suffix
                
                spark.append(buffer)
                HASH = spark.end()
                suffix = /\.([a-zA-Z0-9]+)$/.exec(file.name)[1]
                resolve({
                    buffer,
                    HASH,
                    suffix,
                    filename:`${HASH}.${suffix}`
                })
            }
        })
    }
    
    const clear = ()=>{
        upload_button_select.classList.remove('loading')
        upload_progress.style.display = 'none'
        upload_progress_value.style.width = '0%'
    }
    
    // 监听用户选择文件的操作
    upload_inp.addEventListener('change', async function(e){
        let file = this.files[0],
            already =[],  //用于存储已经存在于后端的切片的信息
            data =null
        
        if(!file) return
        // 文件预览 ,不限制大小， 同时在文件还在转为base64格式时按钮样式是无法点击样式且无法点击
        upload_button_select.classList.add('loading')
        upload_progress.style.display = 'block'
		// 获取文件hash名
        let {HASH, suffix} = await changeToBuffer(file) 
        
        // 获取已经上传的切片信息，如果自己的后台不支持的话就不用做这步处理
        try{
            data =await instance.get(
                '.upload_already',
                {
                	params:{
                        HASH
                    }
            	}
            )
            if(+data.code ===0){
                already = data.fileList
            }
            
        }catch(error){ ... }
         
        // 实现即将上传的文件的切片处理，方式两种：固定数量和固定大小  在采用固定大小上传切片时，最好设置一个最大允许的切片数量，当文件体积除以固定切片大小的数量超出最大切片数量的话，建议采用最大切片数量反过来调整每个切片的大小后再上传。
        let max = 1024*100,  // 100kb
            count = Math.ceil(file.size/max),
            index = 0,
            chunks = []	
        if(count>100){
            count = 100
            max = file.size / 100
        }
        while(index<count){
            chunks.push({
                file:file.slice(index*max ,(index+1)*max),
                filename:`${HASH}_${index+1}.${suffix}`
            })
            index++
        }
		
        // 将每个切片都上传给服务器
         chunks.forEach(chunk=>{
             // 比较当前切片和服务端返回的已有切片进行比较，已有的则不用再传
             if(already.length>0 && already.includes(chunk)){
                 complate()
                 return 
             }
             let fm = new FormData()
             fm.append('file',chunk.file)
             fm.append('filename',chunk.filename)
             instance.post('/upload_chunk', fm).then(data=>{
                 // 循环上传每一个切片后需要让进度条加一，当所有切片都传成功后在发一个请求合并切片
                 if(+data.code ===0){
                     complate()
                     return 
                 }
                 return  Promise.reject(data.codeText)
             }).catch((error)=>{
                 // 如果某个切片上传失败，则直接停止所有切片的上传
                 alert('当前切片上传失败，请稍后再试')
                 clear()
             })
         })
        
        index =0
        // 每个切片都上传成功的处理函数
        const complate =async ()=>{
            // 管控进度条
            index++
            //当所有切片都上传成功则发一个合并切片的请求
            upload_progress_value.style.width = '${index/count*100}%'
            if(index< count)return 
            upload_progress_value.style.width = '100%'
            try{
                // 合并切片请求
                data = await isntance.post(
                    '/upload_merge', 
                    {
                    HASH,
                    count
                	},
                    {
                 		headers:{
                            'Content-Type':'application/x-www-form-urlencoded'
                        }       
                    }
                 )
                if(+data.code===0){
                    alert('文件上传成功')
                    clear()
                    return 
                }
                throw data.codeText
            }catch(error=>{
                alert('合并切片失败，请稍后重试！')
                clear()
        	})
        }
        
    })

    // 点击选择文件，按钮触发上传文件的input框的选择文件行为
    upload_button_select.addEventListener('click',function(){
        if(checkIsDisable(this)) return 
        upload_inp.click()
    })
})()
```



![image-20211030183057743](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030183057743.png)



![image-20211030190952623](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030190952623.png)



注意：因为前端需要将文件对象转为buffer格式的数据，然后交给sparkmd5包解析buffer格式的文件对象以生成对应的文件名的hash名字，其间需要花费不少时间。这是项目中可以优化的地方。

![image-20211030191003834](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030191003834.png)



一但解析完后便开始切片并循环上传切片。

![image-20211030191211044](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030191211044.png)



模拟上传终端——页面刷新，后端文件夹中有一个临时文件夹，内部的文件切片并不完整

![image-20211030191504156](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030191504156.png)



![image-20211030191443902](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030191443902.png)



接下来客户端又对同一个文件进行再次上传，进度条会有一个一下子从零到上传已经完成上传的进度的变化，之后再是正常的上传进度的展示。

![image-20211030191557799](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030191557799.png)



当所有切片都上传完成后，后端的临时文件夹自动删除并合并生成一个新的文件。

![image-20211030191806667](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030191806667.png)



后端代码：

```js
app.post('/upload_chunk', async(req.res)=>{
    try{
        let {
            fields,
            files
        } = await multiparty_upload(req)
        
        let file = (files.file && files.file[0]) || {},
            filename = (fields.filename&&fields.filename[0])||'',
            path = ``,
            isExists =false
        
        let [,HASH] = /^([^_]+)_(\d+)/.exec(filename)
        // 创建临时目录
        path = `${uploadDir}/${HASH}`
        !fs.existSync(path)?fs.mkdirSync(path):null
        // 创建切片文件
        path = `${uploadDir}/${HASH}/${filename}`
        isExists = await exists(path)
        if(isExists){
            res.send({
                code:0,
                codeText:'file is exists',
                originalFilename:filename,
                servicePath:path.replace(__dirname,HOSTNAME)
            })
            return 
        }
        writeFile(res, path, file, filename, true)
    }catch(error){
        res.send({
            code:1,
            codeText:err
        })
    }
})

// 合并切片并删除临时文件夹
const merge = function merge(HASH,count){
    return new Promise(async (resolve,reject)=>{
        let path = `${uploadDir}/${HASH}`,
            fileList = [],
            suffix,
            isExists
        
        isExists = await exists(path)
        if(!isExists){
            reject('HASH path is not found!')
            return 
        }
        fileList = fs.readdirSync(path)
        if(fileList.length<count){
            reject('this slice has not been uploaded')
            return 
        }
        fileList.sort((a,b)=>{
            let reg = /_(\d+)/
            return reg.exec(a)[1] - reg.exec(b)[1]
        }).forEach(item=>{
            !suffix?suffix = /\.([0-9a-zA-Z]+)$/.exec(item)[1]:null
            fs.appendFileSync(`${uploadDir}/${HASH}/${suffix}`,
                              fs.readFileSync(`${path}/${item}`))
            fs.unlinkSync(`${path}/${item}`)
        })
        fs.rmdirSync(path)
        resolve({
            path:`${uploadDir}/${HASH}/${suffix}`,
            filename:`${HASH}/${suffix}`
        })
        
        
    })
}

app.post('/upload_merge', async(req.res)=>{
    let {
        HASH,
        count
    } = req.body
    try{
        let {filename,path} = await merge(HASH,count)
        res.send({
            code:0,
            codeText:'merge success',
            originalFilename:filename,
            servicePath:path.replace(__dirname,HOSTNAME)
        })
    }catch(error){
        res.send({
            code:1,
            codeText:err
        })
    }
})
```

![image-20211030215501666](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211030215501666.png)



## 基于HTTP网络层的前端性能优化

产品性能优化的方面：

- HTTP网络层优化
- 代码编译层优化 webpack
- 代码运行层优化 html+css +JavaScript+vue +react
- 安全优化
- 数据埋点及性能监控



重点能力培养：

- 基础原理
- 性能优化
- 敏捷平台
- 管理协调能力（项目、人员管理）



性能优化中的关键词：CRP（Critical Rendering Path）关键渲染路径（思想） ：针对整个前端从头到尾的流程中的几个关键的节点上做性能优化。即先分析底层原理，整个网络层传输到浏览器端的东西，先分析底层原理，然后围绕着每个底层原理一步步处理。

其实性能优化的点非常多，分js，css，html等有数千条建议。但是在项目中基本只选择整个过程中最关键的几个节点，通过理解这些节点的关键原理后进行性能优化。

经典的面试问题：从url地址栏输入内容到看到页面中间的过程。

下面的几步中就是比较关键的节点。

### 第一步：浏览器进行URL解析

![image-20211031120157950](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031120157950.png)



 http协议和tcp/ip协议的关系

有哪些传输协议

端口号的作用

url编码

url编码：项目中前端向服务器发请求同时传递一些信息给服务器，可能遇到这个情况：比如访问以下的地址：

![image-20211031121442746](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031121442746.png)

其中传参数据部分包含了中文, / , : , 空格 等特殊字符。为了防止传给服务器的信息的乱码，则需要对 ? 后面的参数部分进行编码。 但编码处理的方式有许多：

- encodeURI: 给整个 url 进行编码   （服务端解码使用decodeURI），能编码空格，中文字符但是没有对http进行编码。

  

  encodeURI( url ), 使用encodeURI 编码后的结果：

  ![image-20211031121543547](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031121543547.png)

  
  
- encodeURIComponent: 主要是对传递的参数信息进行编码 （服务端解码使用decodeURIComponent），它除了可以处理空格和中文以外，还可以处理冒号,斜杠等特殊字符。

  encodeURIComponent的使用方式不同于encodeURI 。

![image-20211031122136130](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031122136130.png)

​				使用encodeURIComponent编码后的结果：

![image-20211031122221763](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031122221763.png)



- escape :  这个编码方式一般不用于客户端和服务器，因为服务器端中并非所有语言都支持 unescape解码，前端有escape 和unescape 方法。所以前后端交互一般不用它



URI  / URL  / URN的区别



在解析完url的各个部分之后，在 向服务器发送请请求之前还有一件事——缓存检查



### 第二步：缓存检查（产品优化重点）

向服务器发请求的前提条件是，如果没有设置缓存同时本地也没有缓存的话，就去服务器请求数据。如果本地有缓存且也设置了缓存的话，则直接走本地缓存而不用去服务器请求了。

缓存检查需要服务器和客户端的配合。缓存策略有两种：

- 强缓存
- 协商缓存

检测缓存的顺序是先检测是否有强缓存：

- 有强缓存且没有失效，则走强缓存
- 如果没有强缓存或者强缓存失效，继续检测是否有协商缓存
  - 有协商缓存，则走协商缓存
  - 没有协商缓存，则发送请求获取数据



缓存的位置：

- Memory Cache：内存缓存（存在内存条中，页面关闭则销毁）
- Disk Cache：硬盘缓存



重新打开一个网页，因为内存空间是新开辟的，所以没有内存缓存一说，直接找磁盘缓存。

![image-20211031132437953](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031132437953.png)

强缓存和协商缓存的配置是在nginx或者后端配置的，客户端浏览器会帮助实现缓存，前端不需要具体写代码。

打开一个页面刚开始的时候基本都是存在内存缓存中，当页面关闭的时候，如果有缓存机制的话，则会往硬盘中存放缓存。缓存主要有服务器设定，客户端做的事是有浏览器自动处理的。

![image-20211031133215786](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031133215786.png)

![image-20211031133315464](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031133315464.png)

![image-20211031133351254](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031133351254.png)





网站的html页面一般不做强缓存

![image-20211031133950385](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031133950385.png)



css,js,图片等常做缓存

![image-20211031134119611](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031134119611.png)

![image-20211031134224440](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031134224440.png)



![image-20211031134327810](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031134327810.png)



强缓存的问题：如果强缓存的文件在服务器端更新了，但是本地有强缓存且没有过期的话，这样客户端就无法获取最新的数据。为此有以下解决方案：

- HTMl页面不做强缓存，以保证html文件的请求走正常的http请求，只要html文件走正常的请求，剩下的网页需要使用到的所有资源，图片，css，js等都是放在html文件中的，以后服务器更新这些非html资源后，让资源的名称和之前的名称不再一样，在html文件中被引入后，跟随html返给前端，浏览器在解析时因为资源名字不再一样所以会重新请求新的资源而不再走缓存的内容，因为缓存中没有。

  webpack中就可以使用hash对文件进行更新识别并达到缓存效果。
  
- 当文件更新后，在html导入的时候，设置一个后缀（如时间戳）

  ![image-20211031140043626](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031140043626.png)

  

- 不走强缓存改走协商缓存



协商缓存：

没有强缓存或者强缓存失效后生效 。不管是否有缓存资源，浏览器都会携带缓存的标识向服务器发请求，由服务器来校验当前资源文件是否由更新，如果有更新则返回给客户端最新资源信息。如果更新资源文件，则返回一个304，客户端获取到304响应后再去本地缓存拿取数据。

![image-20211031140220780](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031140220780.png)

![image-20211031140706274](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031140706274.png)

![image-20211031140727718](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031140727718.png)





协商缓存和强缓存的区别：

协商缓存总会发送请求给服务器以确定资源状态。

强缓存则不一定会发请求给服务器。



![image-20211031141646473](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031141646473.png)



![image-20211031142053613](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031142053613.png)





Last-Modified 是http1.0的字段，Etag是http1.1的字段。有的前者还要使用后者原因是，前者只能精确到秒，这样就有可能还是存在没法获取最新资源的情况。

![image-20211031150403773](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031150403773.png)



![image-20211031150432478](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031150432478.png)



强缓存和协商缓存是针对静态资源文件同时还要是不经常更新的资源文件。



对于项目中Ajax请求的数据，一般走不了强缓存和协商缓存。数据缓存常用localStorage/vuex/redux。

![image-20211031150925608](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031150925608.png)

![image-20211031151045607](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031151045607.png)



### 第三步：DNS解析（域名解析）

DNS解析的两种方式：

- 递归查询

![image-20211031151510006](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031151510006.png)



- 迭代查询

![image-20211031152146918](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031152146918.png)




DNS也是有缓存的，如果之前解析过一个域名，一般会在本地有缓存

DNS解析： 域名转为ip地址的过程。

利用好DNS的本地缓存的话，可以优化项目。

每次DNS解析的耗时一般在20~120ms，



在DNS上优化：

- 减少DNS请求，一个页面中尽可能少用不同域名下的资源，资源尽可能都放在一个服务器上，但项目中不会这样处理，真实项目中往往会把不同的资源放在不同的服务器上。这样做虽然增加了DNS服务器的解析负担，但是增加了资源的合理利用，因为不同服务器承受的压力不同，web服务器压力小一些，数据服务器则压力大，图片和音视频服务器压力也更大，因为文件的体积大。 这样就可以更具压力选择购买服务器配置。
  

  当代浏览器都支持同一个源下 http请求的并发（4~7个），所以有服务器的集群的话则提高了一次发送数个http请求的数量。


  ![image-20211031152747075](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031152747075.png)

  

- DNS预获取

  link标签中有一个特殊的标签属性 rel="dns-prefetch"。

  

  ![image-20211031153510246](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031153510246.png)

  注意是放在html 的head标签中的，在还没有加载解析DOM结构的时候，就已经将这些请求发出开始进行DNS解析。 解析回来的结果就存在本地了。同时解析DNS的时候同时加载解析DOM结构。

![image-20211031153419982](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031153419982.png)

比如一个项目中：

- web服务器负责静态资源的发布和管理
- 数据服务器
- 音频/视频服务器
- 第三方平台服务器

![image-20211031153808476](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031153808476.png)



DNS解析完成后，已经拿到外网IP地址了，可以向服务器发送请求了。传输内容可以使用http/https/ftp等协议，但是传输数据必须要有一个数据通道。 所以向服务器发送请求之前还有一件事——建立连接通道。



### TCP三次握手

![image-20211031154408028](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031154408028.png)

 

![image-20211031154713606](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031154713606.png) 





为什么是三次握手而不是两个或者四次?

两次无法保证连接的可靠性，四次的话浪费性能。



UDP 



### 第五步：数据传输

传输通道在三次握手后建立。应用层软件开始通信。

![image-20211031155253268](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031155253268.png)



### 第六步：四次挥手

通信完成后，将连接通道断开，释放资源，这个过程由客户端在收到完整数据后由客户端首先发起释放连接的请求 。

![image-20211031155703929](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031155703929.png)



![image-20211031160203944](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031160203944.png)

每次向服务器发送请求都要建立tcp连接和断开。Connection:keep-alive 字段可以保证tcp通道在建立连接后不关闭。

Connection:keep-alive在http1.0中需要手动设置，在1.1中默认设置了。



### 第七步：页面渲染

客户端拿到数据后就开始解析渲染，之后的内容就是浏览器端的优化内容了，不再涉及网络模块的优化了。

- 浏览器的底层渲染机制
- DOM tree
- CSS tree
- layout tree
- render tree
- html优化
- css优化
- js优化
- vue项目优化
- react项目优化
- .......



http层的性能优化:

- 利用缓存机制
  - 强缓存和协商缓存
  - 本地存储

- DNS优化
  - 分部服务器，增加HTTP请求并发数量
  - DNS Prefetch
- TCP的三次握手四次挥手
  - 开启keep-alive
- 数据传输
  - 减少数据传输的大小，内容压缩，服务器端开启gzip压缩，大批量数据分批次请求（分页，下拉刷新）
  - 减少http请求的数量，雪碧图，字体图标，base64格式图片，资源合并
- CDN服务器分布式
- 采用http2.0
- 首屏加载优化
  - 增加loading效果图
  - SSR
  - 图片延迟加载
  - ....
- ....



http1.0 和 http1.1 和http2.0 的区别

http1.0 和 http1.1：

- 缓存处理
- 带宽优化和网络连接的使用
- 错误通知的管理
- Host头处理
- 长连接

![image-20211031171118944](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031171118944.png)

 http1.1 和http2.0 ：

- 新的二进制格式

- header压缩

- 服务端推送

- 多路复用

  

![image-20211031171239965](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031171239965.png)

![image-20211031171346644](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031171346644.png)

![image-20211031171404983](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211031171404983.png)





多路复用和长连接的区别：















### promise介绍

promise的优缺点：

- 优点：
  - 可以解决异步回调嵌套问题
  - 可以解决多个异步并发的问题
- 缺点
  - 还是要基于回调函数
  - promise无法终止异步



思路：

Promise是一个类

- promise类的实例可能有三个状态：pending,  resolved,  rejected
- 只能由pending变为resolved或者pending变为rejected
- 所有的Promise实例都有一个then方法
- 同一个promise实例可以调用多次then方法
- new Promise时传入一个参数，该参数是一个函数且被立即同步执行
- 如果执行器函数执行时报错，则立即执行reject



```js
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

class Promise{
    constructor(executor){
        this.state = PENDING
        this.value = undefined
        this.reason = undefined
        this.onResolvedCallbacks = []
        this.onRejectedCallbacks = []
        
        
        let resolve = (value)=>{  
            if(this.state === PENDING){
                this.value = value
                this.state = RESOLVED
                //发布
                this.onResolvedCallbacks.forEach(fn=>fn())
            }
        }
        
        let reject = (reason)=>{
            if(this.state === PENDING){
                this.reason = reason
                this.state = REJECTED
                //发布
                this.onRejectedCallbacks.forEach(fn=>fn())
            }
        }
        
        try{
            executor(resolve, reject)
        }catch(error){
            reject(error)
        }
    }
    
    then(onFulfilled, onRejected){
        onFulfilled = typeof onFulfilled === 'function ' ? onFulfilled : value =>value
        onRejected = typeof onRejected === 'function ' ? onRejected :error=>{throw error}
        
        if(this.state === RESOLVED){
            onFulfilled(this.value)
        }
        if(this.state === REJECTED){
            onRejected(this.reason)
        }
        if(this.state === PENDING){
            //订阅
            this.onResolvedCallbacks.push(()=>{
				onFulfilled(this.value)
            })
            //订阅
            this.onRejectedCallbacks.push(()=>{
                onRejected(this.reason)
            })
        }
    }
}
```

![image-20211114180652926](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114180652926.png)







- promise的then方法中接受两个可选的回调函数（onFulfilled和onRejected）这两个回调函数可以返回一个Pormise实例对象（三种状态中的任意一种都可以），可以返回基本数据类型的值，可以直接运行报错。
- 当then方法的回调函数返回一个Promise实例时，该Promise实例的结果将作为then方法返回的那个Promise实例的结果（value或者reason）

```js

// 因为所有的promise库都遵循promise A+ 规范，而该规范规定自己depromise库应该兼容所有的其他promise库
const resolvePromise = (promise2,x,resolve,reject) => {
    // 判断x的值是什么类型，基本数据类型，函数，对象或者另一个promise实例
    
    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
    }
    
    // 为了和其他promise库进行兼容
    if(typeof x === 'object' && x !== null || typeof x === 'function'){
        let called
        try{
            let x = x.then
            if(typeof then === 'function'){
                then.call(x, y=>{
                    if (called) return 
                	called =true
                    resolvePromise(promise2,y,resolve,reject)
                }, r=>{
                    if (called) return 
                	called =true
                    reject(r)
                })
            }else{
                // x是一个普通对象而非promise实例
                if (called) return 
                called =true
                resolve(x)
            }
        }catch(error){
            reject(error)
        }
    }else{
        //如果 x 是基本数据类型
        resolve(x)
    }
    
}



class Promise{
    then(onFulfilled, onRejected){
        let promise2 = new Promise((resolve,reject)=>{
            if(this.state === RESOLVED){
                setTimeout(()=>{
                    try{
                        //x 的值可能是基本数据类型也可以是promise实例
                        let x = onFulfilled(this.value)  
                        // 判断x的值去推到promise2的状态
                        resolvePromise(promise2,x,resolve,reject)
                    }catch(error){
                        reject(error)
                    }
                },0)
            }
            if(this.state === REJECTED){
                setTimeout(()=>{
                    try{
                        let x = onRejected(this.reason)
                    	resolvePromise(promise2,x,resolve,reject)
                    }catch(error){
                        reject(error)
                    }
                },0)
                let x = onRejected(this.reason)
                resolvePromise(promise2,x,resolve,reject)
            }
            if(this.state === PENDING){
                //订阅
                this.onResolvedCallbacks.push(()=>{
                    setTimeout(()=>{
                        try{
                            let x = onFulfilled(this.value)
                        	resolvePromise(promise2,x,resolve,reject)
                        }catch(error){
                            reject(error)
                        }
                    },0)

                })
                //订阅
                this.onRejectedCallbacks.push(()=>{
                    setTimeout(()=>{
                        try{
                            let x = onRejected(this.reason)
                        	resolvePromise(promise2,x,resolve,reject)
                        }cathc(error){
                            reject(error)
                        }
                    },0)

                })
            }    
        })
        return promise2
    }
}
```



### Promise.defer

可以减少一层promise的封装嵌套问题，并未是promise A+规则，但许多promise库都实现了该方法。

```js
Promise.defer = Promise.deferred = function(){
    let dfd = {}
    dfd.promise = new Promise ((resolve,reject)=>{
        dfd.resolve = resolve
        dfd.reject =reject
    })
    return dfd
}

module.exports = Promise
```

![image-20211114221418847](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114221418847.png)







检测自己的promise代码是否符合规范使用一个包——promises-aplus-tests。

![image-20211114211112757](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114211112757.png)









```js
const resolvePromise = (promise2,x,resolve,reject) => {
    // 判断x的值是什么类型，基本数据类型，函数，对象或者另一个promise实例
    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
    }   
}
```

上面的代码片段处理的情况如下图：

![image-20211114204045754](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114204045754.png)





### Promise.all

解决异步并发，同步处理结果。是类的静态方法。

```js
Promise.all = function (promises){
    let arr = []
    let index = 0    
    return new Promise((resolve,reject)=>{
   		for(let i=0;i<promises.length;i++){
            promises[i].then(value=>{
                if(index ===promises.length){
                    resolve(arr)
                }else{
                    arr[i] = value
                }
            },error=>reject(error))
        }
    })
}


const isPromise = (value)=>{
    if(typeof value === 'onject' &&value !=== null || typeof value === 'function'){
        if(typeof value.then === 'funciotn'){
            return true
        }
        return false
    }else{
        return false
    }
}

Promise.all = function (values){
    let arr = []
    let index = 0
    return new Promise((resolve,reject)=>{
        function processData(key,value){
            arr[key] =value
            if(++index === values.length){
                resolve(arr)
            }
        }
        for(let i=0;i<values.length;i++){
            if(isPromise(values[i])){
                values[i].then(value=>{
                    processData(i,value)
                },error=>reject(error))
            }else{
                processData(i,value)
            }
        }
    })
}
```



### Promise.finally（面试常考）

- finally  传入的函数不论失败或者成功都会执行
- 如果调用finally的promise是成功状态则成功的数据会传给下一个then的onFulfilled，如果是失败状态，则传给下一个then的onRejected
- finally中可以返回一个新得promise实例

```js
class Promise {
    finally(callback){
        return this.then(data=>{
            // Promise.resolve() 可以等待传参内部的promise执行完
            return Promise.resolve(callback()).then(()=>data)
        }, reason=>{
            return Promise.resolve(callback()).then(()=>{throw reason})
        })
    }
}
```

![image-20211114230156379](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114230156379.png)





### 回调地狱

- 代码可读性差
- 异步错误处理无法统一

![image-20211114182545007](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114182545007.png)







## generator

generator函数的特点是：函数体可以暂停

generator 可以和 promise 配合。

```js
function* read(){
    
}

let it = read()
```



扩展：

Array.from()  和 [....likeArray] 都可以将类数组转为数组。前者直接将类数组中的每一项取出以转为数组，后者是使用数据原型上的iterator，如果不支持iterator，则无法转换并报错。

![image-20211114231308278](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114231308278.png)



下图中使用生成器函数就是上图的语法糖写法：

![image-20211114231437052](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114231437052.png)



![image-20211114231721253](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114231721253.png)

![image-20211114231831279](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211114231831279.png)



generator和promise的连用

![image-20211115084516726](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211115084516726.png)









![image-20211115085559437](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211115085559437.png)

![image-20211115085350001](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211115085350001.png)



![image-20211115085642936](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211115085642936.png)



### async + await

模拟实现可以基于generator + co

![image-20211115090014568](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211115090014568.png)





## V8内存垃圾回收

- 内存
- V8
- 垃圾回收

### 计算机模型

![image-20211220113052223](C:\Users\dukkha\AppData\Roaming\Typora\typora-user-images\image-20211220113052223.png)

### 寄存器

- CPU的一部分
- 存储容量非常有限的高速存储部件
- 用于暂存指令，数据和地址
- 存储其中的数据可以用于执行算术和逻辑运算
- 存储其中的地址可以用于指向内存中的某个位置

### 内存

- 也称为随机存储器（Random Access Memory）
- 内存是与CPU直接交换数据的内部存储器
- 内存在工作时，可以从任何内存中的任何一个指定地址写入和读出数据
- 内存用来在计算机中暂时存储程序，数据和中间结果

32位操作系统支持的内存最多是2的32次方个字节，也就是4G。



### 内存空间分类

两类：

- 数据空间
- 指令空间



