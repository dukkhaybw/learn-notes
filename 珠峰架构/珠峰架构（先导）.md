# 珠峰架构（先导）

## ES6

### 变量声明

var 声明变量的问题：

- 在全局上下文中用 var 声明的变量会被作为 window 的属性，污染全局变量， let 和 const 则不会
- var 会在当前作用域中有变量提升（编译阶段导致变量声明和初始化都被提升）
- var 可以在同一个作用域下重复声明而不报错
- var 定义的变量没有块级作用域

使用 let 和 const 可以解决上面的那些问题。

### 展开运算符

（...） 可以用于对象或者数组的合并。(浅拷贝)

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。（浅拷贝）

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(target === returnedTarget);
// expected output: true
```

### 深浅拷贝

```js
let obj = { age: { index: 123 } };
obj.xxx = obj; // 解决循环引用深拷贝的情况
```

方式一：

```js
function deepClone(obj, hash = new WeakMap()) {
  if (typeof obj !== 'object' || obj === null) {
    //处理 基本数据类型 和 函数
    return obj;
  }
  if (obj instanceof RegExp) {
    // 正则
    return new RegExp(obj);
  }
  if (obj instanceof Date) {
    // 日期对象
    return new Date(obj);
  }
  if (hash.has(obj)) return hash.get(obj); //++++++++++++++++ 避免循环引用的情况

  //  let temObj = new obj.constructor  高级写法

  let tempObj = obj instanceof Array ? [] : {};
  hash.set(obj, tempObj); // +++++++++++++
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      tempObj[key] = deepClone(obj[key], hash);
    }
  }
  return tempObj;
}
```

方式二：

JSON.parse(JSON.stringify(value))，**该方法对于对象中方法或者值为 undefined 的属性等无法拷贝**。

### 判断类型

1. typeof
2. instanceof
3. Object.prototype.toString.call 格式： '[object Type]'
4. constructor

### set 和 map

集合 set 何如实现并集，交集和差集:

set 类型原型方法：

- add(value)
- delete(value)
- has(value)

```js
let s01 = [1, 2, 3, 6, 1, 7];
let s02 = [3, 4, 5];
// 不能放重复的数据
console.log(typeof new Set([1, 2, 3, 4, 5, 2])); //'object'

// 并集
function union(s1, s2) {
  return [...new Set([...new Set(s01), ...new Set(s02)])];
}

// 交集
function intersection(s1, s2) {
  let newS = [...new Set(s1)].filter((item) => {
    return new Set(s2).has(item);
  });
  return newS;
}

// 差集
function diff(s1, s2) {
  let newS = [...new Set(s1)].filter((item) => {
    return !new Set(s2).has(item);
  });
  return newS;
}
```

map：映射(key 可以是任何值)

```js
let m = new Map();
m.set('name', 'jack');
m.set('name', 'tom'); //覆盖前面的name

let obj = { name: 1 };
m.set(obj, '456');
obj = null;
console.log(obj); //null
console.log(m); // {'name'=>'tom',{name:1}=>'456'}
// 情况是虽然将obj置为null了，但是当前的map中还引用着{name:1}对象，该对象并没有被销毁。
```

WeakMap:key 必须是对象类型

```js
let m = new WeakMap();
m.set('name', 'jack'); // 该行报错， WeakMap的key必须是对象类型

let obj = { name: 1 };
m.set(obj, '456');
obj = null;
console.log(obj); //null
console.log(m); // { {name:1}=>'456' }
// 情况是将obj置为null了，但是当前的weakmap中不会强引用着{name:1}对象，该对象可以被销毁。
```

map 和 WeakMap 的区别

### 对象的 getter 与 setter

```js
Object.defineProperty(); //也支持数组方法的更新, 这种方式定义的属性默认不可枚举（enumerable），不可编辑(writable)，不可删除(configurable),可以数组中的已有的每个元素增加get和set ，但是不会给数组的length属性增加get和set方法。

// koa框架中就这么写了
let obj = {
  other: 'abc',
  get name() {
    return this.other;
  },
  set name(vale) {
    this.other = val;
  }
};
```

### 重写数组的基本方法

```js
const arr = ['push', 'pop', 'splice', 'unshift', 'shift', 'sort', 'reverse', 'slice'];
// 自己写的报错
let originArrayPrototype = { ...Array.prototype };
arr.forEach((item) => {
  Array.prototype[item] = function (...args) {
    // todosomething
    console.log(item);
    console.log(originArrayPrototype[item]); //该值为undefined
    originArrayPrototype[item](...args);
  };
});

//正确的写法 , 面向切片编程
arr.forEach((item) => {
  let oldMethod = Array.prototype[item];
  Array.prototype[item] = function () {
    //todoSomething
    oldMethod.call(this, ...arguments);
  };
});
```

调用数组的方法改变原数组时，系统底层会先改变数组的内容，然后改变数组的长度。所以当一个 proxy 实例代理的是一个数组时，当调用数组的方法对数组进行编辑时，会触发多次 set 方法，其中有一次是因为底层修改 length 属性时触发的，而非开发者主动修改 length 触发的。

```js
let arr = [1, 2, 3];
let proxy = new Proxy(arr, {
  set(target, key, value, originArr) {
    if (key === 'length') return true;
    // dosomething
    return Reflect.set(target, key, value, originArr);
  },
  get(target, key) {
    return Reflect.get(target, key);
  }
});
```

### 数组方法 2222222222

```js
// reduce:
let keys = ['name','age']
let values = ['jack',20]

let result = keys.reduce(function(prev,current,index,arr){
    prev[current] = values[index]
    return prev
},{})

// 写法二：  逗号运算符
let result = keys.reduce(
    (prev,current,index,arr)=>(prev[current] = values[index],prev),
    {}
)

console.log(result)



// 阿里面试题   redux中compose
function compose(...fns){
    return function(...args){
        let lastFn = fns.pop()
        return fns.reduceRight((prv,next,index,arr)=>{
            return next(prv)
        },lastFn(...args))
    }
}

function compose (...fns){  [add,upper,sum]
    return fns.reduce((a.b)=>{
        return (...args)=>{
            return a(b(...args))
        }
    })
}

let compose = (...fns)=>fns.reducer((a,b)=>(...args)=>a(b(...args)))

// 手写reduce
function reduce = (callback,prev){
    for(let i=0;i<this.length,i++){
        if(prev){
            prev = callback(prev,this[i],i,this)
        }else{
            prev = this[i]
            prev = callback(prev,this[i+1],i+1,this)
            i++
        }
    }
    return prev
}


// map   filter  some   every  find  findIndex   forEach
```

### 构造函数

构造函数的属性分为：实例属性（方法）和公有属性（方法）

继承：

```js
function Father(name){
    this.name = name
}
Father.prototype.address ={location:'shanghai'}

function Son(name,age){
    Father.call(this,name)   // +++++++++++ 继承父类实例属性
    this.age = age
}

// Son.prototype = Father.prototype  这不是继承，而是共用

// 继承方式一：
Son.prototype.__proto__ = Father.prototype
// 继承方式二：(等价于方式一)
Object.setPrototypeOf(Son.prototype,Father.prototype)

//继承方式三：
Son.prototype = Object.create(Father.prototype)  //注意这样的情况中Son实例的constructor是使用的父类的原型上的constructor，所以可以对Son类的constructor进行修复

// Son.prototype = new Father()

Son.prototype.do = function(){
    console.log('doSomething')
}


Object.prototype.create(proto){
    functioon Fun (){}
    Fn.prototype = proto
    return new Fun()
}
```

### 类的装饰器

装饰器可以修饰类、类的属性或者类原型上的方法

```js
@flag // 类的装饰器
class Person {}

function flag(constructor) {
  constructor.xxx = 'xxxx';
}

console.log(Person.xxx); // 'xxxx'

class Person {
  @readonly
  PI = 3.14;
  @before
  say() {
    console.log('say');
  }
}

function readonly(prototype, property, descriptor) {
  // prototype 是类的原型 即Person.prototype
  // property 是属性
  // descriptor 是该属性对应的属性描述符
}

function before(target, property, descriptor) {
  let say = descriptor.value; // 值就是修饰的原型上的方法——say
  descriptor.value = function (...args) {
    // 实现面向切片编程
    console.log('befor say');
    say.call(target, ...args);
  };
}

@flag(123)
class Person {}

function flag(value) {
  return function (constructor) {
    constructor.xxx = value;
  };
}

console.log(Person.xxx); // 123
```

### 高阶函数

#### 定义

能定义为高阶函数的情况：

1. 一个函数的参数是另一个函数（常见的回调函数就是一种高阶函数）
2. 一个函数返回另一个函数，则这个函数也是高阶函数

#### 应用场景

情况：

1. 面向切片编程

   扩展原有的业务方法，比如已经有一个函数，现在需要对他进行扩展，一般想到的就是在原函数上进行扩展，原有的方法被改写，他人在在调用时也不得不使用自己扩展的那部分逻辑。但是现在不用了，可以借助高阶函数实现扩展。 —— 目的是尽量不破坏原有的函数。

   ```js
   function say() {
     // todo...
     console.log('say');
   }

   let newFn = say.before(function () {
     console.log('say before');
   });

   newFn(); //它会将befor函数传入的函数先执行，然后再执行say方法

   // 箭头函数没有this,arguments,没有原型
   Function.prototype.before = function (callback) {
     let self = this;
     return function (...args) {
       callback();
       self(...args); //也可以用箭头函数
     };
   };

   Function.prototype.after = function (callback) {
     let self = this;
     return function (...args) {
       self(...args);
       callback(); //也可以用箭头函数
     };
   };
   ```

   react 中的 setState 中就用到了事务，也就是在 setState 函数执行前做一些事，执行后再做一些事。等同于 before 和 after。 react 事务：

   ```js
   function perform(fn, wrappers) {
     wrappers.forEach((wrapper) => {
       wrapper.initialize();
     });
     fn();
     wrappers.forEach((wrapper) => {
       wrapper.close();
     });
   }
   ```

   AOP:主要作用就是将一些跟核心业务逻辑模块无关的功能抽离，其实就是给原函数增加一层，不影响原函数内部的逻辑。

   ![image-20211113222412658](.\typora-user-images\image-20211113222412658.png)

   ```js
   function perform(anyMethod, wrappers) {
     wrappers.forEach((wrapper) => wrapper.initialize());
     anyMethod();
     wrappers.forEach((wrapper) => wrapper.close());
   }

   perform(
     function () {
       console.log('say');
     },
     [
       {
         initialize: function () {},
         close() {}
       },
       {
         initialize: function () {},
         close() {}
       }
     ]
   );
   ```

2. 函数柯里化，函数反柯里化

   ```js
   function isType(type) {
     return function (value) {
       return Object.prototype.toString(value) === `[object ${type}]`;
     };
   }

   let isString = isType('String');
   ```

   **面试常问：如何实现一个通用的函数柯里化？（通过一个柯里化函数，实现一个通用的柯里化方法）**

   ```js
   const cyrrying = function (fn, arr = []) {
     let length = fn.length;
     return function (...args) {
       arr = [...arr, ...args];
       if (arr.length < length) {
         return cyrrying(fn, arr);
       } else {
         return fn(...arr);
       }
     };
   };

   function sum(a, b, c, d, e) {
     return a + b + c + d + e;
   }

   let result = sum(1, 2)(3, 4)(5);
   ```

3. 解决一部并非问题

   ```js
   function after(n, callback) {
     let time = 0;
     return function () {
       time++;
       if (time === n) {
         callback();
       }
     };
   }

   function after(times, callback) {
     return function () {
       time--;
       if (time === 0) {
         callback();
       }
     };
   }

   let fn = after(3, function () {
     //fn执行3次后，第二个参数函数才会执行,并发问题
     console.log('after');
   });
   ```

### 发布订阅模式

```js
class EventBus {
  constructor() {
    this.event = {};
  }
  on(eventName, fn) {
    if (!this.event.hasOwnProperty(eventName)) {
      this.event[eventName] = [];
    }
    this.event[eventName].push(fn);
  }
  emit(eventName, ...args) {
    if (this.event.hasOwnProperty(eventName)) {
      this.event[eventName].forEach((fn) => {
        fn.call(this, ...args);
      });
    }
  }
  off(eventName, fn) {
    if (this.event.hasOwnProperty(eventName)) {
      let index = this.event[eventName].findIndex(fn);
      this.event[eventName].splice(index, 1);
    }
  }
}
```

### 观察者模式

```js
class Subject {
  constructor() {
    this.state = 'good';
    this.oberves = [];
  }
  attach(observe) {
    this.oberves.push(observe);
  }
  setState(data, ...args) {
    this.state = data;
    this.oberves.forEach((observer) => {
      observer.update(...args);
    });
  }
}

class Observe {
  constructor(name) {
    this.name = name;
  }
  update(...args) {
    console.log('--------------');
    console.log(args);
    console.log(this.name);
  }
}

let sub = new Subject();
let obs1 = new Observe('jack');
let obs2 = new Observe('tom');

sub.attach(obs1);
sub.attach(obs2);
sub.setState('bad', 'asd', 'zxc');
```

### 发布订阅和观察者模式的区别

区别在于发布和订阅是否存在关系。发布订阅中两者没有直接关系，没订阅也可以发布，没发布也可以订阅。

观察者模式是基于发布订阅的，同时观察者和被观察者之间是有关系的。

在 vue 中就是数据变化更新视图，监控数据的变化，数据变化后需要更新视图。

将观察者存到被观察中。

## Promise

- 高阶函数
- 发布订阅模式和观察者模式
- Promise 核心使用
- 实现一个完整的 Promise 库
- Promise 中常见面试题
- Promise 中的常见方法
- generator 的使用和 co 库结合使用
- async+await

promise 的优缺点：

- 优点：
  - 可以解决异步回调嵌套问题
  - 可以解决多个异步并发的问题
- 缺点
  - 还是要基于回调函数
  - promise 无法终止异步

实现 promise 的重要点：

- promise 可以是函数或者对象
- 创建 promise 实例时传入的 executor 函数是立即执行函数
- promise 实例有三种状态：pending、resolved 和 rejected
- 状态改变的方向有：pending=>resolved 、pending=>rejected
- 对象或者函数必须有一个 then 方法，then 方法接受两个参数：onFulfilled，onRejected
- onFulfilled，onRejected 是可选择的参数，不填写时有默认值，且该函数是异步触发的
- 对于同一个 promise 可以多次调用 then 方法，注意不是链式调用，并且执行时按照添加的顺序执行
- then 方法内部的 this 指向的是前一个 promise，且前一个 promise 的状态已经改变，所以无法用于下一次链式调用 then 的实例，所以 then 方法返回的是一个全新的 promise 实例
- 全新的 promise 实例的状态由 onFulfilled，onRejected 执行的返回值的结果决定，如果 onFulfilled，onRejected 返回值是除了抛错和另一个 promise 的情况时，全新的 promise 实例的状态的状态都为 resolved，并调用全新的 promise 实例的 resolve 方法并传递参数；如果是抛错和返回一个失败的新 promise，则全新的 promise 实例的状态为失败，且触发全新的 promise 实例的 reject 方法并传递失败的原因

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

function resolvePromise(promise2, x, resolve, reject) {
  /*
  let promise1 = new Promise((resolve,reject)=>{
    resolve(123)  
  })
  let promise2 = promise1.then(data=>{
    return promise2
  })
  */
  if (promise2 === x) return reject(new TypeError('Chaining cycle detected for promise'));
  let called;
  if ((typeof x === 'object' && x != null) || typeof x === 'function') {
    try {
      let then = x.then;
      if (typeof then === 'function') {
        then.call(
          x,
          (y) => {
            if (called) return;
            called = true;
            resolvePromise(promise2, y, resolve, reject);
          },
          (r) => {
            if (called) return;
            called = true;
            reject(r);
            // resolvePromise(promise2, r, resolve, reject);
          }
        );
      } else {
        if (called) return;
        called = true;
        resolve(x);
      }
    } catch (error) {
      reject(error);
    }
  } else {
    resolve(x);
  }
}
class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];

    let resolve = (value) => {
      if (this.status === PENDING) {
        this.value = value;
        this.status = FULFILLED;
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    };

    let reject = (reason) => {
      if (this.status === PENDING) {
        this.reason = reason;
        this.status = REJECTED;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  then(onFulFilled, onRejected) {
    onFulFilled = typeof onFulFilled === 'function' ? onFulFilled : (v) => v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : (e) => {
            throw e;
          };
    let promise2 = new Promise((resolve, reject) => {
      if (this.status === FULFILLED) {
        setTimeout(() => {
          try {
            let x = onFulFilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }
      if (this.status === REJECTED) {
        setTimeout(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }
      if (this.status === PENDING) {
        this.onResolvedCallbacks.push(() => {
          try {
            let x = onFulFilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
        this.onRejectedCallbacks.push(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        });
      }
    });
    return promise2;
  }
}

//Promise的延迟对象
Promise.defer = Promise.deferred = function () {
  let dfd = {};
  dfd.promise = new Promise((resolve, reject) => {
    dfd.resolve = resolve;
    dfd.reject = reject;
  });
  return dfd;
};

module.exports = Promise;
```

## 前端基础

### call：

```js
Function.prototype.call = function (context, ...args) {
  context = context ? Object(context) : window;
  context.fn = this;
  let result = context.fn(...args);
  delete context.fn;
  return result;
};

function fn2() {
  console.log(this, 2);
}

Function.prototype.call.call.call(fn2);
```

### apply：

```js
Function.prototype.apply = fucntion(context,...args){
    context = context?Object(context):window
    context.fn = this
    let result = context.fn(args)
    delete context.fn
    return result
}
```

### bind:

- 绑定函数的 this 指向，绑定参数
- 返回一个函数
- 返回函数可以被 new 调用，且函数内部的 this 会指向 new 创建的实例对象
- new 出来的对象可以访问到原有类的原型

```js
function.prototype.bind = function(context,...args1){
    let that = this
    function Fn(){}
    function fBind(...args2){
        return that.call(this instanceof fBind?this:context,...args1,...args2)
    }
    Fn.prototype = this.prototype
    fBind.prototype = new Fn()
    return fBind
}
```

### 模拟 new：

new 操作所作的事情：

- 创建了一个全新的对象。
- 这个对象会被执行`[[Prototype]]`（也就是`__proto__`）链接。
- 生成的新对象会绑定到函数调用的`this`。
- 通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
- 如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。

```js
function newFn(constructor, ...args) {
  if (typeof constructor !== 'function') {
    throw 'newOperator function the first param must be a function';
  }
  newOperator.target = ctor;
  var newObj = Object.create(ctor.prototype);
  var ctorReturnResult = ctor.apply(newObj, args);
  var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;
  var isFunction = typeof ctorReturnResult === 'function';
  if (isObject || isFunction) {
    return ctorReturnResult;
  }
  return newObj;
}
```

### 0.1+0.2 != 0.3：

在计算机底层，所有的数据都是以二进制的形式存储的，即使是数学运算时，也是先将数据转为二进制后再进行计算的。

进制转换的规则：

- 整数转换

  `n*2^(n-1) + n-1*2^(n-2)+...+(0|1)*2^0`

- 小数转换

  `n*2^-1+n*2^-2+....`

```js
11 //二进制
转 十进制
1*2^1+1*2^0 = 3



1010  //二进制
转 十进制
1*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = 10

0.1  //二进制
转  十进制
0*2^0 +1*2^-1 = 0.5

0.1  //十进制
转  二进制
0.1*2 =0.2    0
0.2*2 =0.4    0
0.4*2 =0.8    0
0.8*2 =1.6    1
0.6*2 =1.2    1
0.2*2 =0.4    0
0.4*2 =0.8    0
0.8*2 =1.6    1
0.6*2 =1.2    1
........
所以0.1转为二进制  0.00011001100110011.....

0.2  //十进制、
转  二进制
0.2*2 = 0.4   0
0.4*2 = 0.8   0
0.8*2 = 1.6   1
0.6*2 = 1.2   1
0.2*2 = 0.4   0
.....
所以0.2转为二进制   0.0011001100110011.....

所以在将0.1+0.2转为二进制进行运算时，已经出现偏差所以无法等于0.3  而是0.300000000000004
```

### instanceof:

```js
function instanceof (obj,classFn){
    let proto = obj.__proto__
    while(proto){
        if(proto === classFn.prototype){
            return true
        }
        proto = proto.__proto__
    }
    return false
}
```

### js 执行上下文栈和作用域链

每个函数执行的时候都会产生一个执行上下文，这些执行上下文的管理是通过 js 引擎创建的执行上下文栈（Execution Context Stack）进行。创建一个执行上下文栈，默认执行的时候会产生一个全局上下文进行入栈，当代码执行到函数调用时就会产生函数执行上下文并进行入栈，函数中还能继续调用函数，也进行入栈。函数一旦执行完成便先进栈的后出栈。出栈就意味着执行上下文栈被销毁，内部的属性也一并被回收。

执行上下文有三个非常重要的属性：

- 变量对象
- 作用域链
- this 指向

作用域是在函数定义的时候就确定的，函数会保存一个内部属性`[[scope]]`。这个[[scope]]属性中保存所有的祖先执行上下文中的变量对象。注意这个 scope 属性并非完整的作用域链。 查询变量时，是在变量对象中进行查找的。

函数执行时，先产生函数执行上下文进行入栈，在函数的执行上下文中确定上述的三个重要的属性：VO，作用域链，this 指向。其中作用域链对应的 key 值是 Scope，Scope 代表的是真正的作用域。该 Scope 属性的值会赋值一份函数定义时确定的作用域，即[[scope]]属性对应的值，同时在加上该函数执行上下文中的 VO 对象。当要查找变量时，现在自己的 AO 对象中查找，找不到在沿着 Scope 中的祖先执行上下文中的变量对象进行依次查找，找不到就直到全局执行上下文。

全局上下文中的 VO（AO）就是全局的 this 指向也是全局对象。AO 由 VO（var 和 function 声明的变量）+arguments 激活而来。

执行上下分为两个阶段进行：

- 预解析阶段
  1. 形参初始赋值
  2. function 声明提升并赋值（同名后面覆盖前面）
  3. var 声明只提升（同名则不再处理）
- 代码执行阶段

### js 类型转换

```js
1+true // 2
1+null // 1
null+null // 0
1+undefined //NaN
1+{}  // '1[onject Object]''
1+[]  // '1'
1+[11] //'111'
1+[11,12]  //'111,12'
true+true //2

true+{}  //'true[onject Object]'

let obj ={
    valueof(){
        return 100
    },
    toString(){
        return 200
    }
}
true+obj //101

let obj ={
    valueof(){  //先调用
        return
    },
    toString(){
        return 200
    }
}
true+obj // 101


let obj ={
    valueof(){
        return {}
    },
    toString(){
        return 200
    }
}
true+obj // 201


对象的valueof方法不是一个基本数据类型时，再调用toString方法
{}.valueof()  // {}



let obj ={
    valueof(){
        return {}
    },
    toString(){
        return {}
    }
}
true+obj // toString还是返回一个对象，则直接报错



let obj ={
    [Symbol.toPrimitive](){
      return 500
    },
    valueof(){
        return {}
    },
    toString(){
        return {}
    }
}
true+obj //501

[Symbol.toPrimitive] 方法到valueof方法 再到toString方法


typeof +'a' // 'number'    NaN
1++'123'  // 124

```

## Node 基础

### 定义

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境(runtime),Node 不是一门语言是让 js 运行在后端的运行时,并且不包括 javascript 全集,因为在服务端中不包含 DOM 和 BOM,Node 也提供了一些新的模块例如 http,fs 模块等。Node.js 使用了事件驱动、非阻塞式 I/O 的模型，使其轻量又高效并且 Node.js 的包管理器 npm，是全球最大的开源库生态系统。

### node 的优势

Node 在处理高并发,I/O 密集场景有明显的性能优势

- 高并发,是指在同一时间并发访问服务器

- I/O 密集指的是文件操作、网络操作、数据库,相对的有 CPU 密集,CPU 密集指的是逻辑处理运算、压缩、解压、加密、解密

- 单线程特点是节约了内存,并且不需要在切换执行上下文

- 而且单线程不需要管锁的问题.

  > Web 主要场景就是接收客户端的请求读取静态资源和渲染界面,所以 Node 非常适合 Web 应用的开发。

![img](http://www.zhufengpeixun.com/advance/assets/img/2.1a033437.png)

### Node 中的事件循环

![img](http://www.zhufengpeixun.com/advance/assets/img/1.4f572942.png)

- 写的 js 代码会交给 v8 引擎进行处理
- 代码中可能会调用 nodeApi,node 会交给 libuv 库处理
- libuv 通过阻塞 i/o 和多线程实现了异步 io
- 通过事件驱动的方式,将结果放到事件队列中,最终交给我们的应用。

```
   本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
|   执行延迟到下一个循环迭代的 I/O 回调。
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
|   仅系统内部使用。
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘
|  检索新的I/O事件;执行与 I/O相关的回调  ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  setImmediate() 回调函数在这里执行。  └───────────────┘
│  ┌─────────────┴─────────────┐
│  │           check           │
│  └─────────────┬─────────────┘
|  一些关闭的回调函数
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

> 这里每一个阶段都对应一个事件队列,当 event loop 执行到某个阶段时会将当前阶段对应的队列依次执行。当该队列已用尽或达到回调限制，事件循环将移动到下一阶段。
>
> `process.nextTick()` 从技术上讲不是事件循环的一部分。优先级高于微任务

**poll 阶段:**

1.检测 Poll 队列中是否为空，如果不为空则执行队列中的任务，直到超时或者全部执行完毕。

2.执行完毕后检测 setImmediate 队列是否为空，如果不为空则执行 check 阶段，如果为空则等待时间到达。时间到达后回到 timer 阶段

3.等待时间到达时可能会出现新的 callback，此时也在当前阶段被清空

### 全局对象

- process 进程

  - platform：区分系统平台，比如 window 和 mac 系统下需要在用户路径下写文件时就需要判断操作系统。

  - argv：参数列表 node xx.js a,b,c,d 第三方包：commander（TJ 写的）专门处理执行 js 文件时的传参。

  - cwd( )：当前工作目录

    ```
    node yyy/xxx.js  此时的cwd的值是yyy文件夹所在的目录
    ```

  - env：环境变量

- Buffer 二进制缓存区，在服务器环境下可以读写文件，读出的内容都是二进制格式，就是存在缓存中，表示时用 16 进制表示

- setInterval,setTimeout,setImmediate

- console

- queueMicrotask

### node 中的模块

每个 js 文件默认都是包裹在一个函数（该函数有参数传入）内部且函数的 this 被改写，能实现模块化。

- \_\_dirname
- \_\_filename
- exports
- module
- require()

commander:

```js
let program = require('commander');
program.on('--help', function () {
  console.log('xxxx');
});
program.option('-p,--port <value>', 'set server port');
program.command('create').action(() => {
  // ...
});
program.version('1.0.0');
let obj = program.parse(process.argv);
```

cross-env:跨平台设置环境变量

```
cross-env b=2 node xxx.js
```

## Node 中的模块

### commonjs 规范

- 1.每个 js 文件都是一个模块
- 2.模块的导出 module.exports
- 3.模块的导入 require

### node 中的模块的分类

- 1.核心模块/内置模块 fs http path 不需要安装 引入的时候不需要增加相对路径、绝对路径
- 2.第三方模块需要安装
- 3.自定义模块需要通过绝对路径或者相对路径进行引

### 模拟模块的前置知识

- path 模块：处理路径
- fs 模块：文件操作
- vm 模块：虚拟机模块

path:

- resolve(\_\_dirname,url)

  ```
  resolve(__dirname,'src','/')   解析到/则直接解析为当前执行磁盘根路径
  ```

- join(\_\_dirname,url)

  ```
  join(__dirname,'src','/')    ...绝对路径/src/  路径拼接
  ```

- dirname(url):返回当前路径的父级路径

- basename('xxx.js','.js') // xxx

- extname('xxx.min.js') // .js

## Vue 基础

### 库与框架

- 库是将代码集合成一个产品,库是开发者主动调用库中的方法实现自己的功能。
- 框架是为解决一类问题而开发的产品,框架是在指定的位置编写好代码，框架去调用。

### MVC 和 MVVM 区别

- 传统的 MVC 指的是,用户操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数 据。将结果返回给前端,页面重新渲染
- MVVM :传统的前端会将数据手动渲染到页面上, MVVM 模式不需要用户手动操作 dom 元素,将数据绑 定到 viewModel 层上，会自动将数据渲染到页面中，视图变化会通知 viewModel 层，由 VM 层去更新数据。

> Vue 并没有完全遵循 MVVM 模型(是 Vue 中的响应式原理部分遵循了 MVVM)，严格的 MVVM 模式中,View 层不能直接和 Model 层通信,只能通过 ViewModel 来进行通信。

![image-20210824204139126](.\typora-user-images\image-20210824204139126.png)

vue 有两种模式：

- runtime-with-compiler
- runtime without conpiler

Vue 中渲染模板采用的优先顺序：

1. 先查找用户传入的`render(h){return h('h1',{id:'app'},this.name)}`
2. 配置对象中没有 render 方法，找配置对象中的 template 配置项对应的模板
3. 没有前面两者，如果有 el，采用配置对象 el 对应的外部模板

templte=>ast 语法树=>render 函数=>内部调用 render 函数

```js
let vm = new Vue({
  el: '#app',
  data: {
    name: 'hello world'
  },
  render(h) {
    return h('h1', { id: 'app' }, this.name);
  }
});
```

注意：虽然 vue2 是数据改变会影响视图，但是并不是只要数据变化就一定会影响视图重新渲染。必须注意变更数据方式或者方法。

无法实现响应式的例子：

```js
let vm = new Vue({
  el: 'app',
  data() {
    return {
      name: 'jack',
      arr: [1, 2, 3]
    };
  }
});
vm.name = 'tom'; //这能实现数据响应式
vm.gender = 'male'; // 这不能实现响应式
vm.arr[0] = 11; //这无法实现响应式
```

数据劫持:

处理对象数据

```js
function observer(obj){
	if(typeof obj !==='object' || obj === null){
        return  obj
    }

    for(let key in obj){
        defineReactive(obj,key,obj[key])
    }

    function defineReactive(obj,key,value){
        Object.definedProperty(obj,key,{
            get(){
                return value
            },
            set(newValue){
                if(newValue !== value){
                    value = newValue
                    ...视图更新逻辑
                }
            }
        })
    }
}

情况一：
let data = {name:'jack'}
observer(data)
data.name = 'tom'  //触发视图更新
data.a = 'hello'  //不会触发视图更新，因为在对data进行数据劫持时没有a这个属性存在。除非自己在后面再调用一次observer(data)    在vue中的解决办法有特别提供：vm.$set()


情况二：
let data = {data:{name:'jack'}}
observer(data)
data.data.name = 'tom'   //不会触发视图更新，因为数据劫持只做了一层
data.data = { age:20}    //触发视图更新
```

```js
function observer(obj){
	if(typeof obj !==='object' || obj === null){
        return  obj
    }

    for(let key in obj){
        defineReactive(obj,key,obj[key])
    }

    function defineReactive(obj,key,value){
        observer(value)   //递归进行数据劫持，以解决上面情况二的不足，问题是比较耗性能
        Object.definedProperty(obj,key,{
            get(){
                return value
            },
            set(newValue){
                if(newValue !== value){
                    value = newValue
                    ...视图更新逻辑
                }
            }
        })
    }
}

情况三：
let data = {data:{name:'jack'}}
observer(data)
data.data.name = 'tom'   //触发视图更新
data.data = { age:20}    //触发视图更新
data.data.age = 22  //不会触发视图更新，因为新增加的对象类型的数据的属性并没有进行过数据劫持
```

```js
function observer(obj){
	if(typeof obj !==='object' || obj === null){
        return  obj
    }

    for(let key in obj){
        defineReactive(obj,key,obj[key])
    }

    function defineReactive(obj,key,value){
        observer(value)
        Object.definedProperty(obj,key,{
            get(){
                return value
            },
            set(newValue){
                if(newValue !== value){
                    observer(newValue)  //如果新修改的数据是对象类型的数据，则对其也进行数据劫持，解决上面的情况三的问题
                    value = newValue
                    ...视图更新逻辑
                }
            }
        })
    }
}
```

处理数组数据

```js
let arrayProto = Array.prototype
let proto = Object.create(arrayProto);
['push','shift','splice'].forEach(method =>{
    proto[method] = function(...args){
        let inserted
        switch (method){
            case 'push':
            case 'unshift':
				inserted = args
            	break;
            case 'splice':
                inserted = args.slice(2)   //splice方法接收3个数据时才是插入数据
            default:
                break;
        }
        ArrayObserver(inserted)
        arrayProto[method].call(this,...args)
        ...数组更新逻辑
    }
})

function ArrayObserver(obj){
    for(let i=0;i<obj.length;i++){
        let item =obj[i]
        observer(item)
    }
}

function observer(obj){
	if(typeof obj !==='object' || obj === null){
        return  obj
    }

    //这段是针对数组的数据劫持
    if(Array.isArray(obj)){
        Object.setPrototypeOf(obj,proto)   //对数组的方法进行重写,注意：只要data中存在一个数据是数组类型的，那么就会针对这一个数组类型的数据进行原型的重写，所有data中有几个数组类型的数据就重写几次，也算是不足之处。
		ArrayObserver(obj)
    }else{
        //以下是针对对象的数据劫持
        for(let key in obj){
            defineReactive(obj,key,obj[key])
        }
    }


    function defineReactive(obj,key,value){
        observer(value)
        Object.definedProperty(obj,key,{
            get(){
                return value
            },
            set(newValue){
                if(newValue !== value){
                    observer(newValue)
                    value = newValue
                    ...视图更新逻辑
                }
            }
        })
    }
}

let data = {data:[1,2,3]}
observer(data)
data.data[0] = 100  //无法触发视图更新


let data = {data:[{name:'jack'}，2]}
data.data[0].name = 'tom'  //在vue中是能触发视图渲染的
data.data[1] = 200   //数组元素中的值是基本数据类型时，该基本数据类型的值是没有响应式能力，同时修改数组长度属性length也是无法触发视图渲染的。
```

vue2 中对于数组更新实现数据劫持的方法有：

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

底层原理是重写了这些方法，因为这些方法能改变元数组对象。相比之下，也有非变更方法，例如 `filter()`、`concat()` 和 `slice()`。它们不会变更原始数组，而**总是返回一个新数组**。当使用非变更方法时，可以用新数组替换旧数组。

```js
example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/);
});
```

Vue 实例的常用方法与属性：

```js
vm.$set(vm.key, key, value);

vm.$delete();

vm.$mount();

vm.$options;

vm.$data | vm._data;

vm.$nextTick(fn);

vm.$watch(); //watch监视属性的回调函数也是在数据变化后的下一个事件环中执行的。

vm.$el; //这个属性存放的是el字段指定的真实的DOM元素
```

在 vue 中使用表达式语法，表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。

```js
let vm = new Vue({
	el:'#app',
    data(){
        return {name:'jack'}
    }
})
vm.$el  //这个属性存放的是el字段指定的真实的DOM元素
vm.$watch('name',function (newVal,oldVal){
    console.log('执行次数')    //虽然name改了两次，但是watch默认只响应了一次，因为watch监视属性的回调函数也是在数据变化后的下一个事件环中执行的。
})
vm.name = 'tom'
vm.name 'mick'
// 上面数据修改了两次但是视图只重新渲染一次
```

注意：

**vue 有一个特点，在代码中，data 中的数据被改变时不会在本轮代码执行完之前进行视图的重写渲染。**而是在下一个事件环中重新渲染视图。 data 中的数据是同步更新的，但是视图是异步更新渲染的。

在 Vue 中数据更新后会有一个队列，将 watch，$nextTick 的回调函数放入队列。 在视图更新后才会依次执行队列中的方法。

### 指令

指令的核心目的是操作 DOM

```js
v-once

v-html

v-text

v-model

v-if/v-else-if/v-else ： 在vue框架中，v-if相关指令对应的部分最后会被编译render函数中为三元表达式

v-show

v-for

v-on / @

v-bind / :
```

```js
vm.$set(vm.arr, 0, 100); // 修改数组内部使用的是splice方法
vm.$set(vm.address, 'number', '6-301'); // 新增属性通过内部会将属性定义成响应式数据
vm.$delete(vm.arr, 0); // 删除索引，属性
```

有一个包：vue-template-compiler，可以将 html 字符串编译为 render 函数调用的形式。

```js
const vtmplate = require('vue-template-compiler');

let str = `<div v-if="true">hello</div><div v-else>world</div>`;

console.log(vtmplate.compile(str).render);
// 输出结果：
//with(this){return (true)?_c('div',[_v("hello")]):_c('div',[_v("world")])}
// 使用 v-if 的最终被编译为三元表达式，条件不满足节点就不渲染
// v-if可以配合template一起使用

let str2 = `<div v-show="true">hello</div>`;
// 输出结果：
// with(this){return _c('div',{directives:[{name:"show",rawName:"v-show",value:(true),expression:"true"}]},[_v("hello")])}
// 使用 v-show 结束出来的是由指令起作用的，在指令中通过控制节点的样式style的display来控制显示与隐藏
```

有一道面试题：v-if 和 v-show 的区别，现在可以从源码的角度给与一定的更有深度的回答。

有一道面试题：display：none、opacity、visibility:hidden 的区别：

display：none 不占位且绑定的事件不被触发

opacity：占位置且绑定的事件依旧有效

visibility:hidden：占位置但啊绑定的事件不会生效

有一道面试题：v-if 和 v-for 的连用和优先级

v-for 的优先级大于 v-if，是先将数据全部循环一边生成对应的节点，然后再判断节点的 v-if 是否满足条件，不满足再去掉，所以对性能不友好。

```js
const vtmplate = require('vue-template-compiler');

let str2 = `<div v-for="(a,index) of arr" :key='index' v-if="a%2===0">hello</div>`;

console.log(vtmplate.compile(str2).render);

// 输出结果：  _l表示循环一个列表的函数
with (this) {
  return _l(arr, function (a, index) {
    return a % 2 === 0 ? _c('div', { key: index }, [_v('hello')]) : _e(); //每个循环中都有条件判断
  });
}
```

v-for 循环中的 key 值：

![image-20210825000354819](.\typora-user-images\image-20210825000354819.png)

使用 index 索引值做循环元素的 key 值时存在不做的例子：

比如对数组做反转后，每个 dom 元素还是一样的，但是 dom 元素中的文本或者其他数据的顺序不再正确，这时 vue 就会对 dom 元素内部的文本节点或者其他元素节点进行增删，而不是直接移动外层的 DOM 元素，从而造成性能损失。

如果将一个方法定义在 data 中那么方法中的 this 指向的并不是当前 vue 实例对象而是 window。同时，定义在 methods 中的方法中的 this 在 vue 底层使用 bind 方法绑定死了，即使是通过 call，apply 等方法都不能改变 this 的指向了。这样就不能在别的组件中复用这个组件的对应方法了，vue3 中解决的这个问题。

v-model：

v-mode 除了用在表单控件中以外，还可以用在组件标签中，只是组件标签内部的 input 事件其实就不再是原生的 input 事件。

```vue
<input type="text" :value="value" @input="fn" />

<input type="text" :value="value" @input="fn($event)" />

<input type="text" :value="value" @input="(e) => (value = e.target.value)" />

<input type="text" v-model="value" />

methods：{ fn(e){ this.value = e.target.value } }
```

### 自定义指令

全局指令：

```js
// el:代表当前指令绑定所在的DOM实例
// bindings：指令的各种属性
// vnode：表示指令所在的context上下文

Vue.directive('focus', function (el, bindings, vnode) {
  console.log(el, bindings, vnode);
});
//这种第二个参数是一个回调函数的写法，默认会在vue框架解析到绑定有该指令的模板节点时就触发一次执行，同时指令所绑定的数据（指令等于号后面的数据）每次发生改变时也会再次执行。   只有指令依赖的数据发生变化才能重新执行。

//上面的写法等价于下面这个写法:

Vue.directive('focus', {
  bind(el, bindings, vnode) {
    console.log(el, bindings, vnode);
  },
  update(el, bindings, vnode) {
    console.log(el, bindings, vnode);
  }
});
```

![image-20210825201954025](.\typora-user-images\image-20210825201954025.png)

clickOutside:

常出现在日历，弹层与选项卡的情况中。点击某个元素，弹出一个面版，当点击该 dom 元素或者面板以外的其他区域时，该面板隐藏。

```
<div v-click-outside='blur'>
	<input type='text' @focus='focus'>
	<div class='content' v-if='isShow'>
		<button>点击</button>
	</div>
</div>

directives:{
    dName:{
    	bind(el,bindings,vnode,oldVnode){
            // 在该指令函数中并不能访问到绑定指令的元素的父元素节点，即el.parentNode 为null，如果想在这里面获取父元素则可以使用Vue.nextTick(()=>{....})
        },
        inserted(el,bindings,vnode,oldVnode){

        },
        update(el,bindings,vnode,oldVnode){

        },
        componentUpdated(el,bindings,vnode,oldVnode){

        },
        unbind(el,bindings,vnode,oldVnode){

        }
    },
    clickOutside:{
        bind(el,bindings,vnode){
            el.handler = function(e){{
                if(!el.contains(e.target)){
                    vnode.context[bindings.expression]()   ++++++++++++++++
                }
            }
            document.addEventListener('click',el.handler)
        },
        unbind(el){
            document.removeEventListener('click',el.handler)
        }
    }
}
```

vue-lazyload——vue 项目中的图片懒加载包：

```js
Vue.use(VueLazyload,{
    preLoad:1.3,
    loading:'http://localhost:3000/images/xxx.gif'
})


<img v-lazy='img' />
```

lazy:

```js
// 找祖先元素中overflow为scroll或者auto的祖先元素
const getScrollParent = function (el) {
  let parentNode = el.parentNode;
  while (parentNode) {
    if (/(scroll)|(auto)/.test(getComputedStyle(parentNode)['overflow'])) {
      return parentNode;
    }
    parentNode = parentNode.parentNode;
  }
  return parentNode;
};

const loadImageAsync = function (src, resolve, reject) {
  let image = new Image();
  image.src = src;
  image.onload = resolve;
  image.onerror = reject;
};

const Lazy = (Vue) => {
  //每个图片标签都对应创建一个对应实例对象，方便扩展和分装
  class ReactiveListener {
    constructor({ el, src, options, elRender }) {
      this.el = el;
      this.src = src;
      this.elRender = elRender;
      this.options = options;
      this.state = { loading: false, error: flase }; //用于确认图片是否加载过
    }
    checkInView() {
      let { top } = this.el.getBoundingClientReact();
      return top < window.innerHeight * (this.options.preLoad || 1.3);
    }
    load() {
      this.elRender(this, 'loading');
      // 懒加载的核心
      loadImageAsync(
        this.src,
        () => {
          this.state.loading = true;
          this.elRender(this, 'finish');
        },
        () => {
          this.state.error = true;
          this.elRender(this, 'error');
        }
      );
    }
  }

  return class lazyClass {
    constructor(options) {
      this.options = options;
      this.bindHandler = false;
      this.listenerQueue = [];
    }
    // 每个绑定了v-lazy指令的标签都会在bind阶段走一次该函数
    add(el, bindings, vnode) {
      Vue.$nextTick(() => {
        let scrollParent = getScrollParent(el);
        //this.bindHandler作为条件避免给祖先元素多次绑定同一个事件——scroll
        if (scrollParent && !this.bindHandler) {
          this.bindHandler = true;
          scrollParent.addEventListener('scroll', this.handleLaztLoad.bind(this));
        }

        // 判断当前这个懒加载标签是否在条件规定的可视范围中，如果不在就不加载渲染图片
        // 为每个标签元素都绑定一个对应的实例对象，并交给当前的lazy实例统一管理
        const listener = new ReactiveListener({
          el,
          src: bindings.value,
          options: this.options,
          elRender: this.elRender.bind(this)
        });
        this.listenerQueue.push(listener);
        this.handleLaztLoad();
      });
    }

    handleLaztLoad() {
      // 这里用于管理图片对象中对应的那些图片标签应该加载
      // 计算当前图片是否在可视区域内
      this.listenerQueue.forEach((listener) => {
        if (!listener.state.loading) {
          let catIn = listener.checkInView();
          catIn && listener.load();
        }
      });
    }
    elRender(listener, state) {
      // 渲染方法
      let el = listener.el;
      let src = '';
      switch (state) {
        case 'loading':
          src = listener.options.loading || '';
          break;
        case 'error':
          src = listener.options.error;
          break;
        default:
          src = listener.src;
          break;
      }
      el.setAttribute('src', src);
    }
  };
};

function install(Vue, options) {
  const lazyClass = Lazy(Vue); // 将业务逻辑封装在类中，再把类封装在一个函数Lazy中
  const lazy = new lazyClass(options);
  //定义全局指令 v-lazy
  Vue.directive('lazy', {
    bind: lazy.add.bind(lazy)
  });
}

export default {
  install
};
```

watch

```js
let vm = new Vue({
    el:'#app',
    data(){
        return {
            name:{name:'jack'},
            age:20
        }
    },
    watch:{
        name(newVal){
            ......
        },
        age:{
            handler(newValue){
                .....
            },
            immediate:true,
           	deep:true, //深度监视
            lazy:true
        }
    }
})
```

computed

```js
initComputed('fullname', () => {
  return vm.name + '!';
});

let dirty = true; //脏值检测
function initComputed(key, handler) {
  let value;
  Object.defineProperty(vm, key, {
    get() {
      if (dirty) {
        value = handler();
        dirty = false;
      }
      return value;
    }
  });
}
```

```js
computed:{
	checkAll:{
		get(){
			return ...
		},
		set(){
			.....
		}
	}
}
```

### 动画

vue 中的动画可以配合 v-if，v-show，v-for 和路由切换的场景使用。

使用方式：

```html
<style>
  .v-enter {
    ...;
  }

  .v-enter-active {
    transition: all 1s;
  }

  .v-enter-to {
    ....;
  }
  .content {
    ....;
  }
  .v-leave {
    ...;
  }
  .v-leave-active {
    transition: all 1s;
  }
  .v-leave-to {
    ...;
  }
</style>

<transtion>
  <div v-if="isShow" class="content">coontent</div>
</transtion>
```

![image-20210825222556342](.\typora-user-images\image-20210825222556342.png)

本质是通过增加或者删除元素上面的类样式实现动画效果。

Vue 中的动画可以配合 animate.css 库来进行使用：

```html
下载引入animate.css库
<style>
  .content {
    ...;
  }
  .v-enter-active {
    animation: bounceIn 1s ease-in;
  }
  .v-leave-active {
    animation: bounceOut 1s ease-in;
  }
</style>

<transition enter-active-class="bounceIn" leave-active-class="bounceOut">
  <div class="content animated" v-if="isShow">content</div>
</transition>
```

动画钩子函数：

- before-enter:时刻
- before-leave：时刻
- enter：时段
- leave：时段
- after-enter：时刻
- after-leave：时刻

```js
<transition @enter='enter'>

</transition>

methods:{
    //el:当前的动画元素
    //done：动画结束时调用done方法
    enter(el,done){
		let li = this.$refs.list[this.currentIndex]
        let {x,y} = li.getBoundingClientReact()
        el.style.left = x + 'px'
        el.style.top =  y + 'px'
        el.style.background = `url(${this.lists[this.currentIndex].cover})`
        el.style.backgroundSize = `100% 100%`
        let {x:a,y:b} = this.$refs.cart.getBoundingClientRect()
        el.style.transform = `translate3d(${a-x}px,${b-y}px,0) scale(0,0)`
        el.addEventListener(`transitionend`,done)
    }
    after(){
        this.isShow = false
    }
}
```

`<transition>`标签只能有一个子元素节点，不能有多个同级的子节点。对于多个的情况要使用 transaction-group。

![image-20210826000408542](.\typora-user-images\image-20210826000408542.png)

### 组件的生命周期

1. 初始化事件和生命周期，确定当前实例的父级和子级实例，创建该实例上的事件发布订阅模式，$attrs,$children ,$options,$listener,$refs,$root,$parent,$on,$emit...
2. beforCreate( ){ }:该声生命周期函数一般做混合 ( Vue.mixin( ) ),比如在每个组件中增加一些共有属性或者方法，在这个生命周期函数中无法获取到该实例 data 上的属性和 methods 中的方法,这个生命周期函数中不能获取到自己的子组件及其后代组件，因为后代组件并没有完成渲染
3. 初始化注入（inject）与校验
4. created(){ }: 当前组件实例已经对 data 或 computed 中的数据实现了数据劫持能力，并且也能获取到 methods 中绑定的方法，（data，methods，computed 中的数据都代理到了当前实例上了），但是不能获取到真实的 DOM 元素，可以在此处发送 Ajax。 此时$el 为假值
5. beforeMount( ){ }: 当实例没有被指定对应的 DOM 节点时，该函数和之后的函数是不会被调用的，就是指即没有配置 el 项也没有 手动$mount( ) 的情况下。 该生命周期函数中会在自己的代码最后调用 render 函数。
6. mounted(){ }: 当前组件挂载完成，在这里可以获取前面所有生命周期中存放的属性或者方法，同时实例的$el 属性也有真实 DOM 作为值。在这里也可以发送 Ajax。但是比如在 Ajax 调完后，拿到的数据需要动态的渲染数据并追加到 dom 元素中，这在这里发送 ajax 请求。 需要涉及操作 dom 的逻辑都放在可以
7. beforUpdate(){}: 可以在这里增加一些数据更新，必须是应用到视图上的数据发生变化时才会触发视图重新渲染
8. updated( ){ } :不要再这里修改渲染到视图上的数据
9. beforDestory ( ){ } : 进行事件移除和清空定时器等。
10. destroyed(){ }

![Vue 实例生命周期](https://cn.vuejs.org/images/lifecycle.png)

vm.$mount('str'),其中可以给该方法传递一个css选择器作用的元素。如果不指定的话，vue内部默认将该实例渲染到内存中的一个节点，挂载到内存中的DOM节点的获取方式是 vm.$el。如果需要将该内存中的 DOM 元素加到真实页面中，可以使用 document.body.appendChild(vm.$el)。

vue 的更新是组件级别的重新渲染。

vue 组件实例的销毁方式有：

- 手动移除组件(vm.$destory)
- 路由切换组件

实例销毁只是移除了所有的观察者，移除监听事件，并不会导致视图刷新，已经渲染的视图还是可以看到的。

组件有自己的子组件时，生命周期的执行过程是：父组件执行到自己的 beforeMount 生命周期后，开始执行子组件的所有创建阶段的生命周期函数，在子组件和后代组件的生命周期函数都执行完后，在回到父组件的生命周期函数 mounted 开始执行。（创建阶段）

子组件直接修改了该父组件以 props 方式传递下来的数据，则子组件自己的视图区域中数据会更新，但是父组件中的数据并不会发生改变。

### 组件通信

为什么使用组件：可复用，方便维护，减少不必要的更新操作。尽可能地减少需要选的地组件。Vue 项目中地更新是组件级别地更新。

通信方式：

- props：实现父传子

- $on/$emi：t 实现子传父

- $parent/$children [index] | $root： (不建议在项目中使用，使用的话，这样提高了组件之间的耦合性。)

- $dispatch(eventName,xxx,...) (开发者需要手写，vue1 中有此方法)

- $broadcast(eventName,xxx,...) (开发者需要手写，vue1 中有此方法)

- $attrs/$listeners

  给子组件标签绑定的一些标签属性如果没有在子组件内部没有使用 props 来注册，那么这些标签属性都默认会添加到组件最外层的标签上，并且在$attrs 中也能获取到。如果不想让组件的最外层标签上出现这些组件标签上的属性（class 和 style 属性除外），那么可以在组件内部配置：inheritAttrs：false 或者 在子组件内部用 props 注册获取。

  如果子组件希望将父组件以标签属性方式传递的数据全部完整的传递给自己的子代组件（孙组件），那么可以在子组件内部通过在自己子组件标签上直接使用 v-bind = "$attrs"  或者 v-on="$listeners" 直接进行展开传递给自己的子组件。

  当开发者给组件标签上通过 v-on 绑定一些事件，当这些事件的事件名和 js 中原生事件名一样时，并不代表就是在组件上绑定了一个原生事件，还是相当于给组件的发布订阅事件池中添加了一个方法。如果想给组件绑定的就是原生事件，那么可以加上.native 以代表原生事件，那么该原生事件将被绑定到组件的最外层元素上。

- provide / inject :在祖先组件中声明一些公共数据，在后代组件中可以注入，比较混乱，可能有命名冲突，组件库中常用

  在父组件中声明公共数据，在后代组件中注入。原理：在祖先组件上配置一个 provide 项，当后代组件注入时，可以沿着组件层级一层层往上查找，上层有提供 provide 的话就注册到后代组件自己的身上。

  不足：比较容易混乱，后代组件不停向上查找，不确定具体数据来自那个祖先组件。主要用于高阶插件或者组件库中。如果上层组件和上上层组件都提供了同名的属性，那么只取最近一层的那个组件的。

  ```js
  祖先组件中：
  provide:{
  	key:value,
  	...
  }

  provide(){
  	return {vm:this}
  }

  后代组件中：

  方式一：
  inject:['vm']

  方式二：
  inject:{
  	vm1:'vm'  //起别名
  }

  方式三：
  inject：{
  	vm1:{
  		from: 'vm'
  		default:'null'
  	}
  }


  // inject会向上查找,注意考虑同名数据覆盖的情况，逐层向上查找，找到后将停止继续网上查找
  ```

  - $refs：获取组件实例对象或者获取真实的 DOM 元素,当 ref 和 v-for 连用的时候，ref 出现的值可能是数组，其他情况下只有一个值.

    作用是获取真实的 dom 元素，当 ref 被用在 v-for 生成的 dom 元素时，$refs才可能是一个数组，其他时候都是一个元素。如果用在组件标签上时，代表的就是当前组件的实例。（ref 不仅可以用在元素dom元素上，还可以用在组件上，而$children 中存放的之后组件实例）

  - eventBus ,在生命周期函数中使用 eventBus 时需要注意后代组件之间的挂载顺序。 eventBus（事件总集）：常常在 main.js 中向 Vue 的原型对象中添加一个属性$bus, ` Vue.prototype.$bus = new Vue() ` 。事件的发布和订阅者往往都是同一个实例对象。

    ```js
    Vue.prototype.$bus = new Vue();
    ```

  - vuex

扩展：

$on/$emit 的怪异写法：

`<组件名 :attr='key' @updata:attr='newval => key = newval'></组件名>` 简写：

`<组件名 :attr.sync='key'></组件名>`

`<组件名 :value='key' @input='newval => key = newval'></组件名>`

`<组件名 v-model='key'></组件名>`

v-model 和.async 的区别是 v-model 的默认绑定的响应式数据就只能叫 value，而.async 则可以自定义。

```js
<com1 :count="count" @update:count="changeCount"></com1>

methods:{
	changeCount(newVal){
		this.count = newVal
	}
}


<com1 :count="count" @update:count="newVal=>count=newVal"></com1>


<com1 :count.sync="count"></com1>


<com1 :value="count" @input="newVal=>count=newVal"></com1>


<com1 v-model="count"></com1>
v-model的局限性是：给组件标签绑定的属性默认只能是value，如果需要传递多个其他的的标签属性，则还是需要使用.sync修饰符。




com1组件内部：
<button @click="changeCount"></button>


props:['count','value'],
methods:{
	changeCount(){
		this.$emit('update:count',value)
	},
	changeValue(){
		this.$emit('input',value)
	}
}
```

在 vue 项目中，.vue 文件后缀名地文件最后是由 vue-loader 加载器进行解析处理为一个对象。

通过@vue/cli 脚手架下载的 Vue 项目默认使用的是 vue-runtime-only 版本，不包含编译部分。如果要使用含有 compiler 本版时，可以通过 vue.config.js 文件进行配置：

```js
module exports ={
    runtimeCompiler:true
}
```

项目入口文件和项目中就可以使用一下写法了：

```js
import Vue from 'vue';
import App from './App.vue';

new Vue({
  template: '<div>hello</div>' // template写法
  // render: h => h(App),
  // ...App,
}).$mount('#app');
```

注意这种模板 template 和.vue 文件中的 tempalte 部分是不同的，后者借助 vue-loader 处理的，不用依赖 vue 库中含有 compiler 版本。这也是 vue 脚手架创建的项目中默认使用 runtime 版本的原因。

面试点：

原生的表单标签中使用 v-model 是否等价于 ：value + @input 事件的语法糖？

两者的区别：

```js
<input type='text' :value='value' @input='(e)=>value = e.target.value' />


<input type='text' v-model='value'/>
```

使用 v-model 的表现：

![image-20211223164036406](.\typora-user-images\image-20211223164036406.png)

中文输入过程没有按下空格键时，是没有实时进行数据同步的。

对于手写:value + @input 事件的表现：

![image-20211223164232235](.\typora-user-images\image-20211223164232235.png)

数据是实时同步的。

:value='code' + @input='handleInput' v-mode 好像等价于前面的语法糖写法，但是是存在不同的（面试也可能问），就是 v-model 是否等价于 :value + @input 事件。 对于元素表单标签绑定 v-model 时，vue 框架内部会处理输入法问题，而且不同的标签解析出的结果不一样，比如复选框绑定 v-mode 类似于 :checked + @change 事件

在线编辑的重点目的是：拿到代码字符转，对代码字符串处理后，基于字符串创建组件并动态挂载到指定的组件元素中（

在代码运行期间创建组件并渲染）。 核心思路就是将代码字符转转为一个对象，该对象中可以有 tempalte 属性，生命周期属性，data 属性，methods 属性等等。然后以该对象为组件的配置对象，调用 Vue.extends(obj),该函数返回一个 Vue 组件对象实例，该组件实例的原型上有$mount 方法。

Vue.extends(obj)返回值：

![image-20211223170545080](.\typora-user-images\image-20211223170545080.png)

(Vue.extends(obj)) .$mount().$el:

![image-20211223170801446](.\typora-user-images\image-20211223170801446.png)

该属性就是一个真实的 DOM 元素，可以被追加到其他元素中展示。

Vue 项目中的每个组件实例都可以通过属性（this.$options.\_base）访问到 Vue 库的构造函数---Vue,而不用再手动引入 Vue 到组件中。

### 递归组件
